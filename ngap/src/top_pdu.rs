// Autogenerated from NGAP-PDU-Descriptions.asn
#![allow(clippy::all)]
use anyhow::Result;
use asn1_per::{aper::*, *};
use async_trait::async_trait;

use super::pdu::*;
use crate::common::Criticality;

// NgapPdu
#[derive(Clone, Debug)]
pub enum NgapPdu {
	InitiatingMessage(InitiatingMessage),
	SuccessfulOutcome(SuccessfulOutcome),
	UnsuccessfulOutcome(UnsuccessfulOutcome),
}

impl NgapPdu {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, true)?;
		if extended {
			return Err(ThreeGppAsn1PerError::new(
				"CHOICE additions not implemented",
			));
		}
		match idx {
			0 => Ok(Self::InitiatingMessage(InitiatingMessage::decode(data)?)),
			1 => Ok(Self::SuccessfulOutcome(SuccessfulOutcome::decode(data)?)),
			2 => Ok(Self::UnsuccessfulOutcome(UnsuccessfulOutcome::decode(
				data,
			)?)),
			_ => Err(ThreeGppAsn1PerError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		match self {
			Self::InitiatingMessage(x) => {
				encode::encode_choice_idx(data, 0, 2, true, 0, false)?;
				x.encode(data).map_err(ThreeGppAsn1PerError::from)
			}
			Self::SuccessfulOutcome(x) => {
				encode::encode_choice_idx(data, 0, 2, true, 1, false)?;
				x.encode(data).map_err(ThreeGppAsn1PerError::from)
			}
			Self::UnsuccessfulOutcome(x) => {
				encode::encode_choice_idx(data, 0, 2, true, 2, false)?;
				x.encode(data).map_err(ThreeGppAsn1PerError::from)
			}
		}
	}
}

impl PerCodec for NgapPdu {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		NgapPdu::decode_inner(data).map_err(|mut e: ThreeGppAsn1PerError| {
			e.codec_error.push_context("NgapPdu");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		self.encode_inner(data)
			.map_err(|mut e: ThreeGppAsn1PerError| {
				e.codec_error.push_context("NgapPdu");
				e
			})
	}
}
pub trait ToNgapPdu {
	fn to_pdu(self) -> NgapPdu;
}

pub struct AmfConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for AmfConfigurationUpdateProcedure {
	type TopPdu = NgapPdu;
	type Request = AmfConfigurationUpdate;
	type Success = AmfConfigurationUpdateAcknowledge;
	type Failure = AmfConfigurationUpdateFailure;
	const CODE: u8 = 0;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: AmfConfigurationUpdate,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<AmfConfigurationUpdateProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::AmfConfigurationUpdateAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfConfigurationUpdate(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::AmfConfigurationUpdateAcknowledge(x)) => {
				Ok(x)
			}
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::AmfConfigurationUpdateFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::AmfConfigurationUpdate(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for AmfConfigurationUpdate {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfConfigurationUpdate(self))
	}
}

impl ToNgapPdu for AmfConfigurationUpdateAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::AmfConfigurationUpdateAcknowledge(self))
	}
}

impl ToNgapPdu for AmfConfigurationUpdateFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::AmfConfigurationUpdateFailure(self))
	}
}

pub struct AmfcpRelocationIndicationProcedure {}

#[async_trait]
impl Indication for AmfcpRelocationIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = AmfcpRelocationIndication;
	const CODE: u8 = 64;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: AmfcpRelocationIndication,
	) {
		<T as IndicationHandler<AmfcpRelocationIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfcpRelocationIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::AmfcpRelocationIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for AmfcpRelocationIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfcpRelocationIndication(self))
	}
}

pub struct AmfStatusIndicationProcedure {}

#[async_trait]
impl Indication for AmfStatusIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = AmfStatusIndication;
	const CODE: u8 = 1;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: AmfStatusIndication,
	) {
		<T as IndicationHandler<AmfStatusIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfStatusIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::AmfStatusIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for AmfStatusIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::AmfStatusIndication(self))
	}
}

pub struct BroadcastSessionModificationProcedure {}

#[async_trait]
impl Procedure for BroadcastSessionModificationProcedure {
	type TopPdu = NgapPdu;
	type Request = BroadcastSessionModificationRequest;
	type Success = BroadcastSessionModificationResponse;
	type Failure = BroadcastSessionModificationFailure;
	const CODE: u8 = 66;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: BroadcastSessionModificationRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<BroadcastSessionModificationProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(
					SuccessfulOutcome::BroadcastSessionModificationResponse(r),
				),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionModificationRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(
				SuccessfulOutcome::BroadcastSessionModificationResponse(x),
			) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(
				UnsuccessfulOutcome::BroadcastSessionModificationFailure(x),
			) => Err(RequestError::UnsuccessfulOutcome(x)),
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionModificationRequest(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for BroadcastSessionModificationRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionModificationRequest(self))
	}
}

impl ToNgapPdu for BroadcastSessionModificationResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionModificationResponse(
			self,
		))
	}
}

impl ToNgapPdu for BroadcastSessionModificationFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::BroadcastSessionModificationFailure(
			self,
		))
	}
}

pub struct BroadcastSessionReleaseProcedure {}

#[async_trait]
impl Procedure for BroadcastSessionReleaseProcedure {
	type TopPdu = NgapPdu;
	type Request = BroadcastSessionReleaseRequest;
	type Success = BroadcastSessionReleaseResponse;
	type Failure = ();
	const CODE: u8 = 67;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: BroadcastSessionReleaseRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<BroadcastSessionReleaseProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionReleaseResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionReleaseResponse(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for BroadcastSessionReleaseRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequest(self))
	}
}

impl ToNgapPdu for BroadcastSessionReleaseResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionReleaseResponse(self))
	}
}

pub struct BroadcastSessionReleaseRequiredProcedure {}

#[async_trait]
impl Indication for BroadcastSessionReleaseRequiredProcedure {
	type TopPdu = NgapPdu;
	type Request = BroadcastSessionReleaseRequired;
	const CODE: u8 = 75;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: BroadcastSessionReleaseRequired,
	) {
		<T as IndicationHandler<BroadcastSessionReleaseRequiredProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequired(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequired(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for BroadcastSessionReleaseRequired {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionReleaseRequired(self))
	}
}

pub struct BroadcastSessionSetupProcedure {}

#[async_trait]
impl Procedure for BroadcastSessionSetupProcedure {
	type TopPdu = NgapPdu;
	type Request = BroadcastSessionSetupRequest;
	type Success = BroadcastSessionSetupResponse;
	type Failure = BroadcastSessionSetupFailure;
	const CODE: u8 = 68;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: BroadcastSessionSetupRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<BroadcastSessionSetupProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionSetupResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionSetupRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionSetupResponse(x)) => {
				Ok(x)
			}
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::BroadcastSessionSetupFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionSetupRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for BroadcastSessionSetupRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::BroadcastSessionSetupRequest(self))
	}
}

impl ToNgapPdu for BroadcastSessionSetupResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::BroadcastSessionSetupResponse(self))
	}
}

impl ToNgapPdu for BroadcastSessionSetupFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::BroadcastSessionSetupFailure(self))
	}
}

pub struct CellTrafficTraceProcedure {}

#[async_trait]
impl Indication for CellTrafficTraceProcedure {
	type TopPdu = NgapPdu;
	type Request = CellTrafficTrace;
	const CODE: u8 = 2;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: CellTrafficTrace,
	) {
		<T as IndicationHandler<CellTrafficTraceProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::CellTrafficTrace(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::CellTrafficTrace(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for CellTrafficTrace {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::CellTrafficTrace(self))
	}
}

pub struct ConnectionEstablishmentIndicationProcedure {}

#[async_trait]
impl Indication for ConnectionEstablishmentIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = ConnectionEstablishmentIndication;
	const CODE: u8 = 65;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: ConnectionEstablishmentIndication,
	) {
		<T as IndicationHandler<ConnectionEstablishmentIndicationProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::ConnectionEstablishmentIndication(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::ConnectionEstablishmentIndication(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for ConnectionEstablishmentIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::ConnectionEstablishmentIndication(self))
	}
}

pub struct DeactivateTraceProcedure {}

#[async_trait]
impl Indication for DeactivateTraceProcedure {
	type TopPdu = NgapPdu;
	type Request = DeactivateTrace;
	const CODE: u8 = 3;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DeactivateTrace,
	) {
		<T as IndicationHandler<DeactivateTraceProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DeactivateTrace(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DeactivateTrace(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DeactivateTrace {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DeactivateTrace(self))
	}
}

pub struct DistributionSetupProcedure {}

#[async_trait]
impl Procedure for DistributionSetupProcedure {
	type TopPdu = NgapPdu;
	type Request = DistributionSetupRequest;
	type Success = DistributionSetupResponse;
	type Failure = DistributionSetupFailure;
	const CODE: u8 = 69;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: DistributionSetupRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<DistributionSetupProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionSetupResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DistributionSetupRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionSetupResponse(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::DistributionSetupFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DistributionSetupRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DistributionSetupRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DistributionSetupRequest(self))
	}
}

impl ToNgapPdu for DistributionSetupResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionSetupResponse(self))
	}
}

impl ToNgapPdu for DistributionSetupFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::DistributionSetupFailure(self))
	}
}

pub struct DistributionReleaseProcedure {}

#[async_trait]
impl Procedure for DistributionReleaseProcedure {
	type TopPdu = NgapPdu;
	type Request = DistributionReleaseRequest;
	type Success = DistributionReleaseResponse;
	type Failure = ();
	const CODE: u8 = 70;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: DistributionReleaseRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<DistributionReleaseProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionReleaseResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DistributionReleaseRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionReleaseResponse(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DistributionReleaseRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DistributionReleaseRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DistributionReleaseRequest(self))
	}
}

impl ToNgapPdu for DistributionReleaseResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::DistributionReleaseResponse(self))
	}
}

pub struct DownlinkNasTransportProcedure {}

#[async_trait]
impl Indication for DownlinkNasTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkNasTransport;
	const CODE: u8 = 4;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkNasTransport,
	) {
		<T as IndicationHandler<DownlinkNasTransportProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNasTransport(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNasTransport(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkNasTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNasTransport(self))
	}
}

pub struct DownlinkNonUeAssociatedNrPPaTransportProcedure {}

#[async_trait]
impl Indication for DownlinkNonUeAssociatedNrPPaTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkNonUeAssociatedNrPPaTransport;
	const CODE: u8 = 5;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkNonUeAssociatedNrPPaTransport,
	) {
		<T as IndicationHandler<DownlinkNonUeAssociatedNrPPaTransportProcedure>>::handle(
			provider, req,
		)
		.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNonUeAssociatedNrPPaTransport(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(
				InitiatingMessage::DownlinkNonUeAssociatedNrPPaTransport(x),
			) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkNonUeAssociatedNrPPaTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkNonUeAssociatedNrPPaTransport(
			self,
		))
	}
}

pub struct DownlinkRanConfigurationTransferProcedure {}

#[async_trait]
impl Indication for DownlinkRanConfigurationTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkRanConfigurationTransfer;
	const CODE: u8 = 6;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkRanConfigurationTransfer,
	) {
		<T as IndicationHandler<DownlinkRanConfigurationTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanConfigurationTransfer(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanConfigurationTransfer(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkRanConfigurationTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanConfigurationTransfer(self))
	}
}

pub struct DownlinkRanEarlyStatusTransferProcedure {}

#[async_trait]
impl Indication for DownlinkRanEarlyStatusTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkRanEarlyStatusTransfer;
	const CODE: u8 = 63;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkRanEarlyStatusTransfer,
	) {
		<T as IndicationHandler<DownlinkRanEarlyStatusTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanEarlyStatusTransfer(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanEarlyStatusTransfer(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkRanEarlyStatusTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanEarlyStatusTransfer(self))
	}
}

pub struct DownlinkRanStatusTransferProcedure {}

#[async_trait]
impl Indication for DownlinkRanStatusTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkRanStatusTransfer;
	const CODE: u8 = 7;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkRanStatusTransfer,
	) {
		<T as IndicationHandler<DownlinkRanStatusTransferProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanStatusTransfer(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanStatusTransfer(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkRanStatusTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRanStatusTransfer(self))
	}
}

pub struct DownlinkUeAssociatedNrPPaTransportProcedure {}

#[async_trait]
impl Indication for DownlinkUeAssociatedNrPPaTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkUeAssociatedNrPPaTransport;
	const CODE: u8 = 8;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkUeAssociatedNrPPaTransport,
	) {
		<T as IndicationHandler<DownlinkUeAssociatedNrPPaTransportProcedure>>::handle(
			provider, req,
		)
		.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkUeAssociatedNrPPaTransport(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkUeAssociatedNrPPaTransport(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkUeAssociatedNrPPaTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkUeAssociatedNrPPaTransport(self))
	}
}

pub struct ErrorIndicationProcedure {}

#[async_trait]
impl Indication for ErrorIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = ErrorIndication;
	const CODE: u8 = 9;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: ErrorIndication,
	) {
		<T as IndicationHandler<ErrorIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::ErrorIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::ErrorIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for ErrorIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::ErrorIndication(self))
	}
}

pub struct HandoverCancelProcedure {}

#[async_trait]
impl Procedure for HandoverCancelProcedure {
	type TopPdu = NgapPdu;
	type Request = HandoverCancel;
	type Success = HandoverCancelAcknowledge;
	type Failure = ();
	const CODE: u8 = 10;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: HandoverCancel,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<HandoverCancelProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCancelAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverCancel(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCancelAcknowledge(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::HandoverCancel(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for HandoverCancel {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverCancel(self))
	}
}

impl ToNgapPdu for HandoverCancelAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCancelAcknowledge(self))
	}
}

pub struct HandoverNotificationProcedure {}

#[async_trait]
impl Indication for HandoverNotificationProcedure {
	type TopPdu = NgapPdu;
	type Request = HandoverNotify;
	const CODE: u8 = 11;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: HandoverNotify,
	) {
		<T as IndicationHandler<HandoverNotificationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverNotify(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::HandoverNotify(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for HandoverNotify {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverNotify(self))
	}
}

pub struct HandoverPreparationProcedure {}

#[async_trait]
impl Procedure for HandoverPreparationProcedure {
	type TopPdu = NgapPdu;
	type Request = HandoverRequired;
	type Success = HandoverCommand;
	type Failure = HandoverPreparationFailure;
	const CODE: u8 = 12;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: HandoverRequired,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<HandoverPreparationProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCommand(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequired(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCommand(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverPreparationFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequired(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for HandoverRequired {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequired(self))
	}
}

impl ToNgapPdu for HandoverCommand {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverCommand(self))
	}
}

impl ToNgapPdu for HandoverPreparationFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverPreparationFailure(self))
	}
}

pub struct HandoverResourceAllocationProcedure {}

#[async_trait]
impl Procedure for HandoverResourceAllocationProcedure {
	type TopPdu = NgapPdu;
	type Request = HandoverRequest;
	type Success = HandoverRequestAcknowledge;
	type Failure = HandoverFailure;
	const CODE: u8 = 13;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: HandoverRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<HandoverResourceAllocationProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverRequestAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverRequestAcknowledge(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for HandoverRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverRequest(self))
	}
}

impl ToNgapPdu for HandoverRequestAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::HandoverRequestAcknowledge(self))
	}
}

impl ToNgapPdu for HandoverFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::HandoverFailure(self))
	}
}

pub struct HandoverSuccessProcedure {}

#[async_trait]
impl Indication for HandoverSuccessProcedure {
	type TopPdu = NgapPdu;
	type Request = HandoverSuccess;
	const CODE: u8 = 61;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: HandoverSuccess,
	) {
		<T as IndicationHandler<HandoverSuccessProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverSuccess(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::HandoverSuccess(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for HandoverSuccess {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::HandoverSuccess(self))
	}
}

pub struct InitialContextSetupProcedure {}

#[async_trait]
impl Procedure for InitialContextSetupProcedure {
	type TopPdu = NgapPdu;
	type Request = InitialContextSetupRequest;
	type Success = InitialContextSetupResponse;
	type Failure = InitialContextSetupFailure;
	const CODE: u8 = 14;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: InitialContextSetupRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<InitialContextSetupProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::InitialContextSetupResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::InitialContextSetupRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::InitialContextSetupResponse(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::InitialContextSetupFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::InitialContextSetupRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for InitialContextSetupRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::InitialContextSetupRequest(self))
	}
}

impl ToNgapPdu for InitialContextSetupResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::InitialContextSetupResponse(self))
	}
}

impl ToNgapPdu for InitialContextSetupFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::InitialContextSetupFailure(self))
	}
}

pub struct InitialUeMessageProcedure {}

#[async_trait]
impl Indication for InitialUeMessageProcedure {
	type TopPdu = NgapPdu;
	type Request = InitialUeMessage;
	const CODE: u8 = 15;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: InitialUeMessage,
	) {
		<T as IndicationHandler<InitialUeMessageProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::InitialUeMessage(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::InitialUeMessage(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for InitialUeMessage {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::InitialUeMessage(self))
	}
}

pub struct LocationReportProcedure {}

#[async_trait]
impl Indication for LocationReportProcedure {
	type TopPdu = NgapPdu;
	type Request = LocationReport;
	const CODE: u8 = 18;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: LocationReport,
	) {
		<T as IndicationHandler<LocationReportProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReport(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::LocationReport(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for LocationReport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReport(self))
	}
}

pub struct LocationReportingControlProcedure {}

#[async_trait]
impl Indication for LocationReportingControlProcedure {
	type TopPdu = NgapPdu;
	type Request = LocationReportingControl;
	const CODE: u8 = 16;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: LocationReportingControl,
	) {
		<T as IndicationHandler<LocationReportingControlProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingControl(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingControl(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for LocationReportingControl {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingControl(self))
	}
}

pub struct LocationReportingFailureIndicationProcedure {}

#[async_trait]
impl Indication for LocationReportingFailureIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = LocationReportingFailureIndication;
	const CODE: u8 = 17;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: LocationReportingFailureIndication,
	) {
		<T as IndicationHandler<LocationReportingFailureIndicationProcedure>>::handle(
			provider, req,
		)
		.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingFailureIndication(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingFailureIndication(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for LocationReportingFailureIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::LocationReportingFailureIndication(self))
	}
}

pub struct MulticastSessionActivationProcedure {}

#[async_trait]
impl Procedure for MulticastSessionActivationProcedure {
	type TopPdu = NgapPdu;
	type Request = MulticastSessionActivationRequest;
	type Success = MulticastSessionActivationResponse;
	type Failure = MulticastSessionActivationFailure;
	const CODE: u8 = 71;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: MulticastSessionActivationRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<MulticastSessionActivationProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionActivationResponse(
					r,
				)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionActivationRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionActivationResponse(
				x,
			)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(
				UnsuccessfulOutcome::MulticastSessionActivationFailure(x),
			) => Err(RequestError::UnsuccessfulOutcome(x)),
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionActivationRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for MulticastSessionActivationRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionActivationRequest(self))
	}
}

impl ToNgapPdu for MulticastSessionActivationResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionActivationResponse(self))
	}
}

impl ToNgapPdu for MulticastSessionActivationFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::MulticastSessionActivationFailure(self))
	}
}

pub struct MulticastSessionDeactivationProcedure {}

#[async_trait]
impl Procedure for MulticastSessionDeactivationProcedure {
	type TopPdu = NgapPdu;
	type Request = MulticastSessionDeactivationRequest;
	type Success = MulticastSessionDeactivationResponse;
	type Failure = ();
	const CODE: u8 = 72;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: MulticastSessionDeactivationRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<MulticastSessionDeactivationProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(
					SuccessfulOutcome::MulticastSessionDeactivationResponse(r),
				),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionDeactivationRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(
				SuccessfulOutcome::MulticastSessionDeactivationResponse(x),
			) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionDeactivationRequest(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for MulticastSessionDeactivationRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionDeactivationRequest(self))
	}
}

impl ToNgapPdu for MulticastSessionDeactivationResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionDeactivationResponse(
			self,
		))
	}
}

pub struct MulticastSessionUpdateProcedure {}

#[async_trait]
impl Procedure for MulticastSessionUpdateProcedure {
	type TopPdu = NgapPdu;
	type Request = MulticastSessionUpdateRequest;
	type Success = MulticastSessionUpdateResponse;
	type Failure = MulticastSessionUpdateFailure;
	const CODE: u8 = 73;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: MulticastSessionUpdateRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<MulticastSessionUpdateProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionUpdateResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionUpdateRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionUpdateResponse(x)) => {
				Ok(x)
			}
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::MulticastSessionUpdateFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionUpdateRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for MulticastSessionUpdateRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastSessionUpdateRequest(self))
	}
}

impl ToNgapPdu for MulticastSessionUpdateResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::MulticastSessionUpdateResponse(self))
	}
}

impl ToNgapPdu for MulticastSessionUpdateFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::MulticastSessionUpdateFailure(self))
	}
}

pub struct MulticastGroupPagingProcedure {}

#[async_trait]
impl Indication for MulticastGroupPagingProcedure {
	type TopPdu = NgapPdu;
	type Request = MulticastGroupPaging;
	const CODE: u8 = 74;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: MulticastGroupPaging,
	) {
		<T as IndicationHandler<MulticastGroupPagingProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastGroupPaging(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::MulticastGroupPaging(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for MulticastGroupPaging {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::MulticastGroupPaging(self))
	}
}

pub struct NasNonDeliveryIndicationProcedure {}

#[async_trait]
impl Indication for NasNonDeliveryIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = NasNonDeliveryIndication;
	const CODE: u8 = 19;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: NasNonDeliveryIndication,
	) {
		<T as IndicationHandler<NasNonDeliveryIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::NasNonDeliveryIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::NasNonDeliveryIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for NasNonDeliveryIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::NasNonDeliveryIndication(self))
	}
}

pub struct NgResetProcedure {}

#[async_trait]
impl Procedure for NgResetProcedure {
	type TopPdu = NgapPdu;
	type Request = NgReset;
	type Success = NgResetAcknowledge;
	type Failure = ();
	const CODE: u8 = 20;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: NgReset,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<NgResetProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgResetAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::NgReset(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgResetAcknowledge(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::NgReset(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for NgReset {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::NgReset(self))
	}
}

impl ToNgapPdu for NgResetAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgResetAcknowledge(self))
	}
}

pub struct NgSetupProcedure {}

#[async_trait]
impl Procedure for NgSetupProcedure {
	type TopPdu = NgapPdu;
	type Request = NgSetupRequest;
	type Success = NgSetupResponse;
	type Failure = NgSetupFailure;
	const CODE: u8 = 21;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: NgSetupRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<NgSetupProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgSetupResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::NgSetupRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgSetupResponse(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::NgSetupFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::NgSetupRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for NgSetupRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::NgSetupRequest(self))
	}
}

impl ToNgapPdu for NgSetupResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::NgSetupResponse(self))
	}
}

impl ToNgapPdu for NgSetupFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::NgSetupFailure(self))
	}
}

pub struct OverloadStartProcedure {}

#[async_trait]
impl Indication for OverloadStartProcedure {
	type TopPdu = NgapPdu;
	type Request = OverloadStart;
	const CODE: u8 = 22;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: OverloadStart,
	) {
		<T as IndicationHandler<OverloadStartProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStart(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStart(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for OverloadStart {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStart(self))
	}
}

pub struct OverloadStopProcedure {}

#[async_trait]
impl Indication for OverloadStopProcedure {
	type TopPdu = NgapPdu;
	type Request = OverloadStop;
	const CODE: u8 = 23;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: OverloadStop,
	) {
		<T as IndicationHandler<OverloadStopProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStop(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStop(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for OverloadStop {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::OverloadStop(self))
	}
}

pub struct PagingProcedure {}

#[async_trait]
impl Indication for PagingProcedure {
	type TopPdu = NgapPdu;
	type Request = Paging;
	const CODE: u8 = 24;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: Paging,
	) {
		<T as IndicationHandler<PagingProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::Paging(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::Paging(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for Paging {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::Paging(self))
	}
}

pub struct PathSwitchRequestProcedure {}

#[async_trait]
impl Procedure for PathSwitchRequestProcedure {
	type TopPdu = NgapPdu;
	type Request = PathSwitchRequest;
	type Success = PathSwitchRequestAcknowledge;
	type Failure = PathSwitchRequestFailure;
	const CODE: u8 = 25;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PathSwitchRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PathSwitchRequestProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PathSwitchRequestAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PathSwitchRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PathSwitchRequestAcknowledge(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PathSwitchRequestFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PathSwitchRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PathSwitchRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PathSwitchRequest(self))
	}
}

impl ToNgapPdu for PathSwitchRequestAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PathSwitchRequestAcknowledge(self))
	}
}

impl ToNgapPdu for PathSwitchRequestFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::PathSwitchRequestFailure(self))
	}
}

pub struct PduSessionResourceModifyProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceModifyProcedure {
	type TopPdu = NgapPdu;
	type Request = PduSessionResourceModifyRequest;
	type Success = PduSessionResourceModifyResponse;
	type Failure = ();
	const CODE: u8 = 26;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PduSessionResourceModifyRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PduSessionResourceModifyProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyResponse(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PduSessionResourceModifyRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyRequest(self))
	}
}

impl ToNgapPdu for PduSessionResourceModifyResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyResponse(self))
	}
}

pub struct PduSessionResourceModifyIndicationProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceModifyIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = PduSessionResourceModifyIndication;
	type Success = PduSessionResourceModifyConfirm;
	type Failure = ();
	const CODE: u8 = 27;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PduSessionResourceModifyIndication,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PduSessionResourceModifyIndicationProcedure>>::request(
			provider, req,
		)
		.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyConfirm(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyIndication(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyConfirm(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyIndication(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PduSessionResourceModifyIndication {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceModifyIndication(self))
	}
}

impl ToNgapPdu for PduSessionResourceModifyConfirm {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceModifyConfirm(self))
	}
}

pub struct PduSessionResourceNotifyProcedure {}

#[async_trait]
impl Indication for PduSessionResourceNotifyProcedure {
	type TopPdu = NgapPdu;
	type Request = PduSessionResourceNotify;
	const CODE: u8 = 30;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: PduSessionResourceNotify,
	) {
		<T as IndicationHandler<PduSessionResourceNotifyProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceNotify(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceNotify(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PduSessionResourceNotify {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceNotify(self))
	}
}

pub struct PduSessionResourceReleaseProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceReleaseProcedure {
	type TopPdu = NgapPdu;
	type Request = PduSessionResourceReleaseCommand;
	type Success = PduSessionResourceReleaseResponse;
	type Failure = ();
	const CODE: u8 = 28;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PduSessionResourceReleaseCommand,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PduSessionResourceReleaseProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceReleaseResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceReleaseCommand(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceReleaseResponse(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceReleaseCommand(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PduSessionResourceReleaseCommand {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceReleaseCommand(self))
	}
}

impl ToNgapPdu for PduSessionResourceReleaseResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceReleaseResponse(self))
	}
}

pub struct PduSessionResourceSetupProcedure {}

#[async_trait]
impl Procedure for PduSessionResourceSetupProcedure {
	type TopPdu = NgapPdu;
	type Request = PduSessionResourceSetupRequest;
	type Success = PduSessionResourceSetupResponse;
	type Failure = ();
	const CODE: u8 = 29;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PduSessionResourceSetupRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PduSessionResourceSetupProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceSetupResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceSetupRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceSetupResponse(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceSetupRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PduSessionResourceSetupRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PduSessionResourceSetupRequest(self))
	}
}

impl ToNgapPdu for PduSessionResourceSetupResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PduSessionResourceSetupResponse(self))
	}
}

pub struct PwsCancelProcedure {}

#[async_trait]
impl Procedure for PwsCancelProcedure {
	type TopPdu = NgapPdu;
	type Request = PwsCancelRequest;
	type Success = PwsCancelResponse;
	type Failure = ();
	const CODE: u8 = 32;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: PwsCancelRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<PwsCancelProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PwsCancelResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsCancelRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PwsCancelResponse(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PwsCancelRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PwsCancelRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsCancelRequest(self))
	}
}

impl ToNgapPdu for PwsCancelResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::PwsCancelResponse(self))
	}
}

pub struct PwsFailureIndicationProcedure {}

#[async_trait]
impl Indication for PwsFailureIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = PwsFailureIndication;
	const CODE: u8 = 33;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: PwsFailureIndication,
	) {
		<T as IndicationHandler<PwsFailureIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsFailureIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PwsFailureIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PwsFailureIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsFailureIndication(self))
	}
}

pub struct PwsRestartIndicationProcedure {}

#[async_trait]
impl Indication for PwsRestartIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = PwsRestartIndication;
	const CODE: u8 = 34;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: PwsRestartIndication,
	) {
		<T as IndicationHandler<PwsRestartIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsRestartIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::PwsRestartIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for PwsRestartIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::PwsRestartIndication(self))
	}
}

pub struct RanConfigurationUpdateProcedure {}

#[async_trait]
impl Procedure for RanConfigurationUpdateProcedure {
	type TopPdu = NgapPdu;
	type Request = RanConfigurationUpdate;
	type Success = RanConfigurationUpdateAcknowledge;
	type Failure = RanConfigurationUpdateFailure;
	const CODE: u8 = 35;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: RanConfigurationUpdate,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<RanConfigurationUpdateProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::RanConfigurationUpdateAcknowledge(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::RanConfigurationUpdate(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::RanConfigurationUpdateAcknowledge(x)) => {
				Ok(x)
			}
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::RanConfigurationUpdateFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::RanConfigurationUpdate(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for RanConfigurationUpdate {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::RanConfigurationUpdate(self))
	}
}

impl ToNgapPdu for RanConfigurationUpdateAcknowledge {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::RanConfigurationUpdateAcknowledge(self))
	}
}

impl ToNgapPdu for RanConfigurationUpdateFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::RanConfigurationUpdateFailure(self))
	}
}

pub struct RancpRelocationIndicationProcedure {}

#[async_trait]
impl Indication for RancpRelocationIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = RancpRelocationIndication;
	const CODE: u8 = 57;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: RancpRelocationIndication,
	) {
		<T as IndicationHandler<RancpRelocationIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::RancpRelocationIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::RancpRelocationIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for RancpRelocationIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::RancpRelocationIndication(self))
	}
}

pub struct RerouteNasRequestProcedure {}

#[async_trait]
impl Indication for RerouteNasRequestProcedure {
	type TopPdu = NgapPdu;
	type Request = RerouteNasRequest;
	const CODE: u8 = 36;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: RerouteNasRequest,
	) {
		<T as IndicationHandler<RerouteNasRequestProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::RerouteNasRequest(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::RerouteNasRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for RerouteNasRequest {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::RerouteNasRequest(self))
	}
}

pub struct RetrieveUeInformationProcedure {}

#[async_trait]
impl Indication for RetrieveUeInformationProcedure {
	type TopPdu = NgapPdu;
	type Request = RetrieveUeInformation;
	const CODE: u8 = 55;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: RetrieveUeInformation,
	) {
		<T as IndicationHandler<RetrieveUeInformationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::RetrieveUeInformation(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::RetrieveUeInformation(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for RetrieveUeInformation {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::RetrieveUeInformation(self))
	}
}

pub struct RrcInactiveTransitionReportProcedure {}

#[async_trait]
impl Indication for RrcInactiveTransitionReportProcedure {
	type TopPdu = NgapPdu;
	type Request = RrcInactiveTransitionReport;
	const CODE: u8 = 37;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: RrcInactiveTransitionReport,
	) {
		<T as IndicationHandler<RrcInactiveTransitionReportProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::RrcInactiveTransitionReport(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::RrcInactiveTransitionReport(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for RrcInactiveTransitionReport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::RrcInactiveTransitionReport(self))
	}
}

pub struct SecondaryRatDataUsageReportProcedure {}

#[async_trait]
impl Indication for SecondaryRatDataUsageReportProcedure {
	type TopPdu = NgapPdu;
	type Request = SecondaryRatDataUsageReport;
	const CODE: u8 = 52;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: SecondaryRatDataUsageReport,
	) {
		<T as IndicationHandler<SecondaryRatDataUsageReportProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::SecondaryRatDataUsageReport(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::SecondaryRatDataUsageReport(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for SecondaryRatDataUsageReport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::SecondaryRatDataUsageReport(self))
	}
}

pub struct TraceFailureIndicationProcedure {}

#[async_trait]
impl Indication for TraceFailureIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = TraceFailureIndication;
	const CODE: u8 = 38;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: TraceFailureIndication,
	) {
		<T as IndicationHandler<TraceFailureIndicationProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::TraceFailureIndication(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::TraceFailureIndication(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for TraceFailureIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::TraceFailureIndication(self))
	}
}

pub struct TraceStartProcedure {}

#[async_trait]
impl Indication for TraceStartProcedure {
	type TopPdu = NgapPdu;
	type Request = TraceStart;
	const CODE: u8 = 39;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: TraceStart,
	) {
		<T as IndicationHandler<TraceStartProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::TraceStart(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::TraceStart(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for TraceStart {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::TraceStart(self))
	}
}

pub struct UeContextModificationProcedure {}

#[async_trait]
impl Procedure for UeContextModificationProcedure {
	type TopPdu = NgapPdu;
	type Request = UeContextModificationRequest;
	type Success = UeContextModificationResponse;
	type Failure = UeContextModificationFailure;
	const CODE: u8 = 40;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeContextModificationRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeContextModificationProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationResponse(x)) => {
				Ok(x)
			}
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextModificationFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeContextModificationRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextModificationRequest(self))
	}
}

impl ToNgapPdu for UeContextModificationResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextModificationResponse(self))
	}
}

impl ToNgapPdu for UeContextModificationFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextModificationFailure(self))
	}
}

pub struct UeContextReleaseProcedure {}

#[async_trait]
impl Procedure for UeContextReleaseProcedure {
	type TopPdu = NgapPdu;
	type Request = UeContextReleaseCommand;
	type Success = UeContextReleaseComplete;
	type Failure = ();
	const CODE: u8 = 41;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeContextReleaseCommand,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeContextReleaseProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextReleaseComplete(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseCommand(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextReleaseComplete(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseCommand(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeContextReleaseCommand {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseCommand(self))
	}
}

impl ToNgapPdu for UeContextReleaseComplete {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextReleaseComplete(self))
	}
}

pub struct UeContextReleaseRequestProcedure {}

#[async_trait]
impl Indication for UeContextReleaseRequestProcedure {
	type TopPdu = NgapPdu;
	type Request = UeContextReleaseRequest;
	const CODE: u8 = 42;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UeContextReleaseRequest,
	) {
		<T as IndicationHandler<UeContextReleaseRequestProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseRequest(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeContextReleaseRequest {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextReleaseRequest(self))
	}
}

pub struct UeContextResumeProcedure {}

#[async_trait]
impl Procedure for UeContextResumeProcedure {
	type TopPdu = NgapPdu;
	type Request = UeContextResumeRequest;
	type Success = UeContextResumeResponse;
	type Failure = UeContextResumeFailure;
	const CODE: u8 = 58;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeContextResumeRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeContextResumeProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextResumeResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextResumeRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextResumeResponse(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextResumeFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeContextResumeRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeContextResumeRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextResumeRequest(self))
	}
}

impl ToNgapPdu for UeContextResumeResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextResumeResponse(self))
	}
}

impl ToNgapPdu for UeContextResumeFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextResumeFailure(self))
	}
}

pub struct UeContextSuspendProcedure {}

#[async_trait]
impl Procedure for UeContextSuspendProcedure {
	type TopPdu = NgapPdu;
	type Request = UeContextSuspendRequest;
	type Success = UeContextSuspendResponse;
	type Failure = UeContextSuspendFailure;
	const CODE: u8 = 59;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeContextSuspendRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeContextSuspendProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextSuspendResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextSuspendRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextSuspendResponse(x)) => Ok(x),
			NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextSuspendFailure(x)) => {
				Err(RequestError::UnsuccessfulOutcome(x))
			}
			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeContextSuspendRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeContextSuspendRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeContextSuspendRequest(self))
	}
}

impl ToNgapPdu for UeContextSuspendResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeContextSuspendResponse(self))
	}
}

impl ToNgapPdu for UeContextSuspendFailure {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::UnsuccessfulOutcome(UnsuccessfulOutcome::UeContextSuspendFailure(self))
	}
}

pub struct UeInformationTransferProcedure {}

#[async_trait]
impl Indication for UeInformationTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = UeInformationTransfer;
	const CODE: u8 = 56;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UeInformationTransfer,
	) {
		<T as IndicationHandler<UeInformationTransferProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeInformationTransfer(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeInformationTransfer(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeInformationTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeInformationTransfer(self))
	}
}

pub struct UeRadioCapabilityCheckProcedure {}

#[async_trait]
impl Procedure for UeRadioCapabilityCheckProcedure {
	type TopPdu = NgapPdu;
	type Request = UeRadioCapabilityCheckRequest;
	type Success = UeRadioCapabilityCheckResponse;
	type Failure = ();
	const CODE: u8 = 43;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeRadioCapabilityCheckRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeRadioCapabilityCheckProcedure>>::request(provider, req).await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityCheckResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityCheckRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityCheckResponse(x)) => {
				Ok(x)
			}

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityCheckRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeRadioCapabilityCheckRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityCheckRequest(self))
	}
}

impl ToNgapPdu for UeRadioCapabilityCheckResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityCheckResponse(self))
	}
}

pub struct UeRadioCapabilityIdMappingProcedure {}

#[async_trait]
impl Procedure for UeRadioCapabilityIdMappingProcedure {
	type TopPdu = NgapPdu;
	type Request = UeRadioCapabilityIdMappingRequest;
	type Success = UeRadioCapabilityIdMappingResponse;
	type Failure = ();
	const CODE: u8 = 60;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: UeRadioCapabilityIdMappingRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<UeRadioCapabilityIdMappingProcedure>>::request(provider, req)
			.await
		{
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityIdMappingResponse(
					r,
				)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityIdMappingRequest(r))
			.into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityIdMappingResponse(
				x,
			)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityIdMappingRequest(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeRadioCapabilityIdMappingRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityIdMappingRequest(self))
	}
}

impl ToNgapPdu for UeRadioCapabilityIdMappingResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::UeRadioCapabilityIdMappingResponse(self))
	}
}

pub struct UeRadioCapabilityInfoIndicationProcedure {}

#[async_trait]
impl Indication for UeRadioCapabilityInfoIndicationProcedure {
	type TopPdu = NgapPdu;
	type Request = UeRadioCapabilityInfoIndication;
	const CODE: u8 = 44;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UeRadioCapabilityInfoIndication,
	) {
		<T as IndicationHandler<UeRadioCapabilityInfoIndicationProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityInfoIndication(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityInfoIndication(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeRadioCapabilityInfoIndication {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeRadioCapabilityInfoIndication(self))
	}
}

pub struct UeTnlaBindingReleaseProcedure {}

#[async_trait]
impl Indication for UeTnlaBindingReleaseProcedure {
	type TopPdu = NgapPdu;
	type Request = UeTnlaBindingReleaseRequest;
	const CODE: u8 = 45;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UeTnlaBindingReleaseRequest,
	) {
		<T as IndicationHandler<UeTnlaBindingReleaseProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeTnlaBindingReleaseRequest(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UeTnlaBindingReleaseRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UeTnlaBindingReleaseRequest {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UeTnlaBindingReleaseRequest(self))
	}
}

pub struct UplinkNasTransportProcedure {}

#[async_trait]
impl Indication for UplinkNasTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkNasTransport;
	const CODE: u8 = 46;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkNasTransport,
	) {
		<T as IndicationHandler<UplinkNasTransportProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNasTransport(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNasTransport(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkNasTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNasTransport(self))
	}
}

pub struct UplinkNonUeAssociatedNrPPaTransportProcedure {}

#[async_trait]
impl Indication for UplinkNonUeAssociatedNrPPaTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkNonUeAssociatedNrPPaTransport;
	const CODE: u8 = 47;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkNonUeAssociatedNrPPaTransport,
	) {
		<T as IndicationHandler<UplinkNonUeAssociatedNrPPaTransportProcedure>>::handle(
			provider, req,
		)
		.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNonUeAssociatedNrPPaTransport(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNonUeAssociatedNrPPaTransport(
				x,
			)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkNonUeAssociatedNrPPaTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkNonUeAssociatedNrPPaTransport(self))
	}
}

pub struct UplinkRanConfigurationTransferProcedure {}

#[async_trait]
impl Indication for UplinkRanConfigurationTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkRanConfigurationTransfer;
	const CODE: u8 = 48;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkRanConfigurationTransfer,
	) {
		<T as IndicationHandler<UplinkRanConfigurationTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanConfigurationTransfer(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanConfigurationTransfer(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkRanConfigurationTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanConfigurationTransfer(self))
	}
}

pub struct UplinkRanEarlyStatusTransferProcedure {}

#[async_trait]
impl Indication for UplinkRanEarlyStatusTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkRanEarlyStatusTransfer;
	const CODE: u8 = 62;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkRanEarlyStatusTransfer,
	) {
		<T as IndicationHandler<UplinkRanEarlyStatusTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanEarlyStatusTransfer(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanEarlyStatusTransfer(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkRanEarlyStatusTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanEarlyStatusTransfer(self))
	}
}

pub struct UplinkRanStatusTransferProcedure {}

#[async_trait]
impl Indication for UplinkRanStatusTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkRanStatusTransfer;
	const CODE: u8 = 49;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkRanStatusTransfer,
	) {
		<T as IndicationHandler<UplinkRanStatusTransferProcedure>>::handle(provider, req).await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanStatusTransfer(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanStatusTransfer(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkRanStatusTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRanStatusTransfer(self))
	}
}

pub struct UplinkUeAssociatedNrPPaTransportProcedure {}

#[async_trait]
impl Indication for UplinkUeAssociatedNrPPaTransportProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkUeAssociatedNrPPaTransport;
	const CODE: u8 = 50;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkUeAssociatedNrPPaTransport,
	) {
		<T as IndicationHandler<UplinkUeAssociatedNrPPaTransportProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkUeAssociatedNrPPaTransport(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkUeAssociatedNrPPaTransport(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkUeAssociatedNrPPaTransport {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkUeAssociatedNrPPaTransport(self))
	}
}

pub struct WriteReplaceWarningProcedure {}

#[async_trait]
impl Procedure for WriteReplaceWarningProcedure {
	type TopPdu = NgapPdu;
	type Request = WriteReplaceWarningRequest;
	type Success = WriteReplaceWarningResponse;
	type Failure = ();
	const CODE: u8 = 51;

	async fn call_provider<T: RequestProvider<Self>>(
		provider: &T,
		req: WriteReplaceWarningRequest,
	) -> Option<ResponseAction<NgapPdu>> {
		match <T as RequestProvider<WriteReplaceWarningProcedure>>::request(provider, req).await {
			Ok((r, f)) => Some((
				NgapPdu::SuccessfulOutcome(SuccessfulOutcome::WriteReplaceWarningResponse(r)),
				f,
			)),
			Err(_) => todo!(),
		}
	}

	#[cfg(feature = "gnb")]
	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::WriteReplaceWarningRequest(r)).into_bytes()
	}

	#[cfg(feature = "gnb")]
	fn decode_response(bytes: &[u8]) -> Result<Self::Success, RequestError<Self::Failure>> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::SuccessfulOutcome(SuccessfulOutcome::WriteReplaceWarningResponse(x)) => Ok(x),

			_ => Err(RequestError::Other("Unexpected pdu contents".to_string())),
		}
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::WriteReplaceWarningRequest(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for WriteReplaceWarningRequest {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::WriteReplaceWarningRequest(self))
	}
}

impl ToNgapPdu for WriteReplaceWarningResponse {
	#[inline(always)]
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::SuccessfulOutcome(SuccessfulOutcome::WriteReplaceWarningResponse(self))
	}
}

pub struct UplinkRimInformationTransferProcedure {}

#[async_trait]
impl Indication for UplinkRimInformationTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = UplinkRimInformationTransfer;
	const CODE: u8 = 53;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: UplinkRimInformationTransfer,
	) {
		<T as IndicationHandler<UplinkRimInformationTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRimInformationTransfer(r)).into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRimInformationTransfer(x)) => Ok(x),
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for UplinkRimInformationTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::UplinkRimInformationTransfer(self))
	}
}

pub struct DownlinkRimInformationTransferProcedure {}

#[async_trait]
impl Indication for DownlinkRimInformationTransferProcedure {
	type TopPdu = NgapPdu;
	type Request = DownlinkRimInformationTransfer;
	const CODE: u8 = 54;

	async fn call_provider<T: IndicationHandler<Self>>(
		provider: &T,
		req: DownlinkRimInformationTransfer,
	) {
		<T as IndicationHandler<DownlinkRimInformationTransferProcedure>>::handle(provider, req)
			.await;
	}

	fn encode_request(r: Self::Request) -> Result<Vec<u8>, ThreeGppAsn1PerError> {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRimInformationTransfer(r))
			.into_bytes()
	}

	#[cfg(feature = "amf")]
	fn decode_request(bytes: &[u8]) -> Result<Self::Request, ThreeGppAsn1PerError> {
		let response_pdu = Self::TopPdu::from_bytes(bytes)?;
		match response_pdu {
			NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRimInformationTransfer(x)) => {
				Ok(x)
			}
			_ => Err(ThreeGppAsn1PerError::new("Unexpected pdu contents")),
		}
	}
}

impl ToNgapPdu for DownlinkRimInformationTransfer {
	fn to_pdu(self) -> NgapPdu {
		NgapPdu::InitiatingMessage(InitiatingMessage::DownlinkRimInformationTransfer(self))
	}
}

#[derive(Clone, Debug)]
pub enum InitiatingMessage {
	AmfConfigurationUpdate(AmfConfigurationUpdate),
	AmfcpRelocationIndication(AmfcpRelocationIndication),
	AmfStatusIndication(AmfStatusIndication),
	BroadcastSessionModificationRequest(BroadcastSessionModificationRequest),
	BroadcastSessionReleaseRequest(BroadcastSessionReleaseRequest),
	BroadcastSessionReleaseRequired(BroadcastSessionReleaseRequired),
	BroadcastSessionSetupRequest(BroadcastSessionSetupRequest),
	CellTrafficTrace(CellTrafficTrace),
	ConnectionEstablishmentIndication(ConnectionEstablishmentIndication),
	DeactivateTrace(DeactivateTrace),
	DistributionSetupRequest(DistributionSetupRequest),
	DistributionReleaseRequest(DistributionReleaseRequest),
	DownlinkNasTransport(DownlinkNasTransport),
	DownlinkNonUeAssociatedNrPPaTransport(DownlinkNonUeAssociatedNrPPaTransport),
	DownlinkRanConfigurationTransfer(DownlinkRanConfigurationTransfer),
	DownlinkRanEarlyStatusTransfer(DownlinkRanEarlyStatusTransfer),
	DownlinkRanStatusTransfer(DownlinkRanStatusTransfer),
	DownlinkUeAssociatedNrPPaTransport(DownlinkUeAssociatedNrPPaTransport),
	ErrorIndication(ErrorIndication),
	HandoverCancel(HandoverCancel),
	HandoverNotify(HandoverNotify),
	HandoverRequired(HandoverRequired),
	HandoverRequest(HandoverRequest),
	HandoverSuccess(HandoverSuccess),
	InitialContextSetupRequest(InitialContextSetupRequest),
	InitialUeMessage(InitialUeMessage),
	LocationReport(LocationReport),
	LocationReportingControl(LocationReportingControl),
	LocationReportingFailureIndication(LocationReportingFailureIndication),
	MulticastSessionActivationRequest(MulticastSessionActivationRequest),
	MulticastSessionDeactivationRequest(MulticastSessionDeactivationRequest),
	MulticastSessionUpdateRequest(MulticastSessionUpdateRequest),
	MulticastGroupPaging(MulticastGroupPaging),
	NasNonDeliveryIndication(NasNonDeliveryIndication),
	NgReset(NgReset),
	NgSetupRequest(NgSetupRequest),
	OverloadStart(OverloadStart),
	OverloadStop(OverloadStop),
	Paging(Paging),
	PathSwitchRequest(PathSwitchRequest),
	PduSessionResourceModifyRequest(PduSessionResourceModifyRequest),
	PduSessionResourceModifyIndication(PduSessionResourceModifyIndication),
	PduSessionResourceNotify(PduSessionResourceNotify),
	PduSessionResourceReleaseCommand(PduSessionResourceReleaseCommand),
	PduSessionResourceSetupRequest(PduSessionResourceSetupRequest),
	PwsCancelRequest(PwsCancelRequest),
	PwsFailureIndication(PwsFailureIndication),
	PwsRestartIndication(PwsRestartIndication),
	RanConfigurationUpdate(RanConfigurationUpdate),
	RancpRelocationIndication(RancpRelocationIndication),
	RerouteNasRequest(RerouteNasRequest),
	RetrieveUeInformation(RetrieveUeInformation),
	RrcInactiveTransitionReport(RrcInactiveTransitionReport),
	SecondaryRatDataUsageReport(SecondaryRatDataUsageReport),
	TraceFailureIndication(TraceFailureIndication),
	TraceStart(TraceStart),
	UeContextModificationRequest(UeContextModificationRequest),
	UeContextReleaseCommand(UeContextReleaseCommand),
	UeContextReleaseRequest(UeContextReleaseRequest),
	UeContextResumeRequest(UeContextResumeRequest),
	UeContextSuspendRequest(UeContextSuspendRequest),
	UeInformationTransfer(UeInformationTransfer),
	UeRadioCapabilityCheckRequest(UeRadioCapabilityCheckRequest),
	UeRadioCapabilityIdMappingRequest(UeRadioCapabilityIdMappingRequest),
	UeRadioCapabilityInfoIndication(UeRadioCapabilityInfoIndication),
	UeTnlaBindingReleaseRequest(UeTnlaBindingReleaseRequest),
	UplinkNasTransport(UplinkNasTransport),
	UplinkNonUeAssociatedNrPPaTransport(UplinkNonUeAssociatedNrPPaTransport),
	UplinkRanConfigurationTransfer(UplinkRanConfigurationTransfer),
	UplinkRanEarlyStatusTransfer(UplinkRanEarlyStatusTransfer),
	UplinkRanStatusTransfer(UplinkRanStatusTransfer),
	UplinkUeAssociatedNrPPaTransport(UplinkUeAssociatedNrPPaTransport),
	WriteReplaceWarningRequest(WriteReplaceWarningRequest),
	UplinkRimInformationTransfer(UplinkRimInformationTransfer),
	DownlinkRimInformationTransfer(DownlinkRimInformationTransfer),
}

impl InitiatingMessage {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		let (id, _ext) = decode::decode_integer(data, Some(0), Some(255), false)?;
		let _ = Criticality::decode(data)?;
		let _ = decode::decode_length_determinent(data, None, None, false)?;
		match id {
			0 => Ok(Self::AmfConfigurationUpdate(
				AmfConfigurationUpdate::decode(data)?,
			)),
			64 => Ok(Self::AmfcpRelocationIndication(
				AmfcpRelocationIndication::decode(data)?,
			)),
			1 => Ok(Self::AmfStatusIndication(AmfStatusIndication::decode(
				data,
			)?)),
			66 => Ok(Self::BroadcastSessionModificationRequest(
				BroadcastSessionModificationRequest::decode(data)?,
			)),
			67 => Ok(Self::BroadcastSessionReleaseRequest(
				BroadcastSessionReleaseRequest::decode(data)?,
			)),
			75 => Ok(Self::BroadcastSessionReleaseRequired(
				BroadcastSessionReleaseRequired::decode(data)?,
			)),
			68 => Ok(Self::BroadcastSessionSetupRequest(
				BroadcastSessionSetupRequest::decode(data)?,
			)),
			2 => Ok(Self::CellTrafficTrace(CellTrafficTrace::decode(data)?)),
			65 => Ok(Self::ConnectionEstablishmentIndication(
				ConnectionEstablishmentIndication::decode(data)?,
			)),
			3 => Ok(Self::DeactivateTrace(DeactivateTrace::decode(data)?)),
			69 => Ok(Self::DistributionSetupRequest(
				DistributionSetupRequest::decode(data)?,
			)),
			70 => Ok(Self::DistributionReleaseRequest(
				DistributionReleaseRequest::decode(data)?,
			)),
			4 => Ok(Self::DownlinkNasTransport(DownlinkNasTransport::decode(
				data,
			)?)),
			5 => Ok(Self::DownlinkNonUeAssociatedNrPPaTransport(
				DownlinkNonUeAssociatedNrPPaTransport::decode(data)?,
			)),
			6 => Ok(Self::DownlinkRanConfigurationTransfer(
				DownlinkRanConfigurationTransfer::decode(data)?,
			)),
			63 => Ok(Self::DownlinkRanEarlyStatusTransfer(
				DownlinkRanEarlyStatusTransfer::decode(data)?,
			)),
			7 => Ok(Self::DownlinkRanStatusTransfer(
				DownlinkRanStatusTransfer::decode(data)?,
			)),
			8 => Ok(Self::DownlinkUeAssociatedNrPPaTransport(
				DownlinkUeAssociatedNrPPaTransport::decode(data)?,
			)),
			9 => Ok(Self::ErrorIndication(ErrorIndication::decode(data)?)),
			10 => Ok(Self::HandoverCancel(HandoverCancel::decode(data)?)),
			11 => Ok(Self::HandoverNotify(HandoverNotify::decode(data)?)),
			12 => Ok(Self::HandoverRequired(HandoverRequired::decode(data)?)),
			13 => Ok(Self::HandoverRequest(HandoverRequest::decode(data)?)),
			61 => Ok(Self::HandoverSuccess(HandoverSuccess::decode(data)?)),
			14 => Ok(Self::InitialContextSetupRequest(
				InitialContextSetupRequest::decode(data)?,
			)),
			15 => Ok(Self::InitialUeMessage(InitialUeMessage::decode(data)?)),
			18 => Ok(Self::LocationReport(LocationReport::decode(data)?)),
			16 => Ok(Self::LocationReportingControl(
				LocationReportingControl::decode(data)?,
			)),
			17 => Ok(Self::LocationReportingFailureIndication(
				LocationReportingFailureIndication::decode(data)?,
			)),
			71 => Ok(Self::MulticastSessionActivationRequest(
				MulticastSessionActivationRequest::decode(data)?,
			)),
			72 => Ok(Self::MulticastSessionDeactivationRequest(
				MulticastSessionDeactivationRequest::decode(data)?,
			)),
			73 => Ok(Self::MulticastSessionUpdateRequest(
				MulticastSessionUpdateRequest::decode(data)?,
			)),
			74 => Ok(Self::MulticastGroupPaging(MulticastGroupPaging::decode(
				data,
			)?)),
			19 => Ok(Self::NasNonDeliveryIndication(
				NasNonDeliveryIndication::decode(data)?,
			)),
			20 => Ok(Self::NgReset(NgReset::decode(data)?)),
			21 => Ok(Self::NgSetupRequest(NgSetupRequest::decode(data)?)),
			22 => Ok(Self::OverloadStart(OverloadStart::decode(data)?)),
			23 => Ok(Self::OverloadStop(OverloadStop::decode(data)?)),
			24 => Ok(Self::Paging(Paging::decode(data)?)),
			25 => Ok(Self::PathSwitchRequest(PathSwitchRequest::decode(data)?)),
			26 => Ok(Self::PduSessionResourceModifyRequest(
				PduSessionResourceModifyRequest::decode(data)?,
			)),
			27 => Ok(Self::PduSessionResourceModifyIndication(
				PduSessionResourceModifyIndication::decode(data)?,
			)),
			30 => Ok(Self::PduSessionResourceNotify(
				PduSessionResourceNotify::decode(data)?,
			)),
			28 => Ok(Self::PduSessionResourceReleaseCommand(
				PduSessionResourceReleaseCommand::decode(data)?,
			)),
			29 => Ok(Self::PduSessionResourceSetupRequest(
				PduSessionResourceSetupRequest::decode(data)?,
			)),
			32 => Ok(Self::PwsCancelRequest(PwsCancelRequest::decode(data)?)),
			33 => Ok(Self::PwsFailureIndication(PwsFailureIndication::decode(
				data,
			)?)),
			34 => Ok(Self::PwsRestartIndication(PwsRestartIndication::decode(
				data,
			)?)),
			35 => Ok(Self::RanConfigurationUpdate(
				RanConfigurationUpdate::decode(data)?,
			)),
			57 => Ok(Self::RancpRelocationIndication(
				RancpRelocationIndication::decode(data)?,
			)),
			36 => Ok(Self::RerouteNasRequest(RerouteNasRequest::decode(data)?)),
			55 => Ok(Self::RetrieveUeInformation(RetrieveUeInformation::decode(
				data,
			)?)),
			37 => Ok(Self::RrcInactiveTransitionReport(
				RrcInactiveTransitionReport::decode(data)?,
			)),
			52 => Ok(Self::SecondaryRatDataUsageReport(
				SecondaryRatDataUsageReport::decode(data)?,
			)),
			38 => Ok(Self::TraceFailureIndication(
				TraceFailureIndication::decode(data)?,
			)),
			39 => Ok(Self::TraceStart(TraceStart::decode(data)?)),
			40 => Ok(Self::UeContextModificationRequest(
				UeContextModificationRequest::decode(data)?,
			)),
			41 => Ok(Self::UeContextReleaseCommand(
				UeContextReleaseCommand::decode(data)?,
			)),
			42 => Ok(Self::UeContextReleaseRequest(
				UeContextReleaseRequest::decode(data)?,
			)),
			58 => Ok(Self::UeContextResumeRequest(
				UeContextResumeRequest::decode(data)?,
			)),
			59 => Ok(Self::UeContextSuspendRequest(
				UeContextSuspendRequest::decode(data)?,
			)),
			56 => Ok(Self::UeInformationTransfer(UeInformationTransfer::decode(
				data,
			)?)),
			43 => Ok(Self::UeRadioCapabilityCheckRequest(
				UeRadioCapabilityCheckRequest::decode(data)?,
			)),
			60 => Ok(Self::UeRadioCapabilityIdMappingRequest(
				UeRadioCapabilityIdMappingRequest::decode(data)?,
			)),
			44 => Ok(Self::UeRadioCapabilityInfoIndication(
				UeRadioCapabilityInfoIndication::decode(data)?,
			)),
			45 => Ok(Self::UeTnlaBindingReleaseRequest(
				UeTnlaBindingReleaseRequest::decode(data)?,
			)),
			46 => Ok(Self::UplinkNasTransport(UplinkNasTransport::decode(data)?)),
			47 => Ok(Self::UplinkNonUeAssociatedNrPPaTransport(
				UplinkNonUeAssociatedNrPPaTransport::decode(data)?,
			)),
			48 => Ok(Self::UplinkRanConfigurationTransfer(
				UplinkRanConfigurationTransfer::decode(data)?,
			)),
			62 => Ok(Self::UplinkRanEarlyStatusTransfer(
				UplinkRanEarlyStatusTransfer::decode(data)?,
			)),
			49 => Ok(Self::UplinkRanStatusTransfer(
				UplinkRanStatusTransfer::decode(data)?,
			)),
			50 => Ok(Self::UplinkUeAssociatedNrPPaTransport(
				UplinkUeAssociatedNrPPaTransport::decode(data)?,
			)),
			51 => Ok(Self::WriteReplaceWarningRequest(
				WriteReplaceWarningRequest::decode(data)?,
			)),
			53 => Ok(Self::UplinkRimInformationTransfer(
				UplinkRimInformationTransfer::decode(data)?,
			)),
			54 => Ok(Self::DownlinkRimInformationTransfer(
				DownlinkRimInformationTransfer::decode(data)?,
			)),
			x => {
				return Err(ThreeGppAsn1PerError::new(format!(
					"Unrecognised procedure code {}",
					x
				)));
			}
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		match self {
			Self::AmfConfigurationUpdate(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::AmfcpRelocationIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 64, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::AmfStatusIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 1, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionModificationRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 66, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionReleaseRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 67, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionReleaseRequired(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 75, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionSetupRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 68, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::CellTrafficTrace(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 2, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::ConnectionEstablishmentIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 65, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DeactivateTrace(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 3, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DistributionSetupRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 69, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DistributionReleaseRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 70, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkNasTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 4, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkNonUeAssociatedNrPPaTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 5, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkRanConfigurationTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 6, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkRanEarlyStatusTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 63, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkRanStatusTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 7, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkUeAssociatedNrPPaTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 8, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::ErrorIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 9, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverCancel(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 10, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverNotify(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 11, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverRequired(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverSuccess(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 61, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::InitialContextSetupRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::InitialUeMessage(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 15, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::LocationReport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 18, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::LocationReportingControl(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 16, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::LocationReportingFailureIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 17, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionActivationRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 71, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionDeactivationRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 72, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionUpdateRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 73, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastGroupPaging(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 74, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NasNonDeliveryIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 19, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NgReset(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NgSetupRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::OverloadStart(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 22, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::OverloadStop(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 23, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::Paging(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 24, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PathSwitchRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceModifyRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceModifyIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 27, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceNotify(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 30, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceReleaseCommand(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 28, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceSetupRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 29, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PwsCancelRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PwsFailureIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 33, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PwsRestartIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 34, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RanConfigurationUpdate(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RancpRelocationIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 57, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RerouteNasRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 36, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RetrieveUeInformation(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 55, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RrcInactiveTransitionReport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 37, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::SecondaryRatDataUsageReport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 52, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::TraceFailureIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 38, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::TraceStart(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 39, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextModificationRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextReleaseCommand(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextReleaseRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 42, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextResumeRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextSuspendRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeInformationTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 56, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeRadioCapabilityCheckRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 43, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeRadioCapabilityIdMappingRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 60, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeRadioCapabilityInfoIndication(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 44, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeTnlaBindingReleaseRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 45, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkNasTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 46, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkNonUeAssociatedNrPPaTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 47, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkRanConfigurationTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 48, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkRanEarlyStatusTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 62, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkRanStatusTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 49, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkUeAssociatedNrPPaTransport(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 50, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::WriteReplaceWarningRequest(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 51, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UplinkRimInformationTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 53, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DownlinkRimInformationTransfer(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 54, false)?;
				Criticality::Ignore.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
		}
		Ok(())
	}
}

impl PerCodec for InitiatingMessage {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		InitiatingMessage::decode_inner(data).map_err(|mut e: ThreeGppAsn1PerError| {
			e.codec_error.push_context("InitiatingMessage");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		self.encode_inner(data)
			.map_err(|mut e: ThreeGppAsn1PerError| {
				e.codec_error.push_context("InitiatingMessage");
				e
			})
	}
}

#[derive(Clone, Debug)]
pub enum SuccessfulOutcome {
	AmfConfigurationUpdateAcknowledge(AmfConfigurationUpdateAcknowledge),
	BroadcastSessionModificationResponse(BroadcastSessionModificationResponse),
	BroadcastSessionReleaseResponse(BroadcastSessionReleaseResponse),
	BroadcastSessionSetupResponse(BroadcastSessionSetupResponse),
	DistributionSetupResponse(DistributionSetupResponse),
	DistributionReleaseResponse(DistributionReleaseResponse),
	HandoverCancelAcknowledge(HandoverCancelAcknowledge),
	HandoverCommand(HandoverCommand),
	HandoverRequestAcknowledge(HandoverRequestAcknowledge),
	InitialContextSetupResponse(InitialContextSetupResponse),
	MulticastSessionActivationResponse(MulticastSessionActivationResponse),
	MulticastSessionDeactivationResponse(MulticastSessionDeactivationResponse),
	MulticastSessionUpdateResponse(MulticastSessionUpdateResponse),
	NgResetAcknowledge(NgResetAcknowledge),
	NgSetupResponse(NgSetupResponse),
	PathSwitchRequestAcknowledge(PathSwitchRequestAcknowledge),
	PduSessionResourceModifyResponse(PduSessionResourceModifyResponse),
	PduSessionResourceModifyConfirm(PduSessionResourceModifyConfirm),
	PduSessionResourceReleaseResponse(PduSessionResourceReleaseResponse),
	PduSessionResourceSetupResponse(PduSessionResourceSetupResponse),
	PwsCancelResponse(PwsCancelResponse),
	RanConfigurationUpdateAcknowledge(RanConfigurationUpdateAcknowledge),
	UeContextModificationResponse(UeContextModificationResponse),
	UeContextReleaseComplete(UeContextReleaseComplete),
	UeContextResumeResponse(UeContextResumeResponse),
	UeContextSuspendResponse(UeContextSuspendResponse),
	UeRadioCapabilityCheckResponse(UeRadioCapabilityCheckResponse),
	UeRadioCapabilityIdMappingResponse(UeRadioCapabilityIdMappingResponse),
	WriteReplaceWarningResponse(WriteReplaceWarningResponse),
}

impl SuccessfulOutcome {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		let (id, _ext) = decode::decode_integer(data, Some(0), Some(255), false)?;
		let _ = Criticality::decode(data)?;
		let _ = decode::decode_length_determinent(data, None, None, false)?;
		match id {
			0 => Ok(Self::AmfConfigurationUpdateAcknowledge(
				AmfConfigurationUpdateAcknowledge::decode(data)?,
			)),
			66 => Ok(Self::BroadcastSessionModificationResponse(
				BroadcastSessionModificationResponse::decode(data)?,
			)),
			67 => Ok(Self::BroadcastSessionReleaseResponse(
				BroadcastSessionReleaseResponse::decode(data)?,
			)),
			68 => Ok(Self::BroadcastSessionSetupResponse(
				BroadcastSessionSetupResponse::decode(data)?,
			)),
			69 => Ok(Self::DistributionSetupResponse(
				DistributionSetupResponse::decode(data)?,
			)),
			70 => Ok(Self::DistributionReleaseResponse(
				DistributionReleaseResponse::decode(data)?,
			)),
			10 => Ok(Self::HandoverCancelAcknowledge(
				HandoverCancelAcknowledge::decode(data)?,
			)),
			12 => Ok(Self::HandoverCommand(HandoverCommand::decode(data)?)),
			13 => Ok(Self::HandoverRequestAcknowledge(
				HandoverRequestAcknowledge::decode(data)?,
			)),
			14 => Ok(Self::InitialContextSetupResponse(
				InitialContextSetupResponse::decode(data)?,
			)),
			71 => Ok(Self::MulticastSessionActivationResponse(
				MulticastSessionActivationResponse::decode(data)?,
			)),
			72 => Ok(Self::MulticastSessionDeactivationResponse(
				MulticastSessionDeactivationResponse::decode(data)?,
			)),
			73 => Ok(Self::MulticastSessionUpdateResponse(
				MulticastSessionUpdateResponse::decode(data)?,
			)),
			20 => Ok(Self::NgResetAcknowledge(NgResetAcknowledge::decode(data)?)),
			21 => Ok(Self::NgSetupResponse(NgSetupResponse::decode(data)?)),
			25 => Ok(Self::PathSwitchRequestAcknowledge(
				PathSwitchRequestAcknowledge::decode(data)?,
			)),
			26 => Ok(Self::PduSessionResourceModifyResponse(
				PduSessionResourceModifyResponse::decode(data)?,
			)),
			27 => Ok(Self::PduSessionResourceModifyConfirm(
				PduSessionResourceModifyConfirm::decode(data)?,
			)),
			28 => Ok(Self::PduSessionResourceReleaseResponse(
				PduSessionResourceReleaseResponse::decode(data)?,
			)),
			29 => Ok(Self::PduSessionResourceSetupResponse(
				PduSessionResourceSetupResponse::decode(data)?,
			)),
			32 => Ok(Self::PwsCancelResponse(PwsCancelResponse::decode(data)?)),
			35 => Ok(Self::RanConfigurationUpdateAcknowledge(
				RanConfigurationUpdateAcknowledge::decode(data)?,
			)),
			40 => Ok(Self::UeContextModificationResponse(
				UeContextModificationResponse::decode(data)?,
			)),
			41 => Ok(Self::UeContextReleaseComplete(
				UeContextReleaseComplete::decode(data)?,
			)),
			58 => Ok(Self::UeContextResumeResponse(
				UeContextResumeResponse::decode(data)?,
			)),
			59 => Ok(Self::UeContextSuspendResponse(
				UeContextSuspendResponse::decode(data)?,
			)),
			43 => Ok(Self::UeRadioCapabilityCheckResponse(
				UeRadioCapabilityCheckResponse::decode(data)?,
			)),
			60 => Ok(Self::UeRadioCapabilityIdMappingResponse(
				UeRadioCapabilityIdMappingResponse::decode(data)?,
			)),
			51 => Ok(Self::WriteReplaceWarningResponse(
				WriteReplaceWarningResponse::decode(data)?,
			)),
			x => {
				return Err(ThreeGppAsn1PerError::new(format!(
					"Unrecognised procedure code {}",
					x
				)));
			}
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		match self {
			Self::AmfConfigurationUpdateAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionModificationResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 66, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionReleaseResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 67, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionSetupResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 68, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DistributionSetupResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 69, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DistributionReleaseResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 70, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverCancelAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 10, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverCommand(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverRequestAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::InitialContextSetupResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionActivationResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 71, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionDeactivationResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 72, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionUpdateResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 73, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NgResetAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 20, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NgSetupResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PathSwitchRequestAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceModifyResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 26, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceModifyConfirm(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 27, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceReleaseResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 28, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PduSessionResourceSetupResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 29, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PwsCancelResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 32, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RanConfigurationUpdateAcknowledge(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextModificationResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextReleaseComplete(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 41, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextResumeResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextSuspendResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeRadioCapabilityCheckResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 43, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeRadioCapabilityIdMappingResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 60, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::WriteReplaceWarningResponse(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 51, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
		}
		Ok(())
	}
}

impl PerCodec for SuccessfulOutcome {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		SuccessfulOutcome::decode_inner(data).map_err(|mut e: ThreeGppAsn1PerError| {
			e.codec_error.push_context("SuccessfulOutcome");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		self.encode_inner(data)
			.map_err(|mut e: ThreeGppAsn1PerError| {
				e.codec_error.push_context("SuccessfulOutcome");
				e
			})
	}
}

#[derive(Clone, Debug)]
pub enum UnsuccessfulOutcome {
	AmfConfigurationUpdateFailure(AmfConfigurationUpdateFailure),
	BroadcastSessionModificationFailure(BroadcastSessionModificationFailure),
	BroadcastSessionSetupFailure(BroadcastSessionSetupFailure),
	DistributionSetupFailure(DistributionSetupFailure),
	HandoverPreparationFailure(HandoverPreparationFailure),
	HandoverFailure(HandoverFailure),
	InitialContextSetupFailure(InitialContextSetupFailure),
	MulticastSessionActivationFailure(MulticastSessionActivationFailure),
	MulticastSessionUpdateFailure(MulticastSessionUpdateFailure),
	NgSetupFailure(NgSetupFailure),
	PathSwitchRequestFailure(PathSwitchRequestFailure),
	RanConfigurationUpdateFailure(RanConfigurationUpdateFailure),
	UeContextModificationFailure(UeContextModificationFailure),
	UeContextResumeFailure(UeContextResumeFailure),
	UeContextSuspendFailure(UeContextSuspendFailure),
}

impl UnsuccessfulOutcome {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		let (id, _ext) = decode::decode_integer(data, Some(0), Some(255), false)?;
		let _ = Criticality::decode(data)?;
		let _ = decode::decode_length_determinent(data, None, None, false)?;
		match id {
			0 => Ok(Self::AmfConfigurationUpdateFailure(
				AmfConfigurationUpdateFailure::decode(data)?,
			)),
			66 => Ok(Self::BroadcastSessionModificationFailure(
				BroadcastSessionModificationFailure::decode(data)?,
			)),
			68 => Ok(Self::BroadcastSessionSetupFailure(
				BroadcastSessionSetupFailure::decode(data)?,
			)),
			69 => Ok(Self::DistributionSetupFailure(
				DistributionSetupFailure::decode(data)?,
			)),
			12 => Ok(Self::HandoverPreparationFailure(
				HandoverPreparationFailure::decode(data)?,
			)),
			13 => Ok(Self::HandoverFailure(HandoverFailure::decode(data)?)),
			14 => Ok(Self::InitialContextSetupFailure(
				InitialContextSetupFailure::decode(data)?,
			)),
			71 => Ok(Self::MulticastSessionActivationFailure(
				MulticastSessionActivationFailure::decode(data)?,
			)),
			73 => Ok(Self::MulticastSessionUpdateFailure(
				MulticastSessionUpdateFailure::decode(data)?,
			)),
			21 => Ok(Self::NgSetupFailure(NgSetupFailure::decode(data)?)),
			25 => Ok(Self::PathSwitchRequestFailure(
				PathSwitchRequestFailure::decode(data)?,
			)),
			35 => Ok(Self::RanConfigurationUpdateFailure(
				RanConfigurationUpdateFailure::decode(data)?,
			)),
			40 => Ok(Self::UeContextModificationFailure(
				UeContextModificationFailure::decode(data)?,
			)),
			58 => Ok(Self::UeContextResumeFailure(
				UeContextResumeFailure::decode(data)?,
			)),
			59 => Ok(Self::UeContextSuspendFailure(
				UeContextSuspendFailure::decode(data)?,
			)),
			x => {
				return Err(ThreeGppAsn1PerError::new(format!(
					"Unrecognised procedure code {}",
					x
				)));
			}
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		match self {
			Self::AmfConfigurationUpdateFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 0, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionModificationFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 66, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::BroadcastSessionSetupFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 68, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::DistributionSetupFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 69, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverPreparationFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 12, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::HandoverFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 13, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::InitialContextSetupFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 14, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionActivationFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 71, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::MulticastSessionUpdateFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 73, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::NgSetupFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 21, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::PathSwitchRequestFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 25, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::RanConfigurationUpdateFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 35, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextModificationFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 40, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextResumeFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 58, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
			Self::UeContextSuspendFailure(x) => {
				encode::encode_integer(data, Some(0), Some(255), false, 59, false)?;
				Criticality::Reject.encode(data)?;
				let container = &mut Allocator::new_codec_data();
				x.encode(container)?;
				encode::encode_length_determinent(
					data,
					None,
					None,
					false,
					container.length_in_bytes(),
				)?;
				data.append_aligned(container);
			}
		}
		Ok(())
	}
}

impl PerCodec for UnsuccessfulOutcome {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, ThreeGppAsn1PerError> {
		UnsuccessfulOutcome::decode_inner(data).map_err(|mut e: ThreeGppAsn1PerError| {
			e.codec_error.push_context("UnsuccessfulOutcome");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), ThreeGppAsn1PerError> {
		self.encode_inner(data)
			.map_err(|mut e: ThreeGppAsn1PerError| {
				e.codec_error.push_context("UnsuccessfulOutcome");
				e
			})
	}
}
