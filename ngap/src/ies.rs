// Autogenerated from NGAP-IEs.asn
#![allow(clippy::all)]
use asn1_per::{aper::*, *};
#[allow(unused_imports)]
use xxap::{GtpTeid, GtpTunnel, PduSessionId, TransportLayerAddress};

use super::common::*;

// AdditionalDlUpTnlInformationForHoList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AdditionalDlUpTnlInformationForHoList(
	pub NonEmpty<AdditionalDlUpTnlInformationForHoItem>,
);

impl AdditionalDlUpTnlInformationForHoList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AdditionalDlUpTnlInformationForHoItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AdditionalDlUpTnlInformationForHoList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AdditionalDlUpTnlInformationForHoList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalDlUpTnlInformationForHoList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalDlUpTnlInformationForHoList");
			e
		})
	}
}
// AdditionalDlUpTnlInformationForHoItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AdditionalDlUpTnlInformationForHoItem {
	pub additional_dl_ngu_up_tnl_information: UpTransportLayerInformation,
	pub additional_qos_flow_setup_response_list: QosFlowListWithDataForwarding,
	pub additional_dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl AdditionalDlUpTnlInformationForHoItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let additional_dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let additional_qos_flow_setup_response_list = QosFlowListWithDataForwarding::decode(data)?;
		let additional_dl_forwarding_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut additional_redundant_dl_ngu_up_tnl_information: Option<
			UpTransportLayerInformation,
		> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					183 => {
						additional_redundant_dl_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			additional_dl_ngu_up_tnl_information,
			additional_qos_flow_setup_response_list,
			additional_dl_forwarding_up_tnl_information,
			additional_redundant_dl_ngu_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_redundant_dl_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 183, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.additional_dl_forwarding_up_tnl_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.additional_dl_ngu_up_tnl_information.encode(data)?;
		self.additional_qos_flow_setup_response_list.encode(data)?;
		if let Some(x) = &self.additional_dl_forwarding_up_tnl_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for AdditionalDlUpTnlInformationForHoItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AdditionalDlUpTnlInformationForHoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalDlUpTnlInformationForHoItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalDlUpTnlInformationForHoItem");
			e
		})
	}
}
// AdditionalQosFlowInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum AdditionalQosFlowInformation {
	#[default]
	MoreLikely,
}

impl AdditionalQosFlowInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for AdditionalQosFlowInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AdditionalQosFlowInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalQosFlowInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AdditionalQosFlowInformation");
			e
		})
	}
}
// AllocationAndRetentionPriority
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllocationAndRetentionPriority {
	pub priority_level_arp: PriorityLevelArp,
	pub pre_emption_capability: PreEmptionCapability,
	pub pre_emption_vulnerability: PreEmptionVulnerability,
}

impl AllocationAndRetentionPriority {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let priority_level_arp = PriorityLevelArp::decode(data)?;
		let pre_emption_capability = PreEmptionCapability::decode(data)?;
		let pre_emption_vulnerability = PreEmptionVulnerability::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			priority_level_arp,
			pre_emption_capability,
			pre_emption_vulnerability,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.priority_level_arp.encode(data)?;
		self.pre_emption_capability.encode(data)?;
		self.pre_emption_vulnerability.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AllocationAndRetentionPriority {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllocationAndRetentionPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllocationAndRetentionPriority");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllocationAndRetentionPriority");
			e
		})
	}
}
// AllowedCagListPerPlmn
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedCagListPerPlmn(pub NonEmpty<CagId>);

impl AllowedCagListPerPlmn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CagId::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AllowedCagListPerPlmn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedCagListPerPlmn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedCagListPerPlmn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedCagListPerPlmn");
			e
		})
	}
}
// AllowedNssai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedNssai(pub NonEmpty<AllowedNssaiItem>);

impl AllowedNssai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AllowedNssaiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AllowedNssai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedNssai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedNssai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedNssai");
			e
		})
	}
}
// AllowedNssaiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedNssaiItem {
	pub snssai: Snssai,
}

impl AllowedNssaiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { snssai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AllowedNssaiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedNssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedNssaiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedNssaiItem");
			e
		})
	}
}
// AllowedPniNpnList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedPniNpnList(pub NonEmpty<AllowedPniNpnItem>);

impl AllowedPniNpnList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AllowedPniNpnItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AllowedPniNpnList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedPniNpnList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedPniNpnList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedPniNpnList");
			e
		})
	}
}
// AllowedPniNpnItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedPniNpnItem {
	pub plmn_identity: PlmnIdentity,
	pub pni_npn_restricted: PniNpnRestricted,
	pub allowed_cag_list_per_plmn: AllowedCagListPerPlmn,
}

impl AllowedPniNpnItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let pni_npn_restricted = PniNpnRestricted::decode(data)?;
		let allowed_cag_list_per_plmn = AllowedCagListPerPlmn::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			pni_npn_restricted,
			allowed_cag_list_per_plmn,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.pni_npn_restricted.encode(data)?;
		self.allowed_cag_list_per_plmn.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AllowedPniNpnItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedPniNpnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedPniNpnItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedPniNpnItem");
			e
		})
	}
}
// AllowedTaCs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AllowedTaCs(pub NonEmpty<Tac>);

impl AllowedTaCs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AllowedTaCs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AllowedTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedTaCs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AllowedTaCs");
			e
		})
	}
}
// AlternativeQosParaSetIndex
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AlternativeQosParaSetIndex(pub u8);

impl AlternativeQosParaSetIndex {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(8), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(8), true, self.0 as i128, false)
	}
}

impl PerCodec for AlternativeQosParaSetIndex {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AlternativeQosParaSetIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetIndex");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetIndex");
			e
		})
	}
}
// AlternativeQosParaSetNotifyIndex
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AlternativeQosParaSetNotifyIndex(pub u8);

impl AlternativeQosParaSetNotifyIndex {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(8), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(8), true, self.0 as i128, false)
	}
}

impl PerCodec for AlternativeQosParaSetNotifyIndex {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AlternativeQosParaSetNotifyIndex::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetNotifyIndex");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetNotifyIndex");
			e
		})
	}
}
// AlternativeQosParaSetList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AlternativeQosParaSetList(pub NonEmpty<AlternativeQosParaSetItem>);

impl AlternativeQosParaSetList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AlternativeQosParaSetItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AlternativeQosParaSetList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AlternativeQosParaSetList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetList");
			e
		})
	}
}
// AlternativeQosParaSetItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AlternativeQosParaSetItem {
	pub alternative_qos_para_set_index: AlternativeQosParaSetIndex,
	pub guaranteed_flow_bit_rate_dl: Option<BitRate>,
	pub guaranteed_flow_bit_rate_ul: Option<BitRate>,
	pub packet_delay_budget: Option<PacketDelayBudget>,
	pub packet_error_rate: Option<PacketErrorRate>,
}

impl AlternativeQosParaSetItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let alternative_qos_para_set_index = AlternativeQosParaSetIndex::decode(data)?;
		let guaranteed_flow_bit_rate_dl = if optionals[0] {
			Some(BitRate::decode(data)?)
		} else {
			None
		};
		let guaranteed_flow_bit_rate_ul = if optionals[1] {
			Some(BitRate::decode(data)?)
		} else {
			None
		};
		let packet_delay_budget = if optionals[2] {
			Some(PacketDelayBudget::decode(data)?)
		} else {
			None
		};
		let packet_error_rate = if optionals[3] {
			Some(PacketErrorRate::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			alternative_qos_para_set_index,
			guaranteed_flow_bit_rate_dl,
			guaranteed_flow_bit_rate_ul,
			packet_delay_budget,
			packet_error_rate,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.guaranteed_flow_bit_rate_dl.is_some());
		optionals.push(self.guaranteed_flow_bit_rate_ul.is_some());
		optionals.push(self.packet_delay_budget.is_some());
		optionals.push(self.packet_error_rate.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.alternative_qos_para_set_index.encode(data)?;
		if let Some(x) = &self.guaranteed_flow_bit_rate_dl {
			x.encode(data)?;
		}
		if let Some(x) = &self.guaranteed_flow_bit_rate_ul {
			x.encode(data)?;
		}
		if let Some(x) = &self.packet_delay_budget {
			x.encode(data)?;
		}
		if let Some(x) = &self.packet_error_rate {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for AlternativeQosParaSetItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AlternativeQosParaSetItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AlternativeQosParaSetItem");
			e
		})
	}
}
// AmfName
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfName(pub String);

impl AmfName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_printable_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for AmfName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfName");
			e
		})
	}
}
// AmfNameVisibleString
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfNameVisibleString(pub String);

impl AmfNameVisibleString {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_visible_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for AmfNameVisibleString {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfNameVisibleString");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfNameVisibleString");
			e
		})
	}
}
// AmfNameUtf8String
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfNameUtf8String(pub String);

impl AmfNameUtf8String {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_utf8_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for AmfNameUtf8String {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfNameUtf8String");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfNameUtf8String");
			e
		})
	}
}
// AmfPagingTarget
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum AmfPagingTarget {
	#[default]
	GlobalRanNodeId(GlobalRanNodeId),
	Tai(Tai),
}

impl AmfPagingTarget {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::GlobalRanNodeId(GlobalRanNodeId::decode(data)?)),
			1 => Ok(Self::Tai(Tai::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::GlobalRanNodeId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Tai(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for AmfPagingTarget {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfPagingTarget::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfPagingTarget");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfPagingTarget");
			e
		})
	}
}
// AmfPointer
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfPointer(pub BitString);

impl AmfPointer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(6),
			Some(6),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(6), Some(6), false, &self.0, false)
	}
}

impl PerCodec for AmfPointer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfPointer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfPointer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfPointer");
			e
		})
	}
}
// AmfRegionId
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfRegionId(pub BitString);

impl AmfRegionId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for AmfRegionId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfRegionId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfRegionId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfRegionId");
			e
		})
	}
}
// AmfSetId
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfSetId(pub BitString);

impl AmfSetId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(10),
			Some(10),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(10), Some(10), false, &self.0, false)
	}
}

impl PerCodec for AmfSetId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfSetId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfSetId");
			e
		})
	}
}
// AmfTnlAssociationSetupList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationSetupList(pub NonEmpty<AmfTnlAssociationSetupItem>);

impl AmfTnlAssociationSetupList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AmfTnlAssociationSetupItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationSetupList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationSetupList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationSetupList");
			e
		})
	}
}
// AmfTnlAssociationSetupItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationSetupItem {
	pub amf_tnl_association_address: CpTransportLayerInformation,
}

impl AmfTnlAssociationSetupItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_tnl_association_address,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_tnl_association_address.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationSetupItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationSetupItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationSetupItem");
			e
		})
	}
}
// AmfTnlAssociationToAddList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToAddList(pub NonEmpty<AmfTnlAssociationToAddItem>);

impl AmfTnlAssociationToAddList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AmfTnlAssociationToAddItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToAddList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToAddList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToAddList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToAddList");
			e
		})
	}
}
// AmfTnlAssociationToAddItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToAddItem {
	pub amf_tnl_association_address: CpTransportLayerInformation,
	pub tnl_association_usage: Option<TnlAssociationUsage>,
	pub tnl_address_weight_factor: TnlAddressWeightFactor,
}

impl AmfTnlAssociationToAddItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;
		let tnl_association_usage = if optionals[0] {
			Some(TnlAssociationUsage::decode(data)?)
		} else {
			None
		};
		let tnl_address_weight_factor = TnlAddressWeightFactor::decode(data)?;

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_tnl_association_address,
			tnl_association_usage,
			tnl_address_weight_factor,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.tnl_association_usage.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_tnl_association_address.encode(data)?;
		if let Some(x) = &self.tnl_association_usage {
			x.encode(data)?;
		}
		self.tnl_address_weight_factor.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToAddItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToAddItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToAddItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToAddItem");
			e
		})
	}
}
// AmfTnlAssociationToRemoveList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToRemoveList(pub NonEmpty<AmfTnlAssociationToRemoveItem>);

impl AmfTnlAssociationToRemoveList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AmfTnlAssociationToRemoveItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToRemoveList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToRemoveList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToRemoveList");
			e
		})
	}
}
// AmfTnlAssociationToRemoveItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToRemoveItem {
	pub amf_tnl_association_address: CpTransportLayerInformation,
	pub tnl_association_transport_layer_address_ngran: Option<CpTransportLayerInformation>,
}

impl AmfTnlAssociationToRemoveItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;

		// Process the extension container
		let mut tnl_association_transport_layer_address_ngran: Option<CpTransportLayerInformation> =
			None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					168 => {
						tnl_association_transport_layer_address_ngran =
							Some(CpTransportLayerInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_tnl_association_address,
			tnl_association_transport_layer_address_ngran,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tnl_association_transport_layer_address_ngran {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 168, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_tnl_association_address.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToRemoveItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToRemoveItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToRemoveItem");
			e
		})
	}
}
// AmfTnlAssociationToUpdateList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToUpdateList(pub NonEmpty<AmfTnlAssociationToUpdateItem>);

impl AmfTnlAssociationToUpdateList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AmfTnlAssociationToUpdateItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToUpdateList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToUpdateList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToUpdateList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToUpdateList");
			e
		})
	}
}
// AmfTnlAssociationToUpdateItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AmfTnlAssociationToUpdateItem {
	pub amf_tnl_association_address: CpTransportLayerInformation,
	pub tnl_association_usage: Option<TnlAssociationUsage>,
	pub tnl_address_weight_factor: Option<TnlAddressWeightFactor>,
}

impl AmfTnlAssociationToUpdateItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let amf_tnl_association_address = CpTransportLayerInformation::decode(data)?;
		let tnl_association_usage = if optionals[0] {
			Some(TnlAssociationUsage::decode(data)?)
		} else {
			None
		};
		let tnl_address_weight_factor = if optionals[1] {
			Some(TnlAddressWeightFactor::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_tnl_association_address,
			tnl_association_usage,
			tnl_address_weight_factor,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.tnl_association_usage.is_some());
		optionals.push(self.tnl_address_weight_factor.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_tnl_association_address.encode(data)?;
		if let Some(x) = &self.tnl_association_usage {
			x.encode(data)?;
		}
		if let Some(x) = &self.tnl_address_weight_factor {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for AmfTnlAssociationToUpdateItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfTnlAssociationToUpdateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToUpdateItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfTnlAssociationToUpdateItem");
			e
		})
	}
}
// AmfUeNgapId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AmfUeNgapId(pub u64);

impl AmfUeNgapId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(1099511627775), false)?.0 as u64,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(
			data,
			Some(0),
			Some(1099511627775),
			false,
			self.0 as i128,
			false,
		)
	}
}

impl PerCodec for AmfUeNgapId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AmfUeNgapId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfUeNgapId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AmfUeNgapId");
			e
		})
	}
}
// AreaOfInterest
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterest {
	pub area_of_interest_tai_list: Option<AreaOfInterestTaiList>,
	pub area_of_interest_cell_list: Option<AreaOfInterestCellList>,
	pub area_of_interest_ran_node_list: Option<AreaOfInterestRanNodeList>,
}

impl AreaOfInterest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let area_of_interest_tai_list = if optionals[0] {
			Some(AreaOfInterestTaiList::decode(data)?)
		} else {
			None
		};
		let area_of_interest_cell_list = if optionals[1] {
			Some(AreaOfInterestCellList::decode(data)?)
		} else {
			None
		};
		let area_of_interest_ran_node_list = if optionals[2] {
			Some(AreaOfInterestRanNodeList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			area_of_interest_tai_list,
			area_of_interest_cell_list,
			area_of_interest_ran_node_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.area_of_interest_tai_list.is_some());
		optionals.push(self.area_of_interest_cell_list.is_some());
		optionals.push(self.area_of_interest_ran_node_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.area_of_interest_tai_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.area_of_interest_cell_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.area_of_interest_ran_node_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for AreaOfInterest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterest");
			e
		})
	}
}
// AreaOfInterestCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestCellList(pub NonEmpty<AreaOfInterestCellItem>);

impl AreaOfInterestCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AreaOfInterestCellItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AreaOfInterestCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestCellList");
			e
		})
	}
}
// AreaOfInterestCellItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestCellItem {
	pub ngran_cgi: NgranCgi,
}

impl AreaOfInterestCellItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cgi = NgranCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { ngran_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AreaOfInterestCellItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestCellItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestCellItem");
			e
		})
	}
}
// AreaOfInterestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestList(pub NonEmpty<AreaOfInterestItem>);

impl AreaOfInterestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AreaOfInterestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AreaOfInterestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestList");
			e
		})
	}
}
// AreaOfInterestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestItem {
	pub area_of_interest: AreaOfInterest,
	pub location_reporting_reference_id: LocationReportingReferenceId,
}

impl AreaOfInterestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let area_of_interest = AreaOfInterest::decode(data)?;
		let location_reporting_reference_id = LocationReportingReferenceId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			area_of_interest,
			location_reporting_reference_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.area_of_interest.encode(data)?;
		self.location_reporting_reference_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AreaOfInterestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestItem");
			e
		})
	}
}
// AreaOfInterestRanNodeList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestRanNodeList(pub NonEmpty<AreaOfInterestRanNodeItem>);

impl AreaOfInterestRanNodeList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AreaOfInterestRanNodeItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AreaOfInterestRanNodeList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestRanNodeList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestRanNodeList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestRanNodeList");
			e
		})
	}
}
// AreaOfInterestRanNodeItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestRanNodeItem {
	pub global_ran_node_id: GlobalRanNodeId,
}

impl AreaOfInterestRanNodeItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { global_ran_node_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AreaOfInterestRanNodeItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestRanNodeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestRanNodeItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestRanNodeItem");
			e
		})
	}
}
// AreaOfInterestTaiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestTaiList(pub NonEmpty<AreaOfInterestTaiItem>);

impl AreaOfInterestTaiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AreaOfInterestTaiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AreaOfInterestTaiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestTaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestTaiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestTaiList");
			e
		})
	}
}
// AreaOfInterestTaiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaOfInterestTaiItem {
	pub tai: Tai,
}

impl AreaOfInterestTaiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AreaOfInterestTaiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaOfInterestTaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestTaiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaOfInterestTaiItem");
			e
		})
	}
}
// AssistanceDataForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssistanceDataForPaging {
	pub assistance_data_for_recommended_cells: Option<AssistanceDataForRecommendedCells>,
	pub paging_attempt_information: Option<PagingAttemptInformation>,
	pub npn_paging_assistance_information: Option<NpnPagingAssistanceInformation>,
	pub paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe>,
}

impl AssistanceDataForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let assistance_data_for_recommended_cells = if optionals[0] {
			Some(AssistanceDataForRecommendedCells::decode(data)?)
		} else {
			None
		};
		let paging_attempt_information = if optionals[1] {
			Some(PagingAttemptInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut npn_paging_assistance_information: Option<NpnPagingAssistanceInformation> = None;
		let mut paging_assis_datafor_c_ecapab_ue: Option<PagingAssisDataforCEcapabUe> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					260 => {
						npn_paging_assistance_information =
							Some(NpnPagingAssistanceInformation::decode(data)?)
					}
					207 => {
						paging_assis_datafor_c_ecapab_ue =
							Some(PagingAssisDataforCEcapabUe::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			assistance_data_for_recommended_cells,
			paging_attempt_information,
			npn_paging_assistance_information,
			paging_assis_datafor_c_ecapab_ue,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.npn_paging_assistance_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 260, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.paging_assis_datafor_c_ecapab_ue {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 207, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.assistance_data_for_recommended_cells.is_some());
		optionals.push(self.paging_attempt_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.assistance_data_for_recommended_cells {
			x.encode(data)?;
		}
		if let Some(x) = &self.paging_attempt_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for AssistanceDataForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssistanceDataForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssistanceDataForPaging");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssistanceDataForPaging");
			e
		})
	}
}
// AssistanceDataForRecommendedCells
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssistanceDataForRecommendedCells {
	pub recommended_cells_for_paging: RecommendedCellsForPaging,
}

impl AssistanceDataForRecommendedCells {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let recommended_cells_for_paging = RecommendedCellsForPaging::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			recommended_cells_for_paging,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.recommended_cells_for_paging.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AssistanceDataForRecommendedCells {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssistanceDataForRecommendedCells::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssistanceDataForRecommendedCells");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssistanceDataForRecommendedCells");
			e
		})
	}
}
// AssociatedMbsQosFlowSetupRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedMbsQosFlowSetupRequestList(pub NonEmpty<AssociatedMbsQosFlowSetupRequestItem>);

impl AssociatedMbsQosFlowSetupRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AssociatedMbsQosFlowSetupRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AssociatedMbsQosFlowSetupRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedMbsQosFlowSetupRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetupRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetupRequestList");
			e
		})
	}
}
// AssociatedMbsQosFlowSetupRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedMbsQosFlowSetupRequestItem {
	pub mbs_qos_flow_identifier: QosFlowIdentifier,
	pub associated_unicast_qos_flow_identifier: QosFlowIdentifier,
}

impl AssociatedMbsQosFlowSetupRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let associated_unicast_qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_qos_flow_identifier,
			associated_unicast_qos_flow_identifier,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_qos_flow_identifier.encode(data)?;
		self.associated_unicast_qos_flow_identifier.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AssociatedMbsQosFlowSetupRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedMbsQosFlowSetupRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetupRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetupRequestItem");
			e
		})
	}
}
// AssociatedMbsQosFlowSetuporModifyRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedMbsQosFlowSetuporModifyRequestList(
	pub NonEmpty<AssociatedMbsQosFlowSetuporModifyRequestItem>,
);

impl AssociatedMbsQosFlowSetuporModifyRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AssociatedMbsQosFlowSetuporModifyRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AssociatedMbsQosFlowSetuporModifyRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedMbsQosFlowSetuporModifyRequestList::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("AssociatedMbsQosFlowSetuporModifyRequestList");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetuporModifyRequestList");
			e
		})
	}
}
// AssociatedMbsQosFlowSetuporModifyRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedMbsQosFlowSetuporModifyRequestItem {
	pub mbs_qos_flow_identifier: QosFlowIdentifier,
	pub associated_unicast_qos_flow_identifier: QosFlowIdentifier,
}

impl AssociatedMbsQosFlowSetuporModifyRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let associated_unicast_qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_qos_flow_identifier,
			associated_unicast_qos_flow_identifier,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_qos_flow_identifier.encode(data)?;
		self.associated_unicast_qos_flow_identifier.encode(data)?;

		Ok(())
	}
}

impl PerCodec for AssociatedMbsQosFlowSetuporModifyRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedMbsQosFlowSetuporModifyRequestItem::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("AssociatedMbsQosFlowSetuporModifyRequestItem");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedMbsQosFlowSetuporModifyRequestItem");
			e
		})
	}
}
// AssociatedQosFlowList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedQosFlowList(pub NonEmpty<AssociatedQosFlowItem>);

impl AssociatedQosFlowList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AssociatedQosFlowItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AssociatedQosFlowList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedQosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedQosFlowList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedQosFlowList");
			e
		})
	}
}
// AssociatedQosFlowItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AssociatedQosFlowItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub qos_flow_mapping_indication: Option<QosFlowMappingIndication>,
	pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl AssociatedQosFlowItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let qos_flow_mapping_indication = if optionals[0] {
			Some(QosFlowMappingIndication::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					221 => {
						current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			qos_flow_mapping_indication,
			current_qos_para_set_index,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.current_qos_para_set_index {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.qos_flow_mapping_indication.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.qos_flow_mapping_indication {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for AssociatedQosFlowItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AssociatedQosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedQosFlowItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AssociatedQosFlowItem");
			e
		})
	}
}
// AuthenticatedIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum AuthenticatedIndication {
	#[default]
	True,
}

impl AuthenticatedIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for AuthenticatedIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AuthenticatedIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AuthenticatedIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AuthenticatedIndication");
			e
		})
	}
}
// AveragingWindow
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct AveragingWindow(pub u16);

impl AveragingWindow {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4095), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(4095), true, self.0 as i128, false)
	}
}

impl PerCodec for AveragingWindow {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AveragingWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AveragingWindow");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AveragingWindow");
			e
		})
	}
}
// AreaScopeOfMdtNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum AreaScopeOfMdtNr {
	#[default]
	CellBased(CellBasedMdtNr),
	TaBased(TaBasedMdt),
	PlmnWide,
	TaiBased(TaiBasedMdt),
}

impl AreaScopeOfMdtNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CellBased(CellBasedMdtNr::decode(data)?)),
			1 => Ok(Self::TaBased(TaBasedMdt::decode(data)?)),
			2 => Ok(Self::PlmnWide),
			3 => Ok(Self::TaiBased(TaiBasedMdt::decode(data)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CellBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				x.encode(data)
			}
			Self::TaBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				x.encode(data)
			}
			Self::PlmnWide => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				Ok(())
			}
			Self::TaiBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for AreaScopeOfMdtNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaScopeOfMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfMdtNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfMdtNr");
			e
		})
	}
}
// AreaScopeOfMdtEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum AreaScopeOfMdtEutra {
	#[default]
	CellBased(CellBasedMdtEutra),
	TaBased(TaBasedMdt),
	PlmnWide,
	TaiBased(TaiBasedMdt),
}

impl AreaScopeOfMdtEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CellBased(CellBasedMdtEutra::decode(data)?)),
			1 => Ok(Self::TaBased(TaBasedMdt::decode(data)?)),
			2 => Ok(Self::PlmnWide),
			3 => Ok(Self::TaiBased(TaiBasedMdt::decode(data)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CellBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				x.encode(data)
			}
			Self::TaBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				x.encode(data)
			}
			Self::PlmnWide => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				Ok(())
			}
			Self::TaiBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for AreaScopeOfMdtEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaScopeOfMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfMdtEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfMdtEutra");
			e
		})
	}
}
// AreaScopeOfNeighCellsList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaScopeOfNeighCellsList(pub NonEmpty<AreaScopeOfNeighCellsItem>);

impl AreaScopeOfNeighCellsList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(AreaScopeOfNeighCellsItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for AreaScopeOfNeighCellsList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaScopeOfNeighCellsList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfNeighCellsList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfNeighCellsList");
			e
		})
	}
}
// AreaScopeOfNeighCellsItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AreaScopeOfNeighCellsItem {
	pub nr_frequency_info: NrFrequencyInfo,
	pub pci_list_for_mdt: Option<PciListForMdt>,
}

impl AreaScopeOfNeighCellsItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let nr_frequency_info = NrFrequencyInfo::decode(data)?;
		let pci_list_for_mdt = if optionals[0] {
			Some(PciListForMdt::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_frequency_info,
			pci_list_for_mdt,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.pci_list_for_mdt.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_frequency_info.encode(data)?;
		if let Some(x) = &self.pci_list_for_mdt {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for AreaScopeOfNeighCellsItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaScopeOfNeighCellsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfNeighCellsItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfNeighCellsItem");
			e
		})
	}
}
// AreaScopeOfQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum AreaScopeOfQmc {
	#[default]
	CellBased(CellBasedQmc),
	TaBased(TaBasedQmc),
	TaiBased(TaiBasedQmc),
	PlmnAreaBased(PlmnAreaBasedQmc),
}

impl AreaScopeOfQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CellBased(CellBasedQmc::decode(data)?)),
			1 => Ok(Self::TaBased(TaBasedQmc::decode(data)?)),
			2 => Ok(Self::TaiBased(TaiBasedQmc::decode(data)?)),
			3 => Ok(Self::PlmnAreaBased(PlmnAreaBasedQmc::decode(data)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CellBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				x.encode(data)
			}
			Self::TaBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				x.encode(data)
			}
			Self::TaiBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				x.encode(data)
			}
			Self::PlmnAreaBased(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for AreaScopeOfQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AreaScopeOfQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AreaScopeOfQmc");
			e
		})
	}
}
// AvailableRanVisibleQoEMetrics
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct AvailableRanVisibleQoEMetrics {
	pub application_layer_buffer_level_list: Option<ApplicationLayerBufferLevelList>,
	pub playout_delay_for_media_startup: Option<PlayoutDelayForMediaStartup>,
}

impl AvailableRanVisibleQoEMetrics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let application_layer_buffer_level_list = if optionals[0] {
			Some(ApplicationLayerBufferLevelList::decode(data)?)
		} else {
			None
		};
		let playout_delay_for_media_startup = if optionals[1] {
			Some(PlayoutDelayForMediaStartup::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			application_layer_buffer_level_list,
			playout_delay_for_media_startup,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.application_layer_buffer_level_list.is_some());
		optionals.push(self.playout_delay_for_media_startup.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.application_layer_buffer_level_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.playout_delay_for_media_startup {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for AvailableRanVisibleQoEMetrics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		AvailableRanVisibleQoEMetrics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AvailableRanVisibleQoEMetrics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("AvailableRanVisibleQoEMetrics");
			e
		})
	}
}
// BeamMeasurementsReportConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BeamMeasurementsReportConfiguration {
	pub beam_measurements_report_quantity: Option<BeamMeasurementsReportQuantity>,
	pub max_nrof_rs_indexes_to_report: Option<MaxNrofRsIndexesToReport>,
}

impl BeamMeasurementsReportConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let beam_measurements_report_quantity = if optionals[0] {
			Some(BeamMeasurementsReportQuantity::decode(data)?)
		} else {
			None
		};
		let max_nrof_rs_indexes_to_report = if optionals[1] {
			Some(MaxNrofRsIndexesToReport::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			beam_measurements_report_quantity,
			max_nrof_rs_indexes_to_report,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.beam_measurements_report_quantity.is_some());
		optionals.push(self.max_nrof_rs_indexes_to_report.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.beam_measurements_report_quantity {
			x.encode(data)?;
		}
		if let Some(x) = &self.max_nrof_rs_indexes_to_report {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for BeamMeasurementsReportConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BeamMeasurementsReportConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BeamMeasurementsReportConfiguration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BeamMeasurementsReportConfiguration");
			e
		})
	}
}
// BeamMeasurementsReportQuantity
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BeamMeasurementsReportQuantity {
	pub rsrp: Rsrp,
	pub rsrq: Rsrq,
	pub si_nr: SiNr,
}

impl BeamMeasurementsReportQuantity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let rsrp = Rsrp::decode(data)?;
		let rsrq = Rsrq::decode(data)?;
		let si_nr = SiNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { rsrp, rsrq, si_nr })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.rsrp.encode(data)?;
		self.rsrq.encode(data)?;
		self.si_nr.encode(data)?;

		Ok(())
	}
}

impl PerCodec for BeamMeasurementsReportQuantity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BeamMeasurementsReportQuantity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BeamMeasurementsReportQuantity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BeamMeasurementsReportQuantity");
			e
		})
	}
}
// BitRate
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct BitRate(pub u64);

impl BitRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4000000000000), true)?.0 as u64,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(
			data,
			Some(0),
			Some(4000000000000),
			true,
			self.0 as i128,
			false,
		)
	}
}

impl PerCodec for BitRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BitRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BitRate");
			e
		})
	}
}
// BroadcastCancelledAreaList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum BroadcastCancelledAreaList {
	#[default]
	CellIdCancelledEutra(CellIdCancelledEutra),
	TaiCancelledEutra(TaiCancelledEutra),
	EmergencyAreaIdCancelledEutra(EmergencyAreaIdCancelledEutra),
	CellIdCancelledNr(CellIdCancelledNr),
	TaiCancelledNr(TaiCancelledNr),
	EmergencyAreaIdCancelledNr(EmergencyAreaIdCancelledNr),
}

impl BroadcastCancelledAreaList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CellIdCancelledEutra(CellIdCancelledEutra::decode(
				data,
			)?)),
			1 => Ok(Self::TaiCancelledEutra(TaiCancelledEutra::decode(data)?)),
			2 => Ok(Self::EmergencyAreaIdCancelledEutra(
				EmergencyAreaIdCancelledEutra::decode(data)?,
			)),
			3 => Ok(Self::CellIdCancelledNr(CellIdCancelledNr::decode(data)?)),
			4 => Ok(Self::TaiCancelledNr(TaiCancelledNr::decode(data)?)),
			5 => Ok(Self::EmergencyAreaIdCancelledNr(
				EmergencyAreaIdCancelledNr::decode(data)?,
			)),
			6 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CellIdCancelledEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
				x.encode(data)
			}
			Self::TaiCancelledEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
				x.encode(data)
			}
			Self::EmergencyAreaIdCancelledEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
				x.encode(data)
			}
			Self::CellIdCancelledNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
				x.encode(data)
			}
			Self::TaiCancelledNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
				x.encode(data)
			}
			Self::EmergencyAreaIdCancelledNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for BroadcastCancelledAreaList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BroadcastCancelledAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastCancelledAreaList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastCancelledAreaList");
			e
		})
	}
}
// BroadcastCompletedAreaList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum BroadcastCompletedAreaList {
	#[default]
	CellIdBroadcastEutra(CellIdBroadcastEutra),
	TaiBroadcastEutra(TaiBroadcastEutra),
	EmergencyAreaIdBroadcastEutra(EmergencyAreaIdBroadcastEutra),
	CellIdBroadcastNr(CellIdBroadcastNr),
	TaiBroadcastNr(TaiBroadcastNr),
	EmergencyAreaIdBroadcastNr(EmergencyAreaIdBroadcastNr),
}

impl BroadcastCompletedAreaList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 6, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CellIdBroadcastEutra(CellIdBroadcastEutra::decode(
				data,
			)?)),
			1 => Ok(Self::TaiBroadcastEutra(TaiBroadcastEutra::decode(data)?)),
			2 => Ok(Self::EmergencyAreaIdBroadcastEutra(
				EmergencyAreaIdBroadcastEutra::decode(data)?,
			)),
			3 => Ok(Self::CellIdBroadcastNr(CellIdBroadcastNr::decode(data)?)),
			4 => Ok(Self::TaiBroadcastNr(TaiBroadcastNr::decode(data)?)),
			5 => Ok(Self::EmergencyAreaIdBroadcastNr(
				EmergencyAreaIdBroadcastNr::decode(data)?,
			)),
			6 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CellIdBroadcastEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 0, false)?;
				x.encode(data)
			}
			Self::TaiBroadcastEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 1, false)?;
				x.encode(data)
			}
			Self::EmergencyAreaIdBroadcastEutra(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 2, false)?;
				x.encode(data)
			}
			Self::CellIdBroadcastNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 3, false)?;
				x.encode(data)
			}
			Self::TaiBroadcastNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 4, false)?;
				x.encode(data)
			}
			Self::EmergencyAreaIdBroadcastNr(x) => {
				encode::encode_choice_idx(data, 0, 6, false, 5, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for BroadcastCompletedAreaList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BroadcastCompletedAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastCompletedAreaList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastCompletedAreaList");
			e
		})
	}
}
// BroadcastPlmnList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BroadcastPlmnList(pub NonEmpty<BroadcastPlmnItem>);

impl BroadcastPlmnList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(BroadcastPlmnItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for BroadcastPlmnList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BroadcastPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastPlmnList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastPlmnList");
			e
		})
	}
}
// BroadcastPlmnItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BroadcastPlmnItem {
	pub plmn_identity: PlmnIdentity,
	pub tai_slice_support_list: SliceSupportList,
	pub npn_support: Option<NpnSupport>,
	pub extended_tai_slice_support_list: Option<ExtendedSliceSupportList>,
	pub tainsag_support_list: Option<TainsagSupportList>,
}

impl BroadcastPlmnItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let tai_slice_support_list = SliceSupportList::decode(data)?;

		// Process the extension container
		let mut npn_support: Option<NpnSupport> = None;
		let mut extended_tai_slice_support_list: Option<ExtendedSliceSupportList> = None;
		let mut tainsag_support_list: Option<TainsagSupportList> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					258 => npn_support = Some(NpnSupport::decode(data)?),
					271 => {
						extended_tai_slice_support_list =
							Some(ExtendedSliceSupportList::decode(data)?)
					}
					353 => tainsag_support_list = Some(TainsagSupportList::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			tai_slice_support_list,
			npn_support,
			extended_tai_slice_support_list,
			tainsag_support_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.npn_support {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 258, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.extended_tai_slice_support_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 271, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.tainsag_support_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 353, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.tai_slice_support_list.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for BroadcastPlmnItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BroadcastPlmnItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastPlmnItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BroadcastPlmnItem");
			e
		})
	}
}
// BluetoothMeasurementConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BluetoothMeasurementConfiguration {
	pub bluetooth_meas_config: BluetoothMeasConfig,
	pub bluetooth_meas_config_name_list: Option<BluetoothMeasConfigNameList>,
	pub bt_rssi: Option<BtRssi>,
}

impl BluetoothMeasurementConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let bluetooth_meas_config = BluetoothMeasConfig::decode(data)?;
		let bluetooth_meas_config_name_list = if optionals[0] {
			Some(BluetoothMeasConfigNameList::decode(data)?)
		} else {
			None
		};
		let bt_rssi = if optionals[1] {
			Some(BtRssi::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			bluetooth_meas_config,
			bluetooth_meas_config_name_list,
			bt_rssi,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.bluetooth_meas_config_name_list.is_some());
		optionals.push(self.bt_rssi.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.bluetooth_meas_config.encode(data)?;
		if let Some(x) = &self.bluetooth_meas_config_name_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.bt_rssi {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for BluetoothMeasurementConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BluetoothMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasurementConfiguration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasurementConfiguration");
			e
		})
	}
}
// BluetoothMeasConfigNameList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BluetoothMeasConfigNameList(pub NonEmpty<BluetoothMeasConfigNameItem>);

impl BluetoothMeasConfigNameList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(BluetoothMeasConfigNameItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for BluetoothMeasConfigNameList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BluetoothMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfigNameList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfigNameList");
			e
		})
	}
}
// BluetoothMeasConfigNameItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BluetoothMeasConfigNameItem {
	pub bluetooth_name: BluetoothName,
}

impl BluetoothMeasConfigNameItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let bluetooth_name = BluetoothName::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { bluetooth_name })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.bluetooth_name.encode(data)?;

		Ok(())
	}
}

impl PerCodec for BluetoothMeasConfigNameItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BluetoothMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfigNameItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfigNameItem");
			e
		})
	}
}
// BluetoothMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum BluetoothMeasConfig {
	#[default]
	Setup,
}

impl BluetoothMeasConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for BluetoothMeasConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BluetoothMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothMeasConfig");
			e
		})
	}
}
// BluetoothName
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BluetoothName(pub Vec<u8>);

impl BluetoothName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(
			data,
			Some(1),
			Some(248),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(1), Some(248), false, &self.0, false)
	}
}

impl PerCodec for BluetoothName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BluetoothName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BluetoothName");
			e
		})
	}
}
// BurstArrivalTime
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct BurstArrivalTime(pub Vec<u8>);

impl BurstArrivalTime {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for BurstArrivalTime {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BurstArrivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BurstArrivalTime");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BurstArrivalTime");
			e
		})
	}
}
// CagId
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct CagId(pub BitString);

impl CagId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(32),
			Some(32),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
	}
}

impl PerCodec for CagId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CagId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CagId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CagId");
			e
		})
	}
}
// CancelAllWarningMessages
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CancelAllWarningMessages {
	#[default]
	True,
}

impl CancelAllWarningMessages {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for CancelAllWarningMessages {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelAllWarningMessages::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelAllWarningMessages");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelAllWarningMessages");
			e
		})
	}
}
// CancelledCellsInEaiEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInEaiEutra(pub NonEmpty<CancelledCellsInEaiEutraItem>);

impl CancelledCellsInEaiEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CancelledCellsInEaiEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CancelledCellsInEaiEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInEaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiEutra");
			e
		})
	}
}
// CancelledCellsInEaiEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInEaiEutraItem {
	pub eutra_cgi: EutraCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInEaiEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CancelledCellsInEaiEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInEaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiEutraItem");
			e
		})
	}
}
// CancelledCellsInEaiNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInEaiNr(pub NonEmpty<CancelledCellsInEaiNrItem>);

impl CancelledCellsInEaiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CancelledCellsInEaiNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CancelledCellsInEaiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInEaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiNr");
			e
		})
	}
}
// CancelledCellsInEaiNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInEaiNrItem {
	pub nr_cgi: NrCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInEaiNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CancelledCellsInEaiNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInEaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInEaiNrItem");
			e
		})
	}
}
// CancelledCellsInTaiEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInTaiEutra(pub NonEmpty<CancelledCellsInTaiEutraItem>);

impl CancelledCellsInTaiEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CancelledCellsInTaiEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CancelledCellsInTaiEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInTaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiEutra");
			e
		})
	}
}
// CancelledCellsInTaiEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInTaiEutraItem {
	pub eutra_cgi: EutraCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInTaiEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CancelledCellsInTaiEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInTaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiEutraItem");
			e
		})
	}
}
// CancelledCellsInTaiNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInTaiNr(pub NonEmpty<CancelledCellsInTaiNrItem>);

impl CancelledCellsInTaiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CancelledCellsInTaiNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CancelledCellsInTaiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInTaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiNr");
			e
		})
	}
}
// CancelledCellsInTaiNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CancelledCellsInTaiNrItem {
	pub nr_cgi: NrCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CancelledCellsInTaiNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CancelledCellsInTaiNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CancelledCellsInTaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CancelledCellsInTaiNrItem");
			e
		})
	}
}
// CandidateCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CandidateCellList(pub NonEmpty<CandidateCellItem>);

impl CandidateCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CandidateCellItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CandidateCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CandidateCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellList");
			e
		})
	}
}
// CandidateCellItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CandidateCellItem {
	pub candidate_cell: CandidateCell,
}

impl CandidateCellItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let candidate_cell = CandidateCell::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { candidate_cell })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.candidate_cell.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CandidateCellItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CandidateCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellItem");
			e
		})
	}
}
// CandidateCell
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum CandidateCell {
	#[default]
	CandidateCgi(CandidateCellId),
	CandidatePci(CandidatePci),
}

impl CandidateCell {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::CandidateCgi(CandidateCellId::decode(data)?)),
			1 => Ok(Self::CandidatePci(CandidatePci::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::CandidateCgi(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::CandidatePci(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for CandidateCell {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CandidateCell::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCell");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCell");
			e
		})
	}
}
// CandidateCellId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CandidateCellId {
	pub candidate_cell_id: NrCgi,
}

impl CandidateCellId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let candidate_cell_id = NrCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { candidate_cell_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.candidate_cell_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CandidateCellId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CandidateCellId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidateCellId");
			e
		})
	}
}
// CandidatePci
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CandidatePci {
	pub candidate_pci: u16,
	pub candidate_nr_arfcn: u32,
}

impl CandidatePci {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let candidate_pci = decode::decode_integer(data, Some(0), Some(1007), true)?.0 as u16;
		let candidate_nr_arfcn =
			decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			candidate_pci,
			candidate_nr_arfcn,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(1007),
			true,
			self.candidate_pci as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(3279165),
			false,
			self.candidate_nr_arfcn as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for CandidatePci {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CandidatePci::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidatePci");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CandidatePci");
			e
		})
	}
}
// Cause
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum Cause {
	#[default]
	RadioNetwork(CauseRadioNetwork),
	Transport(CauseTransport),
	Nas(CauseNas),
	Protocol(CauseProtocol),
	Misc(CauseMisc),
}

impl Cause {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 5, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::RadioNetwork(CauseRadioNetwork::decode(data)?)),
			1 => Ok(Self::Transport(CauseTransport::decode(data)?)),
			2 => Ok(Self::Nas(CauseNas::decode(data)?)),
			3 => Ok(Self::Protocol(CauseProtocol::decode(data)?)),
			4 => Ok(Self::Misc(CauseMisc::decode(data)?)),
			5 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::RadioNetwork(x) => {
				encode::encode_choice_idx(data, 0, 5, false, 0, false)?;
				x.encode(data)
			}
			Self::Transport(x) => {
				encode::encode_choice_idx(data, 0, 5, false, 1, false)?;
				x.encode(data)
			}
			Self::Nas(x) => {
				encode::encode_choice_idx(data, 0, 5, false, 2, false)?;
				x.encode(data)
			}
			Self::Protocol(x) => {
				encode::encode_choice_idx(data, 0, 5, false, 3, false)?;
				x.encode(data)
			}
			Self::Misc(x) => {
				encode::encode_choice_idx(data, 0, 5, false, 4, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for Cause {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Cause::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Cause");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Cause");
			e
		})
	}
}
// CauseMisc
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CauseMisc {
	#[default]
	ControlProcessingOverload,
	NotEnoughUserPlaneProcessingResources,
	HardwareFailure,
	OmIntervention,
	UnknownPlmnOrSnpn,
	Unspecified,
}

impl CauseMisc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for CauseMisc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CauseMisc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseMisc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseMisc");
			e
		})
	}
}
// CauseNas
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CauseNas {
	#[default]
	NormalRelease,
	AuthenticationFailure,
	Deregister,
	Unspecified,
}

impl CauseNas {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
	}
}

impl PerCodec for CauseNas {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CauseNas::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseNas");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseNas");
			e
		})
	}
}
// CauseProtocol
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CauseProtocol {
	#[default]
	TransferSyntaxError,
	AbstractSyntaxErrorReject,
	AbstractSyntaxErrorIgnoreAndNotify,
	MessageNotCompatibleWithReceiverState,
	SemanticError,
	AbstractSyntaxErrorFalselyConstructedMessage,
	Unspecified,
}

impl CauseProtocol {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
	}
}

impl PerCodec for CauseProtocol {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CauseProtocol::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseProtocol");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseProtocol");
			e
		})
	}
}
// CauseRadioNetwork
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CauseRadioNetwork {
	#[default]
	Unspecified,
	TxnrelocoverallExpiry,
	SuccessfulHandover,
	ReleaseDueToNgranGeneratedReason,
	ReleaseDueTo5gcGeneratedReason,
	HandoverCancelled,
	PartialHandover,
	HoFailureInTarget5gcNgranNodeOrTargetSystem,
	HoTargetNotAllowed,
	TngrelocoverallExpiry,
	TngrelocprepExpiry,
	CellNotAvailable,
	UnknownTargetId,
	NoRadioResourcesAvailableInTargetCell,
	UnknownLocalUeNgapId,
	InconsistentRemoteUeNgapId,
	HandoverDesirableForRadioReason,
	TimeCriticalHandover,
	ResourceOptimisationHandover,
	ReduceLoadInServingCell,
	UserInactivity,
	RadioConnectionWithUeLost,
	RadioResourcesNotAvailable,
	InvalidQosCombination,
	FailureInRadioInterfaceProcedure,
	InteractionWithOtherProcedure,
	UnknownPduSessionId,
	UnkownQosFlowId,
	MultiplePduSessionIdInstances,
	MultipleQosFlowIdInstances,
	EncryptionAndOrIntegrityProtectionAlgorithmsNotSupported,
	NgIntraSystemHandoverTriggered,
	NgInterSystemHandoverTriggered,
	XnHandoverTriggered,
	NotSupported5qiValue,
	UeContextTransfer,
	ImsVoiceEpsFallbackOrRatFallbackTriggered,
	UpIntegrityProtectionNotPossible,
	UpConfidentialityProtectionNotPossible,
	SliceNotSupported,
	UeInRrcInactiveStateNotReachable,
	Redirection,
	ResourcesNotAvailableForTheSlice,
	UeMaxIntegrityProtectedDataRateReason,
	ReleaseDueToCnDetectedMobility,
}

impl CauseRadioNetwork {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(44), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(44), true, *self as i128, false)
	}
}

impl PerCodec for CauseRadioNetwork {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CauseRadioNetwork::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseRadioNetwork");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseRadioNetwork");
			e
		})
	}
}
// CauseTransport
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CauseTransport {
	#[default]
	TransportResourceUnavailable,
	Unspecified,
}

impl CauseTransport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for CauseTransport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CauseTransport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseTransport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CauseTransport");
			e
		})
	}
}
// CellCagInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellCagInformation {
	pub ngran_cgi: NgranCgi,
	pub cell_cag_list: CellCagList,
}

impl CellCagInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cgi = NgranCgi::decode(data)?;
		let cell_cag_list = CellCagList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cgi,
			cell_cag_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;
		self.cell_cag_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellCagInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellCagInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellCagInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellCagInformation");
			e
		})
	}
}
// CellCagList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellCagList(pub NonEmpty<CagId>);

impl CellCagList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CagId::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellCagList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellCagList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellCagList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellCagList");
			e
		})
	}
}
// CellIdBroadcastEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdBroadcastEutra(pub NonEmpty<CellIdBroadcastEutraItem>);

impl CellIdBroadcastEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CellIdBroadcastEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdBroadcastEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastEutra");
			e
		})
	}
}
// CellIdBroadcastEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdBroadcastEutraItem {
	pub eutra_cgi: EutraCgi,
}

impl CellIdBroadcastEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { eutra_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellIdBroadcastEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastEutraItem");
			e
		})
	}
}
// CellIdBroadcastNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdBroadcastNr(pub NonEmpty<CellIdBroadcastNrItem>);

impl CellIdBroadcastNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CellIdBroadcastNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdBroadcastNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastNr");
			e
		})
	}
}
// CellIdBroadcastNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdBroadcastNrItem {
	pub nr_cgi: NrCgi,
}

impl CellIdBroadcastNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { nr_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellIdBroadcastNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdBroadcastNrItem");
			e
		})
	}
}
// CellIdCancelledEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdCancelledEutra(pub NonEmpty<CellIdCancelledEutraItem>);

impl CellIdCancelledEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CellIdCancelledEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdCancelledEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledEutra");
			e
		})
	}
}
// CellIdCancelledEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdCancelledEutraItem {
	pub eutra_cgi: EutraCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellIdCancelledEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellIdCancelledEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledEutraItem");
			e
		})
	}
}
// CellIdCancelledNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdCancelledNr(pub NonEmpty<CellIdCancelledNrItem>);

impl CellIdCancelledNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CellIdCancelledNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdCancelledNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledNr");
			e
		})
	}
}
// CellIdCancelledNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdCancelledNrItem {
	pub nr_cgi: NrCgi,
	pub number_of_broadcasts: NumberOfBroadcasts,
}

impl CellIdCancelledNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;
		let number_of_broadcasts = NumberOfBroadcasts::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_cgi,
			number_of_broadcasts,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;
		self.number_of_broadcasts.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellIdCancelledNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdCancelledNrItem");
			e
		})
	}
}
// CellIdListForRestart
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum CellIdListForRestart {
	#[default]
	EutraCgiListforRestart(EutraCgiList),
	NrCgiListforRestart(NrCgiList),
}

impl CellIdListForRestart {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EutraCgiListforRestart(EutraCgiList::decode(data)?)),
			1 => Ok(Self::NrCgiListforRestart(NrCgiList::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EutraCgiListforRestart(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::NrCgiListforRestart(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for CellIdListForRestart {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListForRestart");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListForRestart");
			e
		})
	}
}
// CellSize
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CellSize {
	#[default]
	Verysmall,
	Small,
	Medium,
	Large,
}

impl CellSize {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
	}
}

impl PerCodec for CellSize {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellSize::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellSize");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellSize");
			e
		})
	}
}
// CellType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellType {
	pub cell_size: CellSize,
}

impl CellType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cell_size = CellSize::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cell_size })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cell_size.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellType");
			e
		})
	}
}
// CEmodeBSupportIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CEmodeBSupportIndicator {
	#[default]
	Supported,
}

impl CEmodeBSupportIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for CEmodeBSupportIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CEmodeBSupportIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CEmodeBSupportIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CEmodeBSupportIndicator");
			e
		})
	}
}
// CEmodeBrestricted
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CEmodeBrestricted {
	#[default]
	Restricted,
	NotRestricted,
}

impl CEmodeBrestricted {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for CEmodeBrestricted {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CEmodeBrestricted::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CEmodeBrestricted");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CEmodeBrestricted");
			e
		})
	}
}
// CnAssistedRanTuning
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CnAssistedRanTuning {
	pub expected_ue_behaviour: Option<ExpectedUeBehaviour>,
}

impl CnAssistedRanTuning {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let expected_ue_behaviour = if optionals[0] {
			Some(ExpectedUeBehaviour::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			expected_ue_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.expected_ue_behaviour.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.expected_ue_behaviour {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for CnAssistedRanTuning {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CnAssistedRanTuning::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnAssistedRanTuning");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnAssistedRanTuning");
			e
		})
	}
}
// CNsubgroupId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct CNsubgroupId(pub u8);

impl CNsubgroupId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(7), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(7), true, self.0 as i128, false)
	}
}

impl PerCodec for CNsubgroupId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CNsubgroupId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CNsubgroupId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CNsubgroupId");
			e
		})
	}
}
// CnTypeRestrictionsForEquivalent
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CnTypeRestrictionsForEquivalent(pub NonEmpty<CnTypeRestrictionsForEquivalentItem>);

impl CnTypeRestrictionsForEquivalent {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(15), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CnTypeRestrictionsForEquivalentItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(15), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CnTypeRestrictionsForEquivalent {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CnTypeRestrictionsForEquivalent::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForEquivalent");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForEquivalent");
			e
		})
	}
}
// CnTypeRestrictionsForEquivalentItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CnTypeRestrictionsForEquivalentItem {
	pub plmn_identity: PlmnIdentity,
	pub cn_type: CnType,
}

impl CnTypeRestrictionsForEquivalentItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let cn_type = CnType::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			cn_type,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.cn_type.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CnTypeRestrictionsForEquivalentItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CnTypeRestrictionsForEquivalentItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForEquivalentItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForEquivalentItem");
			e
		})
	}
}
// CnTypeRestrictionsForServing
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CnTypeRestrictionsForServing {
	#[default]
	EpcForbidden,
}

impl CnTypeRestrictionsForServing {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for CnTypeRestrictionsForServing {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CnTypeRestrictionsForServing::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForServing");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnTypeRestrictionsForServing");
			e
		})
	}
}
// CommonNetworkInstance
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CommonNetworkInstance(pub Vec<u8>);

impl CommonNetworkInstance {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for CommonNetworkInstance {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CommonNetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CommonNetworkInstance");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CommonNetworkInstance");
			e
		})
	}
}
// CompletedCellsInEaiEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInEaiEutra(pub NonEmpty<CompletedCellsInEaiEutraItem>);

impl CompletedCellsInEaiEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CompletedCellsInEaiEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CompletedCellsInEaiEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInEaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiEutra");
			e
		})
	}
}
// CompletedCellsInEaiEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInEaiEutraItem {
	pub eutra_cgi: EutraCgi,
}

impl CompletedCellsInEaiEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { eutra_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CompletedCellsInEaiEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInEaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiEutraItem");
			e
		})
	}
}
// CompletedCellsInEaiNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInEaiNr(pub NonEmpty<CompletedCellsInEaiNrItem>);

impl CompletedCellsInEaiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CompletedCellsInEaiNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CompletedCellsInEaiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInEaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiNr");
			e
		})
	}
}
// CompletedCellsInEaiNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInEaiNrItem {
	pub nr_cgi: NrCgi,
}

impl CompletedCellsInEaiNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { nr_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CompletedCellsInEaiNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInEaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInEaiNrItem");
			e
		})
	}
}
// CompletedCellsInTaiEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInTaiEutra(pub NonEmpty<CompletedCellsInTaiEutraItem>);

impl CompletedCellsInTaiEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CompletedCellsInTaiEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CompletedCellsInTaiEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInTaiEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiEutra");
			e
		})
	}
}
// CompletedCellsInTaiEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInTaiEutraItem {
	pub eutra_cgi: EutraCgi,
}

impl CompletedCellsInTaiEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { eutra_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CompletedCellsInTaiEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInTaiEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiEutraItem");
			e
		})
	}
}
// CompletedCellsInTaiNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInTaiNr(pub NonEmpty<CompletedCellsInTaiNrItem>);

impl CompletedCellsInTaiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CompletedCellsInTaiNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CompletedCellsInTaiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInTaiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiNr");
			e
		})
	}
}
// CompletedCellsInTaiNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompletedCellsInTaiNrItem {
	pub nr_cgi: NrCgi,
}

impl CompletedCellsInTaiNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_cgi = NrCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { nr_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CompletedCellsInTaiNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompletedCellsInTaiNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompletedCellsInTaiNrItem");
			e
		})
	}
}
// ConcurrentWarningMessageInd
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ConcurrentWarningMessageInd {
	#[default]
	True,
}

impl ConcurrentWarningMessageInd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ConcurrentWarningMessageInd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ConcurrentWarningMessageInd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConcurrentWarningMessageInd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConcurrentWarningMessageInd");
			e
		})
	}
}
// ConfidentialityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ConfidentialityProtectionIndication {
	#[default]
	Required,
	Preferred,
	NotNeeded,
}

impl ConfidentialityProtectionIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for ConfidentialityProtectionIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ConfidentialityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfidentialityProtectionIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfidentialityProtectionIndication");
			e
		})
	}
}
// ConfidentialityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ConfidentialityProtectionResult {
	#[default]
	Performed,
	NotPerformed,
}

impl ConfidentialityProtectionResult {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for ConfidentialityProtectionResult {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ConfidentialityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfidentialityProtectionResult");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfidentialityProtectionResult");
			e
		})
	}
}
// ConfiguredTacIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ConfiguredTacIndication {
	#[default]
	True,
}

impl ConfiguredTacIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ConfiguredTacIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ConfiguredTacIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfiguredTacIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfiguredTacIndication");
			e
		})
	}
}
// CoreNetworkAssistanceInformationForInactive
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CoreNetworkAssistanceInformationForInactive {
	pub ue_identity_index_value: UeIdentityIndexValue,
	pub ue_specific_drx: Option<PagingDrx>,
	pub periodic_registration_update_timer: PeriodicRegistrationUpdateTimer,
	pub mico_mode_indication: Option<MicoModeIndication>,
	pub tai_list_for_inactive: TaiListForInactive,
	pub expected_ue_behaviour: Option<ExpectedUeBehaviour>,
	pub eutra_paginge_drx_information: Option<EutraPagingeDrxInformation>,
	pub extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue>,
	pub ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging>,
	pub mico_all_plmn: Option<MicoAllPlmn>,
	pub nr_paginge_drx_information: Option<NrPagingeDrxInformation>,
	pub paging_cause_indication_for_voice_service: Option<PagingCauseIndicationForVoiceService>,
	pub peip_sassistance_information: Option<PeipSassistanceInformation>,
	pub hashed_ue_identity_index_value: Option<HashedUeIdentityIndexValue>,
}

impl CoreNetworkAssistanceInformationForInactive {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let ue_identity_index_value = UeIdentityIndexValue::decode(data)?;
		let ue_specific_drx = if optionals[0] {
			Some(PagingDrx::decode(data)?)
		} else {
			None
		};
		let periodic_registration_update_timer = PeriodicRegistrationUpdateTimer::decode(data)?;
		let mico_mode_indication = if optionals[1] {
			Some(MicoModeIndication::decode(data)?)
		} else {
			None
		};
		let tai_list_for_inactive = TaiListForInactive::decode(data)?;
		let expected_ue_behaviour = if optionals[2] {
			Some(ExpectedUeBehaviour::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut eutra_paginge_drx_information: Option<EutraPagingeDrxInformation> = None;
		let mut extended_ue_identity_index_value: Option<ExtendedUeIdentityIndexValue> = None;
		let mut ue_radio_capability_for_paging: Option<UeRadioCapabilityForPaging> = None;
		let mut mico_all_plmn: Option<MicoAllPlmn> = None;
		let mut nr_paginge_drx_information: Option<NrPagingeDrxInformation> = None;
		let mut paging_cause_indication_for_voice_service: Option<
			PagingCauseIndicationForVoiceService,
		> = None;
		let mut peip_sassistance_information: Option<PeipSassistanceInformation> = None;
		let mut hashed_ue_identity_index_value: Option<HashedUeIdentityIndexValue> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					223 => {
						eutra_paginge_drx_information =
							Some(EutraPagingeDrxInformation::decode(data)?)
					}
					280 => {
						extended_ue_identity_index_value =
							Some(ExtendedUeIdentityIndexValue::decode(data)?)
					}
					118 => {
						ue_radio_capability_for_paging =
							Some(UeRadioCapabilityForPaging::decode(data)?)
					}
					282 => mico_all_plmn = Some(MicoAllPlmn::decode(data)?),
					332 => {
						nr_paginge_drx_information = Some(NrPagingeDrxInformation::decode(data)?)
					}
					343 => {
						paging_cause_indication_for_voice_service =
							Some(PagingCauseIndicationForVoiceService::decode(data)?)
					}
					344 => {
						peip_sassistance_information =
							Some(PeipSassistanceInformation::decode(data)?)
					}
					365 => {
						hashed_ue_identity_index_value =
							Some(HashedUeIdentityIndexValue::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_identity_index_value,
			ue_specific_drx,
			periodic_registration_update_timer,
			mico_mode_indication,
			tai_list_for_inactive,
			expected_ue_behaviour,
			eutra_paginge_drx_information,
			extended_ue_identity_index_value,
			ue_radio_capability_for_paging,
			mico_all_plmn,
			nr_paginge_drx_information,
			paging_cause_indication_for_voice_service,
			peip_sassistance_information,
			hashed_ue_identity_index_value,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.eutra_paginge_drx_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 223, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.extended_ue_identity_index_value {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 280, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ue_radio_capability_for_paging {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 118, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mico_all_plmn {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 282, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.nr_paginge_drx_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 332, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.paging_cause_indication_for_voice_service {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 343, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.peip_sassistance_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 344, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.hashed_ue_identity_index_value {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 365, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.ue_specific_drx.is_some());
		optionals.push(self.mico_mode_indication.is_some());
		optionals.push(self.expected_ue_behaviour.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_identity_index_value.encode(data)?;
		if let Some(x) = &self.ue_specific_drx {
			x.encode(data)?;
		}
		self.periodic_registration_update_timer.encode(data)?;
		if let Some(x) = &self.mico_mode_indication {
			x.encode(data)?;
		}
		self.tai_list_for_inactive.encode(data)?;
		if let Some(x) = &self.expected_ue_behaviour {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for CoreNetworkAssistanceInformationForInactive {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CoreNetworkAssistanceInformationForInactive::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("CoreNetworkAssistanceInformationForInactive");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CoreNetworkAssistanceInformationForInactive");
			e
		})
	}
}
// CountValueForPdcpSn12
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CountValueForPdcpSn12 {
	pub pdcp_sn12: u16,
	pub hfn_pdcp_sn12: u32,
}

impl CountValueForPdcpSn12 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdcp_sn12 = decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16;
		let hfn_pdcp_sn12 = decode::decode_integer(data, Some(0), Some(1048575), false)?.0 as u32;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdcp_sn12,
			hfn_pdcp_sn12,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(4095),
			false,
			self.pdcp_sn12 as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(1048575),
			false,
			self.hfn_pdcp_sn12 as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for CountValueForPdcpSn12 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CountValueForPdcpSn12::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CountValueForPdcpSn12");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CountValueForPdcpSn12");
			e
		})
	}
}
// CountValueForPdcpSn18
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CountValueForPdcpSn18 {
	pub pdcp_sn18: u32,
	pub hfn_pdcp_sn18: u16,
}

impl CountValueForPdcpSn18 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdcp_sn18 = decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32;
		let hfn_pdcp_sn18 = decode::decode_integer(data, Some(0), Some(16383), false)?.0 as u16;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdcp_sn18,
			hfn_pdcp_sn18,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(262143),
			false,
			self.pdcp_sn18 as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(16383),
			false,
			self.hfn_pdcp_sn18 as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for CountValueForPdcpSn18 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CountValueForPdcpSn18::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CountValueForPdcpSn18");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CountValueForPdcpSn18");
			e
		})
	}
}
// CoverageEnhancementLevel
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CoverageEnhancementLevel(pub Vec<u8>);

impl CoverageEnhancementLevel {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for CoverageEnhancementLevel {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CoverageEnhancementLevel::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CoverageEnhancementLevel");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CoverageEnhancementLevel");
			e
		})
	}
}
// CpTransportLayerInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum CpTransportLayerInformation {
	#[default]
	EndpointIpAddress(TransportLayerAddress),
	EndpointIpAddressAndPort(EndpointIpAddressAndPort),
}

impl CpTransportLayerInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EndpointIpAddress(TransportLayerAddress::decode(
				data,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					169 => Ok(Self::EndpointIpAddressAndPort(
						EndpointIpAddressAndPort::decode(data)?,
					)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EndpointIpAddress(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
			Self::EndpointIpAddressAndPort(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 169, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for CpTransportLayerInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CpTransportLayerInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CpTransportLayerInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CpTransportLayerInformation");
			e
		})
	}
}
// CriticalityDiagnostics
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CriticalityDiagnostics {
	pub procedure_code: Option<ProcedureCode>,
	pub triggering_message: Option<TriggeringMessage>,
	pub procedure_criticality: Option<Criticality>,
	pub i_es_criticality_diagnostics: Option<CriticalityDiagnosticsIeList>,
}

impl CriticalityDiagnostics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let procedure_code = if optionals[0] {
			Some(ProcedureCode::decode(data)?)
		} else {
			None
		};
		let triggering_message = if optionals[1] {
			Some(TriggeringMessage::decode(data)?)
		} else {
			None
		};
		let procedure_criticality = if optionals[2] {
			Some(Criticality::decode(data)?)
		} else {
			None
		};
		let i_es_criticality_diagnostics = if optionals[3] {
			Some(CriticalityDiagnosticsIeList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			procedure_code,
			triggering_message,
			procedure_criticality,
			i_es_criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.procedure_code.is_some());
		optionals.push(self.triggering_message.is_some());
		optionals.push(self.procedure_criticality.is_some());
		optionals.push(self.i_es_criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.procedure_code {
			x.encode(data)?;
		}
		if let Some(x) = &self.triggering_message {
			x.encode(data)?;
		}
		if let Some(x) = &self.procedure_criticality {
			x.encode(data)?;
		}
		if let Some(x) = &self.i_es_criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for CriticalityDiagnostics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CriticalityDiagnostics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnostics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnostics");
			e
		})
	}
}
// CriticalityDiagnosticsIeList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CriticalityDiagnosticsIeList(pub NonEmpty<CriticalityDiagnosticsIeItem>);

impl CriticalityDiagnosticsIeList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(CriticalityDiagnosticsIeItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CriticalityDiagnosticsIeList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CriticalityDiagnosticsIeList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnosticsIeList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnosticsIeList");
			e
		})
	}
}
// CriticalityDiagnosticsIeItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CriticalityDiagnosticsIeItem {
	pub ie_criticality: Criticality,
	pub ie_id: ProtocolIeId,
	pub type_of_error: TypeOfError,
}

impl CriticalityDiagnosticsIeItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ie_criticality = Criticality::decode(data)?;
		let ie_id = ProtocolIeId::decode(data)?;
		let type_of_error = TypeOfError::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ie_criticality,
			ie_id,
			type_of_error,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ie_criticality.encode(data)?;
		self.ie_id.encode(data)?;
		self.type_of_error.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CriticalityDiagnosticsIeItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CriticalityDiagnosticsIeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnosticsIeItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CriticalityDiagnosticsIeItem");
			e
		})
	}
}
// CellBasedMdtNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellBasedMdtNr {
	pub cell_id_listfor_mdt: CellIdListforMdtNr,
}

impl CellBasedMdtNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cell_id_listfor_mdt = CellIdListforMdtNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cell_id_listfor_mdt,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cell_id_listfor_mdt.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellBasedMdtNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellBasedMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedMdtNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedMdtNr");
			e
		})
	}
}
// CellIdListforMdtNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdListforMdtNr(pub NonEmpty<NrCgi>);

impl CellIdListforMdtNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdListforMdtNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdListforMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforMdtNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforMdtNr");
			e
		})
	}
}
// CellBasedMdtEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellBasedMdtEutra {
	pub cell_id_listfor_mdt: CellIdListforMdtEutra,
}

impl CellBasedMdtEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cell_id_listfor_mdt = CellIdListforMdtEutra::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cell_id_listfor_mdt,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cell_id_listfor_mdt.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellBasedMdtEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellBasedMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedMdtEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedMdtEutra");
			e
		})
	}
}
// CellBasedQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellBasedQmc {
	pub cell_id_listfor_qmc: CellIdListforQmc,
}

impl CellBasedQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cell_id_listfor_qmc = CellIdListforQmc::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cell_id_listfor_qmc,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cell_id_listfor_qmc.encode(data)?;

		Ok(())
	}
}

impl PerCodec for CellBasedQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellBasedQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellBasedQmc");
			e
		})
	}
}
// CellIdListforQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdListforQmc(pub NonEmpty<NgranCgi>);

impl CellIdListforQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdListforQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdListforQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforQmc");
			e
		})
	}
}
// CellIdListforMdtEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellIdListforMdtEutra(pub NonEmpty<EutraCgi>);

impl CellIdListforMdtEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EutraCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellIdListforMdtEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellIdListforMdtEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforMdtEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellIdListforMdtEutra");
			e
		})
	}
}
// DataCodingScheme
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct DataCodingScheme(pub BitString);

impl DataCodingScheme {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for DataCodingScheme {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataCodingScheme::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataCodingScheme");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataCodingScheme");
			e
		})
	}
}
// DataForwardingAccepted
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DataForwardingAccepted {
	#[default]
	DataForwardingAccepted,
}

impl DataForwardingAccepted {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DataForwardingAccepted {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingAccepted::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingAccepted");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingAccepted");
			e
		})
	}
}
// DataForwardingNotPossible
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DataForwardingNotPossible {
	#[default]
	DataForwardingNotPossible,
}

impl DataForwardingNotPossible {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DataForwardingNotPossible {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingNotPossible::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingNotPossible");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingNotPossible");
			e
		})
	}
}
// DataForwardingResponseDrbList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DataForwardingResponseDrbList(pub NonEmpty<DataForwardingResponseDrbItem>);

impl DataForwardingResponseDrbList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DataForwardingResponseDrbItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DataForwardingResponseDrbList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingResponseDrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseDrbList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseDrbList");
			e
		})
	}
}
// DataForwardingResponseDrbItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DataForwardingResponseDrbItem {
	pub drb_id: DrbId,
	pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl DataForwardingResponseDrbItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let drb_id = DrbId::decode(data)?;
		let dl_forwarding_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let ul_forwarding_up_tnl_information = if optionals[1] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drb_id,
			dl_forwarding_up_tnl_information,
			ul_forwarding_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.dl_forwarding_up_tnl_information.is_some());
		optionals.push(self.ul_forwarding_up_tnl_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drb_id.encode(data)?;
		if let Some(x) = &self.dl_forwarding_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.ul_forwarding_up_tnl_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for DataForwardingResponseDrbItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingResponseDrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseDrbItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseDrbItem");
			e
		})
	}
}
// DapsRequestInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DapsRequestInfo {
	pub daps_indicator: DapsIndicator,
}

impl DapsRequestInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let daps_indicator = DapsIndicator::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { daps_indicator })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.daps_indicator.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DapsRequestInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DapsRequestInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsRequestInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsRequestInfo");
			e
		})
	}
}
// DapsResponseInfoList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DapsResponseInfoList(pub NonEmpty<DapsResponseInfoItem>);

impl DapsResponseInfoList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DapsResponseInfoItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DapsResponseInfoList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DapsResponseInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfoList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfoList");
			e
		})
	}
}
// DapsResponseInfoItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DapsResponseInfoItem {
	pub drb_id: DrbId,
	pub daps_response_info: DapsResponseInfo,
}

impl DapsResponseInfoItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drb_id = DrbId::decode(data)?;
		let daps_response_info = DapsResponseInfo::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drb_id,
			daps_response_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drb_id.encode(data)?;
		self.daps_response_info.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DapsResponseInfoItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DapsResponseInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfoItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfoItem");
			e
		})
	}
}
// DapsResponseInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DapsResponseInfo {
	pub dapsresponseindicator: Dapsresponseindicator,
}

impl DapsResponseInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dapsresponseindicator = Dapsresponseindicator::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dapsresponseindicator,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dapsresponseindicator.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DapsResponseInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DapsResponseInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsResponseInfo");
			e
		})
	}
}
// DataForwardingResponseErabList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DataForwardingResponseErabList(pub NonEmpty<DataForwardingResponseErabListItem>);

impl DataForwardingResponseErabList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DataForwardingResponseErabListItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DataForwardingResponseErabList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingResponseErabList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseErabList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseErabList");
			e
		})
	}
}
// DataForwardingResponseErabListItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DataForwardingResponseErabListItem {
	pub e_rab_id: ERabId,
	pub dl_forwarding_up_tnl_information: UpTransportLayerInformation,
}

impl DataForwardingResponseErabListItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let e_rab_id = ERabId::decode(data)?;
		let dl_forwarding_up_tnl_information = UpTransportLayerInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			e_rab_id,
			dl_forwarding_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.e_rab_id.encode(data)?;
		self.dl_forwarding_up_tnl_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DataForwardingResponseErabListItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DataForwardingResponseErabListItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseErabListItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DataForwardingResponseErabListItem");
			e
		})
	}
}
// DelayCritical
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DelayCritical {
	#[default]
	DelayCritical,
	NonDelayCritical,
}

impl DelayCritical {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for DelayCritical {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DelayCritical::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DelayCritical");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DelayCritical");
			e
		})
	}
}
// DlCpSecurityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DlCpSecurityInformation {
	pub dl_nas_mac: DlNasMac,
}

impl DlCpSecurityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dl_nas_mac = DlNasMac::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { dl_nas_mac })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_nas_mac.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DlCpSecurityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DlCpSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlCpSecurityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlCpSecurityInformation");
			e
		})
	}
}
// DlNasMac
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct DlNasMac(pub BitString);

impl DlNasMac {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for DlNasMac {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DlNasMac::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlNasMac");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlNasMac");
			e
		})
	}
}
// DlForwarding
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DlForwarding {
	#[default]
	DlForwardingProposed,
}

impl DlForwarding {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DlForwarding {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DlForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlForwarding");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlForwarding");
			e
		})
	}
}
// DlNguTnlInformationReused
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DlNguTnlInformationReused {
	#[default]
	True,
}

impl DlNguTnlInformationReused {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DlNguTnlInformationReused {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DlNguTnlInformationReused::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlNguTnlInformationReused");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DlNguTnlInformationReused");
			e
		})
	}
}
// DirectForwardingPathAvailability
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DirectForwardingPathAvailability {
	#[default]
	DirectPathAvailable,
}

impl DirectForwardingPathAvailability {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DirectForwardingPathAvailability {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DirectForwardingPathAvailability::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DirectForwardingPathAvailability");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DirectForwardingPathAvailability");
			e
		})
	}
}
// DrbId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct DrbId(pub u8);

impl DrbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(32), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(32), true, self.0 as i128, false)
	}
}

impl PerCodec for DrbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbId");
			e
		})
	}
}
// DrbsSubjectToStatusTransferList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsSubjectToStatusTransferList(pub NonEmpty<DrbsSubjectToStatusTransferItem>);

impl DrbsSubjectToStatusTransferList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DrbsSubjectToStatusTransferItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DrbsSubjectToStatusTransferList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsSubjectToStatusTransferList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToStatusTransferList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToStatusTransferList");
			e
		})
	}
}
// DrbsSubjectToStatusTransferItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsSubjectToStatusTransferItem {
	pub drb_id: DrbId,
	pub drb_status_ul: DrbStatusUl,
	pub drb_status_dl: DrbStatusDl,
	pub old_associated_qos_flow_list_ul_endmarkerexpected: Option<AssociatedQosFlowList>,
}

impl DrbsSubjectToStatusTransferItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drb_id = DrbId::decode(data)?;
		let drb_status_ul = DrbStatusUl::decode(data)?;
		let drb_status_dl = DrbStatusDl::decode(data)?;

		// Process the extension container
		let mut old_associated_qos_flow_list_ul_endmarkerexpected: Option<AssociatedQosFlowList> =
			None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					159 => {
						old_associated_qos_flow_list_ul_endmarkerexpected =
							Some(AssociatedQosFlowList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drb_id,
			drb_status_ul,
			drb_status_dl,
			old_associated_qos_flow_list_ul_endmarkerexpected,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.old_associated_qos_flow_list_ul_endmarkerexpected {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 159, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drb_id.encode(data)?;
		self.drb_status_ul.encode(data)?;
		self.drb_status_dl.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for DrbsSubjectToStatusTransferItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsSubjectToStatusTransferItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToStatusTransferItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToStatusTransferItem");
			e
		})
	}
}
// DrbStatusDl
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum DrbStatusDl {
	#[default]
	DrbStatusDl12(DrbStatusDl12),
	DrbStatusDl18(DrbStatusDl18),
}

impl DrbStatusDl {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::DrbStatusDl12(DrbStatusDl12::decode(data)?)),
			1 => Ok(Self::DrbStatusDl18(DrbStatusDl18::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::DrbStatusDl12(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::DrbStatusDl18(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for DrbStatusDl {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusDl::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl");
			e
		})
	}
}
// DrbStatusDl12
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbStatusDl12 {
	pub dl_count_value: CountValueForPdcpSn12,
}

impl DrbStatusDl12 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dl_count_value = CountValueForPdcpSn12::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { dl_count_value })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_count_value.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DrbStatusDl12 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusDl12::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl12");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl12");
			e
		})
	}
}
// DrbStatusDl18
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbStatusDl18 {
	pub dl_count_value: CountValueForPdcpSn18,
}

impl DrbStatusDl18 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dl_count_value = CountValueForPdcpSn18::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { dl_count_value })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_count_value.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DrbStatusDl18 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusDl18::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl18");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusDl18");
			e
		})
	}
}
// DrbStatusUl
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum DrbStatusUl {
	#[default]
	DrbStatusUl12(DrbStatusUl12),
	DrbStatusUl18(DrbStatusUl18),
}

impl DrbStatusUl {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::DrbStatusUl12(DrbStatusUl12::decode(data)?)),
			1 => Ok(Self::DrbStatusUl18(DrbStatusUl18::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::DrbStatusUl12(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::DrbStatusUl18(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for DrbStatusUl {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusUl::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl");
			e
		})
	}
}
// DrbStatusUl12
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbStatusUl12 {
	pub ul_count_value: CountValueForPdcpSn12,
	pub receive_status_of_ul_pdcp_s_du_s: Option<BitString>,
}

impl DrbStatusUl12 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ul_count_value = CountValueForPdcpSn12::decode(data)?;
		let receive_status_of_ul_pdcp_s_du_s = if optionals[0] {
			Some(decode::decode_bitstring(data, Some(1), Some(2048), false)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_count_value,
			receive_status_of_ul_pdcp_s_du_s,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.receive_status_of_ul_pdcp_s_du_s.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ul_count_value.encode(data)?;
		if let Some(x) = &self.receive_status_of_ul_pdcp_s_du_s {
			encode::encode_bitstring(data, Some(1), Some(2048), false, &x, false)?;
		}

		Ok(())
	}
}

impl PerCodec for DrbStatusUl12 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusUl12::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl12");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl12");
			e
		})
	}
}
// DrbStatusUl18
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbStatusUl18 {
	pub ul_count_value: CountValueForPdcpSn18,
	pub receive_status_of_ul_pdcp_s_du_s: Option<BitString>,
}

impl DrbStatusUl18 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ul_count_value = CountValueForPdcpSn18::decode(data)?;
		let receive_status_of_ul_pdcp_s_du_s = if optionals[0] {
			Some(decode::decode_bitstring(
				data,
				Some(1),
				Some(131072),
				false,
			)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_count_value,
			receive_status_of_ul_pdcp_s_du_s,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.receive_status_of_ul_pdcp_s_du_s.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ul_count_value.encode(data)?;
		if let Some(x) = &self.receive_status_of_ul_pdcp_s_du_s {
			encode::encode_bitstring(data, Some(1), Some(131072), false, &x, false)?;
		}

		Ok(())
	}
}

impl PerCodec for DrbStatusUl18 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbStatusUl18::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl18");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbStatusUl18");
			e
		})
	}
}
// DrbsToQosFlowsMappingList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsToQosFlowsMappingList(pub NonEmpty<DrbsToQosFlowsMappingItem>);

impl DrbsToQosFlowsMappingList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DrbsToQosFlowsMappingItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DrbsToQosFlowsMappingList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsToQosFlowsMappingList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsToQosFlowsMappingList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsToQosFlowsMappingList");
			e
		})
	}
}
// DrbsToQosFlowsMappingItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsToQosFlowsMappingItem {
	pub drb_id: DrbId,
	pub associated_qos_flow_list: AssociatedQosFlowList,
	pub daps_request_info: Option<DapsRequestInfo>,
}

impl DrbsToQosFlowsMappingItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drb_id = DrbId::decode(data)?;
		let associated_qos_flow_list = AssociatedQosFlowList::decode(data)?;

		// Process the extension container
		let mut daps_request_info: Option<DapsRequestInfo> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					266 => daps_request_info = Some(DapsRequestInfo::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drb_id,
			associated_qos_flow_list,
			daps_request_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.daps_request_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 266, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drb_id.encode(data)?;
		self.associated_qos_flow_list.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for DrbsToQosFlowsMappingItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsToQosFlowsMappingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsToQosFlowsMappingItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsToQosFlowsMappingItem");
			e
		})
	}
}
// Dynamic5qiDescriptor
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Dynamic5qiDescriptor {
	pub priority_level_qos: PriorityLevelQos,
	pub packet_delay_budget: PacketDelayBudget,
	pub packet_error_rate: PacketErrorRate,
	pub five_qi: Option<FiveQi>,
	pub delay_critical: Option<DelayCritical>,
	pub averaging_window: Option<AveragingWindow>,
	pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
	pub extended_packet_delay_budget: Option<ExtendedPacketDelayBudget>,
	pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
	pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl Dynamic5qiDescriptor {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let priority_level_qos = PriorityLevelQos::decode(data)?;
		let packet_delay_budget = PacketDelayBudget::decode(data)?;
		let packet_error_rate = PacketErrorRate::decode(data)?;
		let five_qi = if optionals[0] {
			Some(FiveQi::decode(data)?)
		} else {
			None
		};
		let delay_critical = if optionals[1] {
			Some(DelayCritical::decode(data)?)
		} else {
			None
		};
		let averaging_window = if optionals[2] {
			Some(AveragingWindow::decode(data)?)
		} else {
			None
		};
		let maximum_data_burst_volume = if optionals[3] {
			Some(MaximumDataBurstVolume::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut extended_packet_delay_budget: Option<ExtendedPacketDelayBudget> = None;
		let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
		let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					189 => {
						extended_packet_delay_budget =
							Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					187 => {
						cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					188 => {
						cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			priority_level_qos,
			packet_delay_budget,
			packet_error_rate,
			five_qi,
			delay_critical,
			averaging_window,
			maximum_data_burst_volume,
			extended_packet_delay_budget,
			cn_packet_delay_budget_dl,
			cn_packet_delay_budget_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.extended_packet_delay_budget {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 189, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_packet_delay_budget_dl {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_packet_delay_budget_ul {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.five_qi.is_some());
		optionals.push(self.delay_critical.is_some());
		optionals.push(self.averaging_window.is_some());
		optionals.push(self.maximum_data_burst_volume.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.priority_level_qos.encode(data)?;
		self.packet_delay_budget.encode(data)?;
		self.packet_error_rate.encode(data)?;
		if let Some(x) = &self.five_qi {
			x.encode(data)?;
		}
		if let Some(x) = &self.delay_critical {
			x.encode(data)?;
		}
		if let Some(x) = &self.averaging_window {
			x.encode(data)?;
		}
		if let Some(x) = &self.maximum_data_burst_volume {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for Dynamic5qiDescriptor {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Dynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Dynamic5qiDescriptor");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Dynamic5qiDescriptor");
			e
		})
	}
}
// EarlyMeasurement
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EarlyMeasurement {
	#[default]
	True,
}

impl EarlyMeasurement {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for EarlyMeasurement {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EarlyMeasurement::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EarlyMeasurement");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EarlyMeasurement");
			e
		})
	}
}
// EarlyStatusTransferTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EarlyStatusTransferTransparentContainer {
	pub procedure_stage: ProcedureStageChoice,
}

impl EarlyStatusTransferTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let procedure_stage = ProcedureStageChoice::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { procedure_stage })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.procedure_stage.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EarlyStatusTransferTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EarlyStatusTransferTransparentContainer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("EarlyStatusTransferTransparentContainer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EarlyStatusTransferTransparentContainer");
			e
		})
	}
}
// ProcedureStageChoice
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum ProcedureStageChoice {
	#[default]
	FirstDlCount(FirstDlCount),
}

impl ProcedureStageChoice {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::FirstDlCount(FirstDlCount::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::FirstDlCount(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for ProcedureStageChoice {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ProcedureStageChoice::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ProcedureStageChoice");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ProcedureStageChoice");
			e
		})
	}
}
// FirstDlCount
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FirstDlCount {
	pub drbs_subject_to_early_status_transfer: DrbsSubjectToEarlyStatusTransferList,
}

impl FirstDlCount {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drbs_subject_to_early_status_transfer =
			DrbsSubjectToEarlyStatusTransferList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drbs_subject_to_early_status_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drbs_subject_to_early_status_transfer.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FirstDlCount {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FirstDlCount::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FirstDlCount");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FirstDlCount");
			e
		})
	}
}
// DrbsSubjectToEarlyStatusTransferList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsSubjectToEarlyStatusTransferList(pub NonEmpty<DrbsSubjectToEarlyStatusTransferItem>);

impl DrbsSubjectToEarlyStatusTransferList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(DrbsSubjectToEarlyStatusTransferItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for DrbsSubjectToEarlyStatusTransferList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsSubjectToEarlyStatusTransferList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToEarlyStatusTransferList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToEarlyStatusTransferList");
			e
		})
	}
}
// DrbsSubjectToEarlyStatusTransferItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct DrbsSubjectToEarlyStatusTransferItem {
	pub drb_id: DrbId,
	pub first_dl_count: DrbStatusDl,
}

impl DrbsSubjectToEarlyStatusTransferItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drb_id = DrbId::decode(data)?;
		let first_dl_count = DrbStatusDl::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drb_id,
			first_dl_count,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drb_id.encode(data)?;
		self.first_dl_count.encode(data)?;

		Ok(())
	}
}

impl PerCodec for DrbsSubjectToEarlyStatusTransferItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DrbsSubjectToEarlyStatusTransferItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToEarlyStatusTransferItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DrbsSubjectToEarlyStatusTransferItem");
			e
		})
	}
}
// EdtSession
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EdtSession {
	#[default]
	True,
}

impl EdtSession {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for EdtSession {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EdtSession::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EdtSession");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EdtSession");
			e
		})
	}
}
// EmergencyAreaId
#[derive(Clone, Debug)]
pub struct EmergencyAreaId(pub [u8; 3]);
impl Default for EmergencyAreaId {
	fn default() -> EmergencyAreaId {
		let init = std::mem::MaybeUninit::<[u8; 3]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		EmergencyAreaId(default_value)
	}
}
impl EmergencyAreaId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(3), Some(3), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
	}
}

impl PerCodec for EmergencyAreaId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaId");
			e
		})
	}
}
// EmergencyAreaIdBroadcastEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdBroadcastEutra(pub NonEmpty<EmergencyAreaIdBroadcastEutraItem>);

impl EmergencyAreaIdBroadcastEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaIdBroadcastEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdBroadcastEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastEutra");
			e
		})
	}
}
// EmergencyAreaIdBroadcastEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdBroadcastEutraItem {
	pub emergency_area_id: EmergencyAreaId,
	pub completed_cells_in_eai_eutra: CompletedCellsInEaiEutra,
}

impl EmergencyAreaIdBroadcastEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let emergency_area_id = EmergencyAreaId::decode(data)?;
		let completed_cells_in_eai_eutra = CompletedCellsInEaiEutra::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			emergency_area_id,
			completed_cells_in_eai_eutra,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.emergency_area_id.encode(data)?;
		self.completed_cells_in_eai_eutra.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdBroadcastEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastEutraItem");
			e
		})
	}
}
// EmergencyAreaIdBroadcastNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdBroadcastNr(pub NonEmpty<EmergencyAreaIdBroadcastNrItem>);

impl EmergencyAreaIdBroadcastNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaIdBroadcastNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdBroadcastNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastNr");
			e
		})
	}
}
// EmergencyAreaIdBroadcastNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdBroadcastNrItem {
	pub emergency_area_id: EmergencyAreaId,
	pub completed_cells_in_eai_nr: CompletedCellsInEaiNr,
}

impl EmergencyAreaIdBroadcastNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let emergency_area_id = EmergencyAreaId::decode(data)?;
		let completed_cells_in_eai_nr = CompletedCellsInEaiNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			emergency_area_id,
			completed_cells_in_eai_nr,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.emergency_area_id.encode(data)?;
		self.completed_cells_in_eai_nr.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdBroadcastNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdBroadcastNrItem");
			e
		})
	}
}
// EmergencyAreaIdCancelledEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdCancelledEutra(pub NonEmpty<EmergencyAreaIdCancelledEutraItem>);

impl EmergencyAreaIdCancelledEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaIdCancelledEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdCancelledEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledEutra");
			e
		})
	}
}
// EmergencyAreaIdCancelledEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdCancelledEutraItem {
	pub emergency_area_id: EmergencyAreaId,
	pub cancelled_cells_in_eai_eutra: CancelledCellsInEaiEutra,
}

impl EmergencyAreaIdCancelledEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let emergency_area_id = EmergencyAreaId::decode(data)?;
		let cancelled_cells_in_eai_eutra = CancelledCellsInEaiEutra::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			emergency_area_id,
			cancelled_cells_in_eai_eutra,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.emergency_area_id.encode(data)?;
		self.cancelled_cells_in_eai_eutra.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdCancelledEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledEutraItem");
			e
		})
	}
}
// EmergencyAreaIdCancelledNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdCancelledNr(pub NonEmpty<EmergencyAreaIdCancelledNrItem>);

impl EmergencyAreaIdCancelledNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaIdCancelledNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdCancelledNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledNr");
			e
		})
	}
}
// EmergencyAreaIdCancelledNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdCancelledNrItem {
	pub emergency_area_id: EmergencyAreaId,
	pub cancelled_cells_in_eai_nr: CancelledCellsInEaiNr,
}

impl EmergencyAreaIdCancelledNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let emergency_area_id = EmergencyAreaId::decode(data)?;
		let cancelled_cells_in_eai_nr = CancelledCellsInEaiNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			emergency_area_id,
			cancelled_cells_in_eai_nr,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.emergency_area_id.encode(data)?;
		self.cancelled_cells_in_eai_nr.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdCancelledNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdCancelledNrItem");
			e
		})
	}
}
// EmergencyAreaIdList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdList(pub NonEmpty<EmergencyAreaId>);

impl EmergencyAreaIdList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaId::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdList");
			e
		})
	}
}
// EmergencyAreaIdListForRestart
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyAreaIdListForRestart(pub NonEmpty<EmergencyAreaId>);

impl EmergencyAreaIdListForRestart {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EmergencyAreaId::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EmergencyAreaIdListForRestart {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyAreaIdListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdListForRestart");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyAreaIdListForRestart");
			e
		})
	}
}
// EmergencyFallbackIndicator
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EmergencyFallbackIndicator {
	pub emergency_fallback_request_indicator: EmergencyFallbackRequestIndicator,
	pub emergency_service_target_cn: Option<EmergencyServiceTargetCn>,
}

impl EmergencyFallbackIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let emergency_fallback_request_indicator = EmergencyFallbackRequestIndicator::decode(data)?;
		let emergency_service_target_cn = if optionals[0] {
			Some(EmergencyServiceTargetCn::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			emergency_fallback_request_indicator,
			emergency_service_target_cn,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.emergency_service_target_cn.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.emergency_fallback_request_indicator.encode(data)?;
		if let Some(x) = &self.emergency_service_target_cn {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for EmergencyFallbackIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyFallbackIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyFallbackIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyFallbackIndicator");
			e
		})
	}
}
// EmergencyFallbackRequestIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EmergencyFallbackRequestIndicator {
	#[default]
	EmergencyFallbackRequested,
}

impl EmergencyFallbackRequestIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for EmergencyFallbackRequestIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyFallbackRequestIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyFallbackRequestIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyFallbackRequestIndicator");
			e
		})
	}
}
// EmergencyServiceTargetCn
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EmergencyServiceTargetCn {
	#[default]
	FiveGc,
	Epc,
}

impl EmergencyServiceTargetCn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for EmergencyServiceTargetCn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EmergencyServiceTargetCn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyServiceTargetCn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EmergencyServiceTargetCn");
			e
		})
	}
}
// EnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum EnbId {
	#[default]
	MacroEnbId(BitString),
	HomeEnbId(BitString),
	ShortMacroEnbId(BitString),
	LongMacroEnbId(BitString),
}

impl EnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::MacroEnbId(decode::decode_bitstring(
				data,
				Some(20),
				Some(20),
				false,
			)?)),
			1 => Ok(Self::HomeEnbId(decode::decode_bitstring(
				data,
				Some(28),
				Some(28),
				false,
			)?)),
			2 => Ok(Self::ShortMacroEnbId(decode::decode_bitstring(
				data,
				Some(18),
				Some(18),
				false,
			)?)),
			3 => Ok(Self::LongMacroEnbId(decode::decode_bitstring(
				data,
				Some(21),
				Some(21),
				false,
			)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::MacroEnbId(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)
			}
			Self::HomeEnbId(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				encode::encode_bitstring(data, Some(28), Some(28), false, &x, false)
			}
			Self::ShortMacroEnbId(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				encode::encode_bitstring(data, Some(18), Some(18), false, &x, false)
			}
			Self::LongMacroEnbId(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				encode::encode_bitstring(data, Some(21), Some(21), false, &x, false)
			}
		}
	}
}

impl PerCodec for EnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnbId");
			e
		})
	}
}
// EnhancedCoverageRestriction
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EnhancedCoverageRestriction {
	#[default]
	Restricted,
}

impl EnhancedCoverageRestriction {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for EnhancedCoverageRestriction {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EnhancedCoverageRestriction::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnhancedCoverageRestriction");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnhancedCoverageRestriction");
			e
		})
	}
}
// ExtendedConnectedTime
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExtendedConnectedTime(pub u8);

impl ExtendedConnectedTime {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
	}
}

impl PerCodec for ExtendedConnectedTime {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedConnectedTime::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedConnectedTime");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedConnectedTime");
			e
		})
	}
}
// EnDcsonConfigurationTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EnDcsonConfigurationTransfer(pub Vec<u8>);

impl EnDcsonConfigurationTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for EnDcsonConfigurationTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EnDcsonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnDcsonConfigurationTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EnDcsonConfigurationTransfer");
			e
		})
	}
}
// EndpointIpAddressAndPort
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EndpointIpAddressAndPort {
	pub endpoint_ip_address: TransportLayerAddress,
	pub port_number: PortNumber,
}

impl EndpointIpAddressAndPort {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
		let endpoint_ip_address = TransportLayerAddress::decode(data)?;
		let port_number = PortNumber::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			endpoint_ip_address,
			port_number,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, false, &optionals, false)?;
		self.endpoint_ip_address.encode(data)?;
		self.port_number.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EndpointIpAddressAndPort {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EndpointIpAddressAndPort::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EndpointIpAddressAndPort");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EndpointIpAddressAndPort");
			e
		})
	}
}
// EndIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EndIndication {
	#[default]
	NoFurtherData,
	FurtherDataExists,
}

impl EndIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for EndIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EndIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EndIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EndIndication");
			e
		})
	}
}
// EquivalentPlmns
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EquivalentPlmns(pub NonEmpty<PlmnIdentity>);

impl EquivalentPlmns {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(15), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PlmnIdentity::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(15), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EquivalentPlmns {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EquivalentPlmns::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EquivalentPlmns");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EquivalentPlmns");
			e
		})
	}
}
// EpsTac
#[derive(Clone, Debug)]
pub struct EpsTac(pub [u8; 2]);
impl Default for EpsTac {
	fn default() -> EpsTac {
		let init = std::mem::MaybeUninit::<[u8; 2]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		EpsTac(default_value)
	}
}
impl EpsTac {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(2), Some(2), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
	}
}

impl PerCodec for EpsTac {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EpsTac::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EpsTac");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EpsTac");
			e
		})
	}
}
// EpsTai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EpsTai {
	pub plmn_identity: PlmnIdentity,
	pub eps_tac: EpsTac,
}

impl EpsTai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let eps_tac = EpsTac::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			eps_tac,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.eps_tac.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EpsTai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EpsTai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EpsTai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EpsTai");
			e
		})
	}
}
// ERabId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ERabId(pub u8);

impl ERabId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(15), true, self.0 as i128, false)
	}
}

impl PerCodec for ERabId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ERabId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabId");
			e
		})
	}
}
// ERabInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ERabInformationList(pub NonEmpty<ERabInformationItem>);

impl ERabInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ERabInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ERabInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ERabInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabInformationList");
			e
		})
	}
}
// ERabInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ERabInformationItem {
	pub e_rab_id: ERabId,
	pub dl_forwarding: Option<DlForwarding>,
	pub source_tnl_addr_info: Option<TransportLayerAddress>,
	pub source_node_tnl_addr_info: Option<TransportLayerAddress>,
}

impl ERabInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let e_rab_id = ERabId::decode(data)?;
		let dl_forwarding = if optionals[0] {
			Some(DlForwarding::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut source_tnl_addr_info: Option<TransportLayerAddress> = None;
		let mut source_node_tnl_addr_info: Option<TransportLayerAddress> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					284 => source_tnl_addr_info = Some(TransportLayerAddress::decode(data)?),
					354 => source_node_tnl_addr_info = Some(TransportLayerAddress::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			e_rab_id,
			dl_forwarding,
			source_tnl_addr_info,
			source_node_tnl_addr_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.source_tnl_addr_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 284, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.source_node_tnl_addr_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 354, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_forwarding.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.e_rab_id.encode(data)?;
		if let Some(x) = &self.dl_forwarding {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for ERabInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ERabInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ERabInformationItem");
			e
		})
	}
}
// EutraCellIdentity
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct EutraCellIdentity(pub BitString);

impl EutraCellIdentity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(28),
			Some(28),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(28), Some(28), false, &self.0, false)
	}
}

impl PerCodec for EutraCellIdentity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCellIdentity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCellIdentity");
			e
		})
	}
}
// EutraCgi
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutraCgi {
	pub plmn_identity: PlmnIdentity,
	pub eutra_cell_identity: EutraCellIdentity,
}

impl EutraCgi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let eutra_cell_identity = EutraCellIdentity::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			eutra_cell_identity,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.eutra_cell_identity.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EutraCgi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgi");
			e
		})
	}
}
// EutraCgiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutraCgiList(pub NonEmpty<EutraCgi>);

impl EutraCgiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EutraCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EutraCgiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraCgiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgiList");
			e
		})
	}
}
// EutraCgiListForWarning
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutraCgiListForWarning(pub NonEmpty<EutraCgi>);

impl EutraCgiListForWarning {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EutraCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EutraCgiListForWarning {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraCgiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgiListForWarning");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraCgiListForWarning");
			e
		})
	}
}
// EutraPagingeDrxInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutraPagingeDrxInformation {
	pub eutra_paging_e_drx_cycle: EutraPagingEDrxCycle,
	pub eutra_paging_time_window: Option<EutraPagingTimeWindow>,
}

impl EutraPagingeDrxInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let eutra_paging_e_drx_cycle = EutraPagingEDrxCycle::decode(data)?;
		let eutra_paging_time_window = if optionals[0] {
			Some(EutraPagingTimeWindow::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_paging_e_drx_cycle,
			eutra_paging_time_window,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.eutra_paging_time_window.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_paging_e_drx_cycle.encode(data)?;
		if let Some(x) = &self.eutra_paging_time_window {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for EutraPagingeDrxInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraPagingeDrxInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingeDrxInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingeDrxInformation");
			e
		})
	}
}
// EutraPagingEDrxCycle
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EutraPagingEDrxCycle {
	#[default]
	Hfhalf,
	Hf1,
	Hf2,
	Hf4,
	Hf6,
	Hf8,
	Hf10,
	Hf12,
	Hf14,
	Hf16,
	Hf32,
	Hf64,
	Hf128,
	Hf256,
}

impl EutraPagingEDrxCycle {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
	}
}

impl PerCodec for EutraPagingEDrxCycle {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraPagingEDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingEDrxCycle");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingEDrxCycle");
			e
		})
	}
}
// EutraPagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EutraPagingTimeWindow {
	#[default]
	S1,
	S2,
	S3,
	S4,
	S5,
	S6,
	S7,
	S8,
	S9,
	S10,
	S11,
	S12,
	S13,
	S14,
	S15,
	S16,
}

impl EutraPagingTimeWindow {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
	}
}

impl PerCodec for EutraPagingTimeWindow {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutraPagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingTimeWindow");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutraPagingTimeWindow");
			e
		})
	}
}
// EutrAencryptionAlgorithms
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct EutrAencryptionAlgorithms(pub BitString);

impl EutrAencryptionAlgorithms {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
	}
}

impl PerCodec for EutrAencryptionAlgorithms {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutrAencryptionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutrAencryptionAlgorithms");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutrAencryptionAlgorithms");
			e
		})
	}
}
// EutrAintegrityProtectionAlgorithms
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct EutrAintegrityProtectionAlgorithms(pub BitString);

impl EutrAintegrityProtectionAlgorithms {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
	}
}

impl PerCodec for EutrAintegrityProtectionAlgorithms {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutrAintegrityProtectionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutrAintegrityProtectionAlgorithms");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutrAintegrityProtectionAlgorithms");
			e
		})
	}
}
// EventType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EventType {
	#[default]
	Direct,
	ChangeOfServeCell,
	UePresenceInAreaOfInterest,
	StopChangeOfServeCell,
	StopUePresenceInAreaOfInterest,
	CancelLocationReportingForTheUe,
}

impl EventType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for EventType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EventType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventType");
			e
		})
	}
}
// ExcessPacketDelayThresholdConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExcessPacketDelayThresholdConfiguration(pub NonEmpty<ExcessPacketDelayThresholdItem>);

impl ExcessPacketDelayThresholdConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(255), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ExcessPacketDelayThresholdItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(255), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ExcessPacketDelayThresholdConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExcessPacketDelayThresholdConfiguration::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("ExcessPacketDelayThresholdConfiguration");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExcessPacketDelayThresholdConfiguration");
			e
		})
	}
}
// ExcessPacketDelayThresholdItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExcessPacketDelayThresholdItem {
	pub five_qi: FiveQi,
	pub excess_packet_delay_threshold_value: ExcessPacketDelayThresholdValue,
}

impl ExcessPacketDelayThresholdItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let five_qi = FiveQi::decode(data)?;
		let excess_packet_delay_threshold_value = ExcessPacketDelayThresholdValue::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_qi,
			excess_packet_delay_threshold_value,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.five_qi.encode(data)?;
		self.excess_packet_delay_threshold_value.encode(data)?;

		Ok(())
	}
}

impl PerCodec for ExcessPacketDelayThresholdItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExcessPacketDelayThresholdItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExcessPacketDelayThresholdItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExcessPacketDelayThresholdItem");
			e
		})
	}
}
// ExcessPacketDelayThresholdValue
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ExcessPacketDelayThresholdValue {
	#[default]
	Ms0dot25,
	Ms0dot5,
	Ms1,
	Ms2,
	Ms4,
	Ms5,
	Ms10,
	Ms20,
	Ms30,
	Ms40,
	Ms50,
	Ms60,
	Ms70,
	Ms80,
	Ms90,
	Ms100,
	Ms150,
	Ms300,
	Ms500,
}

impl ExcessPacketDelayThresholdValue {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(18), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(18), true, *self as i128, false)
	}
}

impl PerCodec for ExcessPacketDelayThresholdValue {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExcessPacketDelayThresholdValue::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExcessPacketDelayThresholdValue");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExcessPacketDelayThresholdValue");
			e
		})
	}
}
// ExpectedActivityPeriod
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExpectedActivityPeriod(pub u8);

impl ExpectedActivityPeriod {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(181), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(181), true, self.0 as i128, false)
	}
}

impl PerCodec for ExpectedActivityPeriod {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedActivityPeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedActivityPeriod");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedActivityPeriod");
			e
		})
	}
}
// ExpectedHoInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ExpectedHoInterval {
	#[default]
	Sec15,
	Sec30,
	Sec60,
	Sec90,
	Sec120,
	Sec180,
	LongTime,
}

impl ExpectedHoInterval {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(6), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(6), true, *self as i128, false)
	}
}

impl PerCodec for ExpectedHoInterval {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedHoInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedHoInterval");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedHoInterval");
			e
		})
	}
}
// ExpectedIdlePeriod
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExpectedIdlePeriod(pub u8);

impl ExpectedIdlePeriod {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(181), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(181), true, self.0 as i128, false)
	}
}

impl PerCodec for ExpectedIdlePeriod {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedIdlePeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedIdlePeriod");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedIdlePeriod");
			e
		})
	}
}
// ExpectedUeActivityBehaviour
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExpectedUeActivityBehaviour {
	pub expected_activity_period: Option<ExpectedActivityPeriod>,
	pub expected_idle_period: Option<ExpectedIdlePeriod>,
	pub source_of_ue_activity_behaviour_information: Option<SourceOfUeActivityBehaviourInformation>,
}

impl ExpectedUeActivityBehaviour {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let expected_activity_period = if optionals[0] {
			Some(ExpectedActivityPeriod::decode(data)?)
		} else {
			None
		};
		let expected_idle_period = if optionals[1] {
			Some(ExpectedIdlePeriod::decode(data)?)
		} else {
			None
		};
		let source_of_ue_activity_behaviour_information = if optionals[2] {
			Some(SourceOfUeActivityBehaviourInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			expected_activity_period,
			expected_idle_period,
			source_of_ue_activity_behaviour_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.expected_activity_period.is_some());
		optionals.push(self.expected_idle_period.is_some());
		optionals.push(self.source_of_ue_activity_behaviour_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.expected_activity_period {
			x.encode(data)?;
		}
		if let Some(x) = &self.expected_idle_period {
			x.encode(data)?;
		}
		if let Some(x) = &self.source_of_ue_activity_behaviour_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ExpectedUeActivityBehaviour {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedUeActivityBehaviour::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeActivityBehaviour");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeActivityBehaviour");
			e
		})
	}
}
// ExpectedUeBehaviour
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExpectedUeBehaviour {
	pub expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
	pub expected_ho_interval: Option<ExpectedHoInterval>,
	pub expected_ue_mobility: Option<ExpectedUeMobility>,
	pub expected_ue_moving_trajectory: Option<ExpectedUeMovingTrajectory>,
}

impl ExpectedUeBehaviour {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let expected_ue_activity_behaviour = if optionals[0] {
			Some(ExpectedUeActivityBehaviour::decode(data)?)
		} else {
			None
		};
		let expected_ho_interval = if optionals[1] {
			Some(ExpectedHoInterval::decode(data)?)
		} else {
			None
		};
		let expected_ue_mobility = if optionals[2] {
			Some(ExpectedUeMobility::decode(data)?)
		} else {
			None
		};
		let expected_ue_moving_trajectory = if optionals[3] {
			Some(ExpectedUeMovingTrajectory::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			expected_ue_activity_behaviour,
			expected_ho_interval,
			expected_ue_mobility,
			expected_ue_moving_trajectory,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.expected_ue_activity_behaviour.is_some());
		optionals.push(self.expected_ho_interval.is_some());
		optionals.push(self.expected_ue_mobility.is_some());
		optionals.push(self.expected_ue_moving_trajectory.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.expected_ue_activity_behaviour {
			x.encode(data)?;
		}
		if let Some(x) = &self.expected_ho_interval {
			x.encode(data)?;
		}
		if let Some(x) = &self.expected_ue_mobility {
			x.encode(data)?;
		}
		if let Some(x) = &self.expected_ue_moving_trajectory {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ExpectedUeBehaviour {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedUeBehaviour::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeBehaviour");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeBehaviour");
			e
		})
	}
}
// ExpectedUeMobility
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ExpectedUeMobility {
	#[default]
	Stationary,
	Mobile,
}

impl ExpectedUeMobility {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for ExpectedUeMobility {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedUeMobility::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMobility");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMobility");
			e
		})
	}
}
// ExpectedUeMovingTrajectory
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExpectedUeMovingTrajectory(pub NonEmpty<ExpectedUeMovingTrajectoryItem>);

impl ExpectedUeMovingTrajectory {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ExpectedUeMovingTrajectoryItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ExpectedUeMovingTrajectory {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedUeMovingTrajectory::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMovingTrajectory");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMovingTrajectory");
			e
		})
	}
}
// ExpectedUeMovingTrajectoryItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExpectedUeMovingTrajectoryItem {
	pub ngran_cgi: NgranCgi,
	pub time_stayed_in_cell: Option<u16>,
}

impl ExpectedUeMovingTrajectoryItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ngran_cgi = NgranCgi::decode(data)?;
		let time_stayed_in_cell = if optionals[0] {
			Some(decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cgi,
			time_stayed_in_cell,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.time_stayed_in_cell.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;
		if let Some(x) = &self.time_stayed_in_cell {
			encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)?;
		}

		Ok(())
	}
}

impl PerCodec for ExpectedUeMovingTrajectoryItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExpectedUeMovingTrajectoryItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMovingTrajectoryItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExpectedUeMovingTrajectoryItem");
			e
		})
	}
}
// ExtendedAmfName
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExtendedAmfName {
	pub amf_name_visible_string: Option<AmfNameVisibleString>,
	pub amf_name_utf8_string: Option<AmfNameUtf8String>,
}

impl ExtendedAmfName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let amf_name_visible_string = if optionals[0] {
			Some(AmfNameVisibleString::decode(data)?)
		} else {
			None
		};
		let amf_name_utf8_string = if optionals[1] {
			Some(AmfNameUtf8String::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_name_visible_string,
			amf_name_utf8_string,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.amf_name_visible_string.is_some());
		optionals.push(self.amf_name_utf8_string.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.amf_name_visible_string {
			x.encode(data)?;
		}
		if let Some(x) = &self.amf_name_utf8_string {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ExtendedAmfName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedAmfName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedAmfName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedAmfName");
			e
		})
	}
}
// ExtendedPacketDelayBudget
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExtendedPacketDelayBudget(pub i128);

impl ExtendedPacketDelayBudget {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(65535), true)?.0,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(65535), true, self.0, false)
	}
}

impl PerCodec for ExtendedPacketDelayBudget {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedPacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedPacketDelayBudget");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedPacketDelayBudget");
			e
		})
	}
}
// ExtendedRanNodeName
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExtendedRanNodeName {
	pub ran_node_name_visible_string: Option<RanNodeNameVisibleString>,
	pub ran_node_name_utf8_string: Option<RanNodeNameUtf8String>,
}

impl ExtendedRanNodeName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let ran_node_name_visible_string = if optionals[0] {
			Some(RanNodeNameVisibleString::decode(data)?)
		} else {
			None
		};
		let ran_node_name_utf8_string = if optionals[1] {
			Some(RanNodeNameUtf8String::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ran_node_name_visible_string,
			ran_node_name_utf8_string,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ran_node_name_visible_string.is_some());
		optionals.push(self.ran_node_name_utf8_string.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.ran_node_name_visible_string {
			x.encode(data)?;
		}
		if let Some(x) = &self.ran_node_name_utf8_string {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ExtendedRanNodeName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedRanNodeName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRanNodeName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRanNodeName");
			e
		})
	}
}
// ExtendedRatRestrictionInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExtendedRatRestrictionInformation {
	pub primary_rat_restriction: BitString,
	pub secondary_rat_restriction: BitString,
}

impl ExtendedRatRestrictionInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let primary_rat_restriction = decode::decode_bitstring(data, Some(8), Some(8), true)?;
		let secondary_rat_restriction = decode::decode_bitstring(data, Some(8), Some(8), true)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			primary_rat_restriction,
			secondary_rat_restriction,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_bitstring(
			data,
			Some(8),
			Some(8),
			true,
			&self.primary_rat_restriction,
			false,
		)?;
		encode::encode_bitstring(
			data,
			Some(8),
			Some(8),
			true,
			&self.secondary_rat_restriction,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for ExtendedRatRestrictionInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedRatRestrictionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRatRestrictionInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRatRestrictionInformation");
			e
		})
	}
}
// ExtendedRncId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExtendedRncId(pub u16);

impl ExtendedRncId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(4096), Some(65535), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(4096), Some(65535), false, self.0 as i128, false)
	}
}

impl PerCodec for ExtendedRncId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedRncId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRncId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedRncId");
			e
		})
	}
}
// ExtendedSliceSupportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ExtendedSliceSupportList(pub NonEmpty<SliceSupportItem>);

impl ExtendedSliceSupportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SliceSupportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ExtendedSliceSupportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedSliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedSliceSupportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedSliceSupportList");
			e
		})
	}
}
// ExtendedUeIdentityIndexValue
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExtendedUeIdentityIndexValue(pub BitString);

impl ExtendedUeIdentityIndexValue {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for ExtendedUeIdentityIndexValue {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedUeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedUeIdentityIndexValue");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedUeIdentityIndexValue");
			e
		})
	}
}
// EventTrigger
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum EventTrigger {
	#[default]
	OutOfCoverage(OutOfCoverage),
	EventL1LoggedMdtConfig(EventL1LoggedMdtConfig),
}

impl EventTrigger {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::OutOfCoverage(OutOfCoverage::decode(data)?)),
			1 => Ok(Self::EventL1LoggedMdtConfig(
				EventL1LoggedMdtConfig::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::OutOfCoverage(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::EventL1LoggedMdtConfig(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for EventTrigger {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EventTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventTrigger");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventTrigger");
			e
		})
	}
}
// EventL1LoggedMdtConfig
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EventL1LoggedMdtConfig {
	pub l1_threshold: MeasurementThresholdL1LoggedMdt,
	pub hysteresis: Hysteresis,
	pub time_to_trigger: TimeToTrigger,
}

impl EventL1LoggedMdtConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let l1_threshold = MeasurementThresholdL1LoggedMdt::decode(data)?;
		let hysteresis = Hysteresis::decode(data)?;
		let time_to_trigger = TimeToTrigger::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			l1_threshold,
			hysteresis,
			time_to_trigger,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.l1_threshold.encode(data)?;
		self.hysteresis.encode(data)?;
		self.time_to_trigger.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EventL1LoggedMdtConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EventL1LoggedMdtConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventL1LoggedMdtConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventL1LoggedMdtConfig");
			e
		})
	}
}
// MeasurementThresholdL1LoggedMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MeasurementThresholdL1LoggedMdt {
	#[default]
	ThresholdRsrp(ThresholdRsrp),
	ThresholdRsrq(ThresholdRsrq),
}

impl MeasurementThresholdL1LoggedMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::ThresholdRsrp(ThresholdRsrp::decode(data)?)),
			1 => Ok(Self::ThresholdRsrq(ThresholdRsrq::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::ThresholdRsrp(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::ThresholdRsrq(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MeasurementThresholdL1LoggedMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MeasurementThresholdL1LoggedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MeasurementThresholdL1LoggedMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MeasurementThresholdL1LoggedMdt");
			e
		})
	}
}
// FailureIndication
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FailureIndication {
	pub ue_rlf_report_container: UeRlfReportContainer,
}

impl FailureIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_rlf_report_container = UeRlfReportContainer::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_rlf_report_container,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_rlf_report_container.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FailureIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FailureIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FailureIndication");
			e
		})
	}
}
// FiveGProSeAuthorized
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGProSeAuthorized {
	pub five_g_pro_se_direct_discovery: Option<FiveGProSeDirectDiscovery>,
	pub five_g_pro_se_direct_communication: Option<FiveGProSeDirectCommunication>,
	pub five_g_pro_se_layer_2_ue_to_network_relay: Option<FiveGProSeLayer2UeToNetworkRelay>,
	pub five_g_pro_se_layer_3_ue_to_network_relay: Option<FiveGProSeLayer3UeToNetworkRelay>,
	pub five_g_pro_se_layer_2_remote_ue: Option<FiveGProSeLayer2RemoteUe>,
}

impl FiveGProSeAuthorized {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
		let five_g_pro_se_direct_discovery = if optionals[0] {
			Some(FiveGProSeDirectDiscovery::decode(data)?)
		} else {
			None
		};
		let five_g_pro_se_direct_communication = if optionals[1] {
			Some(FiveGProSeDirectCommunication::decode(data)?)
		} else {
			None
		};
		let five_g_pro_se_layer_2_ue_to_network_relay = if optionals[2] {
			Some(FiveGProSeLayer2UeToNetworkRelay::decode(data)?)
		} else {
			None
		};
		let five_g_pro_se_layer_3_ue_to_network_relay = if optionals[3] {
			Some(FiveGProSeLayer3UeToNetworkRelay::decode(data)?)
		} else {
			None
		};
		let five_g_pro_se_layer_2_remote_ue = if optionals[4] {
			Some(FiveGProSeLayer2RemoteUe::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[5] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_g_pro_se_direct_discovery,
			five_g_pro_se_direct_communication,
			five_g_pro_se_layer_2_ue_to_network_relay,
			five_g_pro_se_layer_3_ue_to_network_relay,
			five_g_pro_se_layer_2_remote_ue,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.five_g_pro_se_direct_discovery.is_some());
		optionals.push(self.five_g_pro_se_direct_communication.is_some());
		optionals.push(self.five_g_pro_se_layer_2_ue_to_network_relay.is_some());
		optionals.push(self.five_g_pro_se_layer_3_ue_to_network_relay.is_some());
		optionals.push(self.five_g_pro_se_layer_2_remote_ue.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.five_g_pro_se_direct_discovery {
			x.encode(data)?;
		}
		if let Some(x) = &self.five_g_pro_se_direct_communication {
			x.encode(data)?;
		}
		if let Some(x) = &self.five_g_pro_se_layer_2_ue_to_network_relay {
			x.encode(data)?;
		}
		if let Some(x) = &self.five_g_pro_se_layer_3_ue_to_network_relay {
			x.encode(data)?;
		}
		if let Some(x) = &self.five_g_pro_se_layer_2_remote_ue {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for FiveGProSeAuthorized {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeAuthorized");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeAuthorized");
			e
		})
	}
}
// FiveGProSeDirectDiscovery
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum FiveGProSeDirectDiscovery {
	#[default]
	Authorized,
	NotAuthorized,
}

impl FiveGProSeDirectDiscovery {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for FiveGProSeDirectDiscovery {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeDirectDiscovery::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeDirectDiscovery");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeDirectDiscovery");
			e
		})
	}
}
// FiveGProSeDirectCommunication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum FiveGProSeDirectCommunication {
	#[default]
	Authorized,
	NotAuthorized,
}

impl FiveGProSeDirectCommunication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for FiveGProSeDirectCommunication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeDirectCommunication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeDirectCommunication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeDirectCommunication");
			e
		})
	}
}
// FiveGProSeLayer2UeToNetworkRelay
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum FiveGProSeLayer2UeToNetworkRelay {
	#[default]
	Authorized,
	NotAuthorized,
}

impl FiveGProSeLayer2UeToNetworkRelay {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for FiveGProSeLayer2UeToNetworkRelay {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeLayer2UeToNetworkRelay::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer2UeToNetworkRelay");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer2UeToNetworkRelay");
			e
		})
	}
}
// FiveGProSeLayer3UeToNetworkRelay
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum FiveGProSeLayer3UeToNetworkRelay {
	#[default]
	Authorized,
	NotAuthorized,
}

impl FiveGProSeLayer3UeToNetworkRelay {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for FiveGProSeLayer3UeToNetworkRelay {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeLayer3UeToNetworkRelay::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer3UeToNetworkRelay");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer3UeToNetworkRelay");
			e
		})
	}
}
// FiveGProSeLayer2RemoteUe
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum FiveGProSeLayer2RemoteUe {
	#[default]
	Authorized,
	NotAuthorized,
}

impl FiveGProSeLayer2RemoteUe {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for FiveGProSeLayer2RemoteUe {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSeLayer2RemoteUe::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer2RemoteUe");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSeLayer2RemoteUe");
			e
		})
	}
}
// FiveGProSePc5QosParameters
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGProSePc5QosParameters {
	pub five_g_pro_sepc_5_qos_flow_list: FiveGProSePc5QosFlowList,
	pub five_g_pro_sepc_5_link_aggregate_bit_rates: Option<BitRate>,
}

impl FiveGProSePc5QosParameters {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let five_g_pro_sepc_5_qos_flow_list = FiveGProSePc5QosFlowList::decode(data)?;
		let five_g_pro_sepc_5_link_aggregate_bit_rates = if optionals[0] {
			Some(BitRate::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_g_pro_sepc_5_qos_flow_list,
			five_g_pro_sepc_5_link_aggregate_bit_rates,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.five_g_pro_sepc_5_link_aggregate_bit_rates.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.five_g_pro_sepc_5_qos_flow_list.encode(data)?;
		if let Some(x) = &self.five_g_pro_sepc_5_link_aggregate_bit_rates {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for FiveGProSePc5QosParameters {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSePc5QosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosParameters");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosParameters");
			e
		})
	}
}
// FiveGProSePc5QosFlowList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGProSePc5QosFlowList(pub NonEmpty<FiveGProSePc5QosFlowItem>);

impl FiveGProSePc5QosFlowList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(FiveGProSePc5QosFlowItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for FiveGProSePc5QosFlowList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSePc5QosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosFlowList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosFlowList");
			e
		})
	}
}
// FiveGProSePc5QosFlowItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGProSePc5QosFlowItem {
	pub five_gpro_sep_qi: FiveQi,
	pub five_gpro_sepc_5_flow_bit_rates: Option<FiveGProSePc5FlowBitRates>,
	pub five_gpro_serange: Option<Range>,
}

impl FiveGProSePc5QosFlowItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let five_gpro_sep_qi = FiveQi::decode(data)?;
		let five_gpro_sepc_5_flow_bit_rates = if optionals[0] {
			Some(FiveGProSePc5FlowBitRates::decode(data)?)
		} else {
			None
		};
		let five_gpro_serange = if optionals[1] {
			Some(Range::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_gpro_sep_qi,
			five_gpro_sepc_5_flow_bit_rates,
			five_gpro_serange,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.five_gpro_sepc_5_flow_bit_rates.is_some());
		optionals.push(self.five_gpro_serange.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.five_gpro_sep_qi.encode(data)?;
		if let Some(x) = &self.five_gpro_sepc_5_flow_bit_rates {
			x.encode(data)?;
		}
		if let Some(x) = &self.five_gpro_serange {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for FiveGProSePc5QosFlowItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSePc5QosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosFlowItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5QosFlowItem");
			e
		})
	}
}
// FiveGProSePc5FlowBitRates
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGProSePc5FlowBitRates {
	pub five_gpro_seguaranteed_flow_bit_rate: BitRate,
	pub five_gpro_semaximum_flow_bit_rate: BitRate,
}

impl FiveGProSePc5FlowBitRates {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let five_gpro_seguaranteed_flow_bit_rate = BitRate::decode(data)?;
		let five_gpro_semaximum_flow_bit_rate = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_gpro_seguaranteed_flow_bit_rate,
			five_gpro_semaximum_flow_bit_rate,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.five_gpro_seguaranteed_flow_bit_rate.encode(data)?;
		self.five_gpro_semaximum_flow_bit_rate.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FiveGProSePc5FlowBitRates {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGProSePc5FlowBitRates::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5FlowBitRates");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGProSePc5FlowBitRates");
			e
		})
	}
}
// FiveGSTmsi
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FiveGSTmsi {
	pub amf_set_id: AmfSetId,
	pub amf_pointer: AmfPointer,
	pub five_g_tmsi: FiveGTmsi,
}

impl FiveGSTmsi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let amf_set_id = AmfSetId::decode(data)?;
		let amf_pointer = AmfPointer::decode(data)?;
		let five_g_tmsi = FiveGTmsi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_set_id,
			amf_pointer,
			five_g_tmsi,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_set_id.encode(data)?;
		self.amf_pointer.encode(data)?;
		self.five_g_tmsi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FiveGSTmsi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGSTmsi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGSTmsi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGSTmsi");
			e
		})
	}
}
// FiveGTmsi
#[derive(Clone, Debug)]
pub struct FiveGTmsi(pub [u8; 4]);
impl Default for FiveGTmsi {
	fn default() -> FiveGTmsi {
		let init = std::mem::MaybeUninit::<[u8; 4]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		FiveGTmsi(default_value)
	}
}
impl FiveGTmsi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(4), Some(4), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
	}
}

impl PerCodec for FiveGTmsi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveGTmsi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGTmsi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveGTmsi");
			e
		})
	}
}
// FiveQi
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct FiveQi(pub u8);

impl FiveQi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
	}
}

impl PerCodec for FiveQi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FiveQi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveQi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FiveQi");
			e
		})
	}
}
// ForbiddenAreaInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ForbiddenAreaInformation(pub NonEmpty<ForbiddenAreaInformationItem>);

impl ForbiddenAreaInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ForbiddenAreaInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ForbiddenAreaInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ForbiddenAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenAreaInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenAreaInformation");
			e
		})
	}
}
// ForbiddenAreaInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ForbiddenAreaInformationItem {
	pub plmn_identity: PlmnIdentity,
	pub forbidden_ta_cs: ForbiddenTaCs,
}

impl ForbiddenAreaInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let forbidden_ta_cs = ForbiddenTaCs::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			forbidden_ta_cs,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.forbidden_ta_cs.encode(data)?;

		Ok(())
	}
}

impl PerCodec for ForbiddenAreaInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ForbiddenAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenAreaInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenAreaInformationItem");
			e
		})
	}
}
// ForbiddenTaCs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ForbiddenTaCs(pub NonEmpty<Tac>);

impl ForbiddenTaCs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(4096), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(4096), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ForbiddenTaCs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ForbiddenTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenTaCs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ForbiddenTaCs");
			e
		})
	}
}
// FromEutranToNgran
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FromEutranToNgran {
	pub source_enb_id: IntersystemSonEnbId,
	pub target_ngran_node_id: IntersystemSonNgranNodeId,
}

impl FromEutranToNgran {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
		let source_enb_id = IntersystemSonEnbId::decode(data)?;
		let target_ngran_node_id = IntersystemSonNgranNodeId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			source_enb_id,
			target_ngran_node_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, false, &optionals, false)?;
		self.source_enb_id.encode(data)?;
		self.target_ngran_node_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FromEutranToNgran {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FromEutranToNgran::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FromEutranToNgran");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FromEutranToNgran");
			e
		})
	}
}
// FromNgranToEutran
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct FromNgranToEutran {
	pub source_ngran_node_id: IntersystemSonNgranNodeId,
	pub target_enb_id: IntersystemSonEnbId,
}

impl FromNgranToEutran {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 1)?;
		let source_ngran_node_id = IntersystemSonNgranNodeId::decode(data)?;
		let target_enb_id = IntersystemSonEnbId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			source_ngran_node_id,
			target_enb_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, false, &optionals, false)?;
		self.source_ngran_node_id.encode(data)?;
		self.target_enb_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for FromNgranToEutran {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		FromNgranToEutran::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FromNgranToEutran");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("FromNgranToEutran");
			e
		})
	}
}
// GbrQosInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GbrQosInformation {
	pub maximum_flow_bit_rate_dl: BitRate,
	pub maximum_flow_bit_rate_ul: BitRate,
	pub guaranteed_flow_bit_rate_dl: BitRate,
	pub guaranteed_flow_bit_rate_ul: BitRate,
	pub notification_control: Option<NotificationControl>,
	pub maximum_packet_loss_rate_dl: Option<PacketLossRate>,
	pub maximum_packet_loss_rate_ul: Option<PacketLossRate>,
	pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
}

impl GbrQosInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let maximum_flow_bit_rate_dl = BitRate::decode(data)?;
		let maximum_flow_bit_rate_ul = BitRate::decode(data)?;
		let guaranteed_flow_bit_rate_dl = BitRate::decode(data)?;
		let guaranteed_flow_bit_rate_ul = BitRate::decode(data)?;
		let notification_control = if optionals[0] {
			Some(NotificationControl::decode(data)?)
		} else {
			None
		};
		let maximum_packet_loss_rate_dl = if optionals[1] {
			Some(PacketLossRate::decode(data)?)
		} else {
			None
		};
		let maximum_packet_loss_rate_ul = if optionals[2] {
			Some(PacketLossRate::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut alternative_qos_para_set_list: Option<AlternativeQosParaSetList> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					220 => {
						alternative_qos_para_set_list =
							Some(AlternativeQosParaSetList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			maximum_flow_bit_rate_dl,
			maximum_flow_bit_rate_ul,
			guaranteed_flow_bit_rate_dl,
			guaranteed_flow_bit_rate_ul,
			notification_control,
			maximum_packet_loss_rate_dl,
			maximum_packet_loss_rate_ul,
			alternative_qos_para_set_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.alternative_qos_para_set_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 220, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.notification_control.is_some());
		optionals.push(self.maximum_packet_loss_rate_dl.is_some());
		optionals.push(self.maximum_packet_loss_rate_ul.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.maximum_flow_bit_rate_dl.encode(data)?;
		self.maximum_flow_bit_rate_ul.encode(data)?;
		self.guaranteed_flow_bit_rate_dl.encode(data)?;
		self.guaranteed_flow_bit_rate_ul.encode(data)?;
		if let Some(x) = &self.notification_control {
			x.encode(data)?;
		}
		if let Some(x) = &self.maximum_packet_loss_rate_dl {
			x.encode(data)?;
		}
		if let Some(x) = &self.maximum_packet_loss_rate_ul {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for GbrQosInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GbrQosInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GbrQosInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GbrQosInformation");
			e
		})
	}
}
// GlobalCableId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalCableId(pub Vec<u8>);

impl GlobalCableId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for GlobalCableId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalCableId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalCableId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalCableId");
			e
		})
	}
}
// GlobalCableIdNew
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalCableIdNew {
	pub global_cable_id: GlobalCableId,
	pub tai: Tai,
}

impl GlobalCableIdNew {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_cable_id = GlobalCableId::decode(data)?;
		let tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_cable_id,
			tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_cable_id.encode(data)?;
		self.tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalCableIdNew {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalCableIdNew::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalCableIdNew");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalCableIdNew");
			e
		})
	}
}
// GlobalEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalEnbId {
	pub plmn_identity: PlmnIdentity,
	pub enb_id: EnbId,
}

impl GlobalEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let enb_id = EnbId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			enb_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.enb_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalEnbId");
			e
		})
	}
}
// GlobalGnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalGnbId {
	pub plmn_identity: PlmnIdentity,
	pub gnb_id: GnbId,
}

impl GlobalGnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let gnb_id = GnbId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			gnb_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.gnb_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalGnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalGnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalGnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalGnbId");
			e
		})
	}
}
// GlobalN3IwfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalN3IwfId {
	pub plmn_identity: PlmnIdentity,
	pub n3_iwf_id: N3IwfId,
}

impl GlobalN3IwfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let n3_iwf_id = N3IwfId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			n3_iwf_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.n3_iwf_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalN3IwfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalN3IwfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalN3IwfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalN3IwfId");
			e
		})
	}
}
// GlobalLineId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalLineId {
	pub global_line_identity: GlobalLineIdentity,
	pub line_type: Option<LineType>,
	pub tai: Option<Tai>,
}

impl GlobalLineId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let global_line_identity = GlobalLineIdentity::decode(data)?;
		let line_type = if optionals[0] {
			Some(LineType::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut tai: Option<Tai> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					213 => tai = Some(Tai::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_line_identity,
			line_type,
			tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tai {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.line_type.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_line_identity.encode(data)?;
		if let Some(x) = &self.line_type {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for GlobalLineId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalLineId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalLineId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalLineId");
			e
		})
	}
}
// GlobalLineIdentity
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalLineIdentity(pub Vec<u8>);

impl GlobalLineIdentity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for GlobalLineIdentity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalLineIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalLineIdentity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalLineIdentity");
			e
		})
	}
}
// GlobalNgEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalNgEnbId {
	pub plmn_identity: PlmnIdentity,
	pub ng_enb_id: NgEnbId,
}

impl GlobalNgEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let ng_enb_id = NgEnbId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			ng_enb_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.ng_enb_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalNgEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalNgEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalNgEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalNgEnbId");
			e
		})
	}
}
// GlobalRanNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum GlobalRanNodeId {
	#[default]
	GlobalGnbId(GlobalGnbId),
	GlobalNgEnbId(GlobalNgEnbId),
	GlobalN3IwfId(GlobalN3IwfId),
	GlobalTngfId(GlobalTngfId),
	GlobalTwifId(GlobalTwifId),
	GlobalWAgfId(GlobalWAgfId),
}

impl GlobalRanNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::GlobalGnbId(GlobalGnbId::decode(data)?)),
			1 => Ok(Self::GlobalNgEnbId(GlobalNgEnbId::decode(data)?)),
			2 => Ok(Self::GlobalN3IwfId(GlobalN3IwfId::decode(data)?)),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					240 => Ok(Self::GlobalTngfId(GlobalTngfId::decode(data)?)),
					241 => Ok(Self::GlobalTwifId(GlobalTwifId::decode(data)?)),
					242 => Ok(Self::GlobalWAgfId(GlobalWAgfId::decode(data)?)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::GlobalGnbId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				x.encode(data)
			}
			Self::GlobalNgEnbId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				x.encode(data)
			}
			Self::GlobalN3IwfId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				x.encode(data)
			}
			Self::GlobalTngfId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 240, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::GlobalTwifId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 241, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::GlobalWAgfId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 242, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for GlobalRanNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalRanNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalRanNodeId");
			e
		})
	}
}
// GlobalTngfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalTngfId {
	pub plmn_identity: PlmnIdentity,
	pub tngf_id: TngfId,
}

impl GlobalTngfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let tngf_id = TngfId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			tngf_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.tngf_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalTngfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalTngfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalTngfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalTngfId");
			e
		})
	}
}
// GlobalTwifId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalTwifId {
	pub plmn_identity: PlmnIdentity,
	pub twif_id: TwifId,
}

impl GlobalTwifId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let twif_id = TwifId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			twif_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.twif_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalTwifId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalTwifId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalTwifId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalTwifId");
			e
		})
	}
}
// GlobalWAgfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct GlobalWAgfId {
	pub plmn_identity: PlmnIdentity,
	pub w_agf_id: WAgfId,
}

impl GlobalWAgfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let w_agf_id = WAgfId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			w_agf_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.w_agf_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for GlobalWAgfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GlobalWAgfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalWAgfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GlobalWAgfId");
			e
		})
	}
}
// GnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum GnbId {
	#[default]
	GnbId(BitString),
}

impl GnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::GnbId(decode::decode_bitstring(
				data,
				Some(22),
				Some(32),
				false,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::GnbId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(22), Some(32), false, &x, false)
			}
		}
	}
}

impl PerCodec for GnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GnbId");
			e
		})
	}
}
// Guami
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Guami {
	pub plmn_identity: PlmnIdentity,
	pub amf_region_id: AmfRegionId,
	pub amf_set_id: AmfSetId,
	pub amf_pointer: AmfPointer,
}

impl Guami {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let amf_region_id = AmfRegionId::decode(data)?;
		let amf_set_id = AmfSetId::decode(data)?;
		let amf_pointer = AmfPointer::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			amf_region_id,
			amf_set_id,
			amf_pointer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.amf_region_id.encode(data)?;
		self.amf_set_id.encode(data)?;
		self.amf_pointer.encode(data)?;

		Ok(())
	}
}

impl PerCodec for Guami {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Guami::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Guami");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Guami");
			e
		})
	}
}
// GuamiType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum GuamiType {
	#[default]
	Native,
	Mapped,
}

impl GuamiType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for GuamiType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GuamiType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GuamiType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GuamiType");
			e
		})
	}
}
// HandoverCommandTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HandoverCommandTransfer {
	pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub qos_flow_to_be_forwarded_list: Option<QosFlowToBeForwardedList>,
	pub data_forwarding_response_drb_list: Option<DataForwardingResponseDrbList>,
	pub additional_dl_forwarding_up_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_ul_forwarding_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub data_forwarding_response_erab_list: Option<DataForwardingResponseErabList>,
	pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
}

impl HandoverCommandTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let dl_forwarding_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let qos_flow_to_be_forwarded_list = if optionals[1] {
			Some(QosFlowToBeForwardedList::decode(data)?)
		} else {
			None
		};
		let data_forwarding_response_drb_list = if optionals[2] {
			Some(DataForwardingResponseDrbList::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut additional_dl_forwarding_up_tnl_information: Option<QosFlowPerTnlInformationList> =
			None;
		let mut ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_ul_forwarding_up_tnl_information: Option<
			UpTransportLayerInformationList,
		> = None;
		let mut data_forwarding_response_erab_list: Option<DataForwardingResponseErabList> = None;
		let mut qos_flow_failed_to_setup_list: Option<QosFlowListWithCause> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					152 => {
						additional_dl_forwarding_up_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					164 => {
						ul_forwarding_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					172 => {
						additional_ul_forwarding_up_tnl_information =
							Some(UpTransportLayerInformationList::decode(data)?)
					}
					249 => {
						data_forwarding_response_erab_list =
							Some(DataForwardingResponseErabList::decode(data)?)
					}
					283 => {
						qos_flow_failed_to_setup_list = Some(QosFlowListWithCause::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_forwarding_up_tnl_information,
			qos_flow_to_be_forwarded_list,
			data_forwarding_response_drb_list,
			additional_dl_forwarding_up_tnl_information,
			ul_forwarding_up_tnl_information,
			additional_ul_forwarding_up_tnl_information,
			data_forwarding_response_erab_list,
			qos_flow_failed_to_setup_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_dl_forwarding_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 152, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ul_forwarding_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 164, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_ul_forwarding_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 172, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.data_forwarding_response_erab_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 249, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_flow_failed_to_setup_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 283, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_forwarding_up_tnl_information.is_some());
		optionals.push(self.qos_flow_to_be_forwarded_list.is_some());
		optionals.push(self.data_forwarding_response_drb_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.dl_forwarding_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_to_be_forwarded_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.data_forwarding_response_drb_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for HandoverCommandTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverCommandTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverCommandTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverCommandTransfer");
			e
		})
	}
}
// HandoverFlag
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum HandoverFlag {
	#[default]
	HandoverPreparation,
}

impl HandoverFlag {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for HandoverFlag {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverFlag::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverFlag");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverFlag");
			e
		})
	}
}
// HandoverPreparationUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HandoverPreparationUnsuccessfulTransfer {
	pub cause: Cause,
}

impl HandoverPreparationUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cause })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for HandoverPreparationUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverPreparationUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("HandoverPreparationUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverPreparationUnsuccessfulTransfer");
			e
		})
	}
}
// HandoverRequestAcknowledgeTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HandoverRequestAcknowledgeTransfer {
	pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
	pub dl_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub security_result: Option<SecurityResult>,
	pub qos_flow_setup_response_list: QosFlowListWithDataForwarding,
	pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
	pub data_forwarding_response_drb_list: Option<DataForwardingResponseDrbList>,
	pub additional_dl_up_tnl_information_for_ho_list: Option<AdditionalDlUpTnlInformationForHoList>,
	pub ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_ul_forwarding_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub data_forwarding_response_erab_list: Option<DataForwardingResponseErabList>,
	pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub used_rsn_information: Option<RedundantPduSessionInformation>,
	pub global_ran_node_id: Option<GlobalRanNodeId>,
	pub mbs_support_indicator: Option<MbsSupportIndicator>,
}

impl HandoverRequestAcknowledgeTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let dl_forwarding_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let security_result = if optionals[1] {
			Some(SecurityResult::decode(data)?)
		} else {
			None
		};
		let qos_flow_setup_response_list = QosFlowListWithDataForwarding::decode(data)?;
		let qos_flow_failed_to_setup_list = if optionals[2] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};
		let data_forwarding_response_drb_list = if optionals[3] {
			Some(DataForwardingResponseDrbList::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut additional_dl_up_tnl_information_for_ho_list: Option<
			AdditionalDlUpTnlInformationForHoList,
		> = None;
		let mut ul_forwarding_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_ul_forwarding_up_tnl_information: Option<
			UpTransportLayerInformationList,
		> = None;
		let mut data_forwarding_response_erab_list: Option<DataForwardingResponseErabList> = None;
		let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
		let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
		let mut mbs_support_indicator: Option<MbsSupportIndicator> = None;

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					153 => {
						additional_dl_up_tnl_information_for_ho_list =
							Some(AdditionalDlUpTnlInformationForHoList::decode(data)?)
					}
					164 => {
						ul_forwarding_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					172 => {
						additional_ul_forwarding_up_tnl_information =
							Some(UpTransportLayerInformationList::decode(data)?)
					}
					249 => {
						data_forwarding_response_erab_list =
							Some(DataForwardingResponseErabList::decode(data)?)
					}
					192 => {
						redundant_dl_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					198 => {
						used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
					}
					27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
					309 => mbs_support_indicator = Some(MbsSupportIndicator::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_ngu_up_tnl_information,
			dl_forwarding_up_tnl_information,
			security_result,
			qos_flow_setup_response_list,
			qos_flow_failed_to_setup_list,
			data_forwarding_response_drb_list,
			additional_dl_up_tnl_information_for_ho_list,
			ul_forwarding_up_tnl_information,
			additional_ul_forwarding_up_tnl_information,
			data_forwarding_response_erab_list,
			redundant_dl_ngu_up_tnl_information,
			used_rsn_information,
			global_ran_node_id,
			mbs_support_indicator,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_dl_up_tnl_information_for_ho_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 153, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ul_forwarding_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 164, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_ul_forwarding_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 172, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.data_forwarding_response_erab_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 249, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.used_rsn_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.global_ran_node_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_support_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_forwarding_up_tnl_information.is_some());
		optionals.push(self.security_result.is_some());
		optionals.push(self.qos_flow_failed_to_setup_list.is_some());
		optionals.push(self.data_forwarding_response_drb_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_ngu_up_tnl_information.encode(data)?;
		if let Some(x) = &self.dl_forwarding_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.security_result {
			x.encode(data)?;
		}
		self.qos_flow_setup_response_list.encode(data)?;
		if let Some(x) = &self.qos_flow_failed_to_setup_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.data_forwarding_response_drb_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for HandoverRequestAcknowledgeTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverRequestAcknowledgeTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverRequestAcknowledgeTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverRequestAcknowledgeTransfer");
			e
		})
	}
}
// HandoverRequiredTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HandoverRequiredTransfer {
	pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
}

impl HandoverRequiredTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let direct_forwarding_path_availability = if optionals[0] {
			Some(DirectForwardingPathAvailability::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			direct_forwarding_path_availability,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.direct_forwarding_path_availability.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.direct_forwarding_path_availability {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for HandoverRequiredTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverRequiredTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverRequiredTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverRequiredTransfer");
			e
		})
	}
}
// HandoverResourceAllocationUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HandoverResourceAllocationUnsuccessfulTransfer {
	pub cause: Cause,
	pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl HandoverResourceAllocationUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cause = Cause::decode(data)?;
		let criticality_diagnostics = if optionals[0] {
			Some(CriticalityDiagnostics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cause,
			criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;
		if let Some(x) = &self.criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for HandoverResourceAllocationUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverResourceAllocationUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("HandoverResourceAllocationUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverResourceAllocationUnsuccessfulTransfer");
			e
		})
	}
}
// HandoverType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum HandoverType {
	#[default]
	Intra5gs,
	FivegsToEps,
	EpsTo5gs,
}

impl HandoverType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for HandoverType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverType");
			e
		})
	}
}
// HashedUeIdentityIndexValue
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct HashedUeIdentityIndexValue(pub BitString);

impl HashedUeIdentityIndexValue {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(13),
			Some(13),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(13), Some(13), true, &self.0, false)
	}
}

impl PerCodec for HashedUeIdentityIndexValue {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HashedUeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HashedUeIdentityIndexValue");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HashedUeIdentityIndexValue");
			e
		})
	}
}
// HfcNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HfcNodeId(pub Vec<u8>);

impl HfcNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for HfcNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HfcNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HfcNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HfcNodeId");
			e
		})
	}
}
// HfcNodeIdNew
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HfcNodeIdNew {
	pub hfc_node_id: HfcNodeId,
	pub tai: Tai,
}

impl HfcNodeIdNew {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let hfc_node_id = HfcNodeId::decode(data)?;
		let tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { hfc_node_id, tai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.hfc_node_id.encode(data)?;
		self.tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for HfcNodeIdNew {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HfcNodeIdNew::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HfcNodeIdNew");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HfcNodeIdNew");
			e
		})
	}
}
// HoReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct HoReport {
	pub handover_report_type: HandoverReportType,
	pub handover_cause: Cause,
	pub sourcecell_cgi: NgranCgi,
	pub targetcell_cgi: NgranCgi,
	pub reestablishmentcell_cgi: Option<NgranCgi>,
	pub sourcecell_c_rnti: Option<BitString>,
	pub targetcellin_eutran: Option<EutraCgi>,
	pub mobility_information: Option<MobilityInformation>,
	pub ue_rlf_report_container: Option<UeRlfReportContainer>,
	pub extended_mobility_information: Option<ExtendedMobilityInformation>,
}

impl HoReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
		let handover_report_type = HandoverReportType::decode(data)?;
		let handover_cause = Cause::decode(data)?;
		let sourcecell_cgi = NgranCgi::decode(data)?;
		let targetcell_cgi = NgranCgi::decode(data)?;
		let reestablishmentcell_cgi = if optionals[0] {
			Some(NgranCgi::decode(data)?)
		} else {
			None
		};
		let sourcecell_c_rnti = if optionals[1] {
			Some(decode::decode_bitstring(data, Some(16), Some(16), false)?)
		} else {
			None
		};
		let targetcellin_eutran = if optionals[2] {
			Some(EutraCgi::decode(data)?)
		} else {
			None
		};
		let mobility_information = if optionals[3] {
			Some(MobilityInformation::decode(data)?)
		} else {
			None
		};
		let ue_rlf_report_container = if optionals[4] {
			Some(UeRlfReportContainer::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut extended_mobility_information: Option<ExtendedMobilityInformation> = None;

		if optionals[5] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					366 => {
						extended_mobility_information =
							Some(ExtendedMobilityInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			handover_report_type,
			handover_cause,
			sourcecell_cgi,
			targetcell_cgi,
			reestablishmentcell_cgi,
			sourcecell_c_rnti,
			targetcellin_eutran,
			mobility_information,
			ue_rlf_report_container,
			extended_mobility_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.extended_mobility_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 366, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.reestablishmentcell_cgi.is_some());
		optionals.push(self.sourcecell_c_rnti.is_some());
		optionals.push(self.targetcellin_eutran.is_some());
		optionals.push(self.mobility_information.is_some());
		optionals.push(self.ue_rlf_report_container.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.handover_report_type.encode(data)?;
		self.handover_cause.encode(data)?;
		self.sourcecell_cgi.encode(data)?;
		self.targetcell_cgi.encode(data)?;
		if let Some(x) = &self.reestablishmentcell_cgi {
			x.encode(data)?;
		}
		if let Some(x) = &self.sourcecell_c_rnti {
			encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)?;
		}
		if let Some(x) = &self.targetcellin_eutran {
			x.encode(data)?;
		}
		if let Some(x) = &self.mobility_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.ue_rlf_report_container {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for HoReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HoReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HoReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HoReport");
			e
		})
	}
}
// Hysteresis
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct Hysteresis(pub u8);

impl Hysteresis {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(30), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(30), false, self.0 as i128, false)
	}
}

impl PerCodec for Hysteresis {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Hysteresis::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Hysteresis");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Hysteresis");
			e
		})
	}
}
// IabAuthorized
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IabAuthorized {
	#[default]
	Authorized,
	NotAuthorized,
}

impl IabAuthorized {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for IabAuthorized {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IabAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabAuthorized");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabAuthorized");
			e
		})
	}
}
// IabSupported
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IabSupported {
	#[default]
	True,
}

impl IabSupported {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for IabSupported {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IabSupported::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabSupported");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabSupported");
			e
		})
	}
}
// IabNodeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IabNodeIndication {
	#[default]
	True,
}

impl IabNodeIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for IabNodeIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IabNodeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabNodeIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IabNodeIndication");
			e
		})
	}
}
// ImsVoiceSupportIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ImsVoiceSupportIndicator {
	#[default]
	Supported,
	NotSupported,
}

impl ImsVoiceSupportIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for ImsVoiceSupportIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ImsVoiceSupportIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ImsVoiceSupportIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ImsVoiceSupportIndicator");
			e
		})
	}
}
// IndexToRfsp
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct IndexToRfsp(pub u16);

impl IndexToRfsp {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
	}
}

impl PerCodec for IndexToRfsp {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IndexToRfsp::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IndexToRfsp");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IndexToRfsp");
			e
		})
	}
}
// InfoOnRecommendedCellsAndRanNodesForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct InfoOnRecommendedCellsAndRanNodesForPaging {
	pub recommended_cells_for_paging: RecommendedCellsForPaging,
	pub recommend_ran_nodes_for_paging: RecommendedRanNodesForPaging,
}

impl InfoOnRecommendedCellsAndRanNodesForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let recommended_cells_for_paging = RecommendedCellsForPaging::decode(data)?;
		let recommend_ran_nodes_for_paging = RecommendedRanNodesForPaging::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			recommended_cells_for_paging,
			recommend_ran_nodes_for_paging,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.recommended_cells_for_paging.encode(data)?;
		self.recommend_ran_nodes_for_paging.encode(data)?;

		Ok(())
	}
}

impl PerCodec for InfoOnRecommendedCellsAndRanNodesForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		InfoOnRecommendedCellsAndRanNodesForPaging::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("InfoOnRecommendedCellsAndRanNodesForPaging");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InfoOnRecommendedCellsAndRanNodesForPaging");
			e
		})
	}
}
// IntegrityProtectionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IntegrityProtectionIndication {
	#[default]
	Required,
	Preferred,
	NotNeeded,
}

impl IntegrityProtectionIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for IntegrityProtectionIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntegrityProtectionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntegrityProtectionIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntegrityProtectionIndication");
			e
		})
	}
}
// IntegrityProtectionResult
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IntegrityProtectionResult {
	#[default]
	Performed,
	NotPerformed,
}

impl IntegrityProtectionResult {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for IntegrityProtectionResult {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntegrityProtectionResult::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntegrityProtectionResult");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntegrityProtectionResult");
			e
		})
	}
}
// IntendedNumberOfPagingAttempts
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct IntendedNumberOfPagingAttempts(pub u8);

impl IntendedNumberOfPagingAttempts {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
	}
}

impl PerCodec for IntendedNumberOfPagingAttempts {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntendedNumberOfPagingAttempts::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntendedNumberOfPagingAttempts");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntendedNumberOfPagingAttempts");
			e
		})
	}
}
// InterfacesToTrace
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct InterfacesToTrace(pub BitString);

impl InterfacesToTrace {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for InterfacesToTrace {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		InterfacesToTrace::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterfacesToTrace");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterfacesToTrace");
			e
		})
	}
}
// ImmediateMdtNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ImmediateMdtNr {
	pub measurements_to_activate: MeasurementsToActivate,
	pub m1_configuration: Option<M1Configuration>,
	pub m4_configuration: Option<M4Configuration>,
	pub m5_configuration: Option<M5Configuration>,
	pub m6_configuration: Option<M6Configuration>,
	pub m7_configuration: Option<M7Configuration>,
	pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
	pub wlan_measurement_configuration: Option<WlanMeasurementConfiguration>,
	pub mdt_location_info: Option<MdtLocationInfo>,
	pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
}

impl ImmediateMdtNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 10)?;
		let measurements_to_activate = MeasurementsToActivate::decode(data)?;
		let m1_configuration = if optionals[0] {
			Some(M1Configuration::decode(data)?)
		} else {
			None
		};
		let m4_configuration = if optionals[1] {
			Some(M4Configuration::decode(data)?)
		} else {
			None
		};
		let m5_configuration = if optionals[2] {
			Some(M5Configuration::decode(data)?)
		} else {
			None
		};
		let m6_configuration = if optionals[3] {
			Some(M6Configuration::decode(data)?)
		} else {
			None
		};
		let m7_configuration = if optionals[4] {
			Some(M7Configuration::decode(data)?)
		} else {
			None
		};
		let bluetooth_measurement_configuration = if optionals[5] {
			Some(BluetoothMeasurementConfiguration::decode(data)?)
		} else {
			None
		};
		let wlan_measurement_configuration = if optionals[6] {
			Some(WlanMeasurementConfiguration::decode(data)?)
		} else {
			None
		};
		let mdt_location_info = if optionals[7] {
			Some(MdtLocationInfo::decode(data)?)
		} else {
			None
		};
		let sensor_measurement_configuration = if optionals[8] {
			Some(SensorMeasurementConfiguration::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[9] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			measurements_to_activate,
			m1_configuration,
			m4_configuration,
			m5_configuration,
			m6_configuration,
			m7_configuration,
			bluetooth_measurement_configuration,
			wlan_measurement_configuration,
			mdt_location_info,
			sensor_measurement_configuration,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.m1_configuration.is_some());
		optionals.push(self.m4_configuration.is_some());
		optionals.push(self.m5_configuration.is_some());
		optionals.push(self.m6_configuration.is_some());
		optionals.push(self.m7_configuration.is_some());
		optionals.push(self.bluetooth_measurement_configuration.is_some());
		optionals.push(self.wlan_measurement_configuration.is_some());
		optionals.push(self.mdt_location_info.is_some());
		optionals.push(self.sensor_measurement_configuration.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.measurements_to_activate.encode(data)?;
		if let Some(x) = &self.m1_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.m4_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.m5_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.m6_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.m7_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.bluetooth_measurement_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.wlan_measurement_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.mdt_location_info {
			x.encode(data)?;
		}
		if let Some(x) = &self.sensor_measurement_configuration {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ImmediateMdtNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ImmediateMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ImmediateMdtNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ImmediateMdtNr");
			e
		})
	}
}
// InterSystemFailureIndication
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct InterSystemFailureIndication {
	pub ue_rlf_report_container: Option<UeRlfReportContainer>,
}

impl InterSystemFailureIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ue_rlf_report_container = if optionals[0] {
			Some(UeRlfReportContainer::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_rlf_report_container,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ue_rlf_report_container.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.ue_rlf_report_container {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for InterSystemFailureIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		InterSystemFailureIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemFailureIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemFailureIndication");
			e
		})
	}
}
// IntersystemSonConfigurationTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemSonConfigurationTransfer {
	pub transfer_type: IntersystemSonTransferType,
	pub intersystem_son_information: IntersystemSonInformation,
}

impl IntersystemSonConfigurationTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let transfer_type = IntersystemSonTransferType::decode(data)?;
		let intersystem_son_information = IntersystemSonInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			transfer_type,
			intersystem_son_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.transfer_type.encode(data)?;
		self.intersystem_son_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemSonConfigurationTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonConfigurationTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonConfigurationTransfer");
			e
		})
	}
}
// IntersystemSonTransferType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum IntersystemSonTransferType {
	#[default]
	FromEutranToNgran(FromEutranToNgran),
	FromNgranToEutran(FromNgranToEutran),
}

impl IntersystemSonTransferType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::FromEutranToNgran(FromEutranToNgran::decode(data)?)),
			1 => Ok(Self::FromNgranToEutran(FromNgranToEutran::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::FromEutranToNgran(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::FromNgranToEutran(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for IntersystemSonTransferType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonTransferType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonTransferType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonTransferType");
			e
		})
	}
}
// IntersystemSonEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemSonEnbId {
	pub global_enb_id: GlobalEnbId,
	pub selected_epstai: EpsTai,
}

impl IntersystemSonEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_enb_id = GlobalEnbId::decode(data)?;
		let selected_epstai = EpsTai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_enb_id,
			selected_epstai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_enb_id.encode(data)?;
		self.selected_epstai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemSonEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonEnbId");
			e
		})
	}
}
// IntersystemSonNgranNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemSonNgranNodeId {
	pub global_ran_node_id: GlobalRanNodeId,
	pub selected_tai: Tai,
}

impl IntersystemSonNgranNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;
		let selected_tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_ran_node_id,
			selected_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;
		self.selected_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemSonNgranNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonNgranNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonNgranNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonNgranNodeId");
			e
		})
	}
}
// IntersystemSonInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum IntersystemSonInformation {
	#[default]
	IntersystemSonInformationReport(IntersystemSonInformationReport),
	IntersystemSonInformationRequest(IntersystemSonInformationRequest),
	IntersystemSonInformationReply(IntersystemSonInformationReply),
}

impl IntersystemSonInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::IntersystemSonInformationReport(
				IntersystemSonInformationReport::decode(data)?,
			)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					290 => Ok(Self::IntersystemSonInformationRequest(
						IntersystemSonInformationRequest::decode(data)?,
					)),
					291 => Ok(Self::IntersystemSonInformationReply(
						IntersystemSonInformationReply::decode(data)?,
					)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::IntersystemSonInformationReport(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
			Self::IntersystemSonInformationRequest(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 290, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::IntersystemSonInformationReply(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 1, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 291, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for IntersystemSonInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformation");
			e
		})
	}
}
// IntersystemSonInformationRequest
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum IntersystemSonInformationRequest {
	#[default]
	NgranCellActivation(IntersystemCellActivationRequest),
	ResourceStatus(IntersystemResourceStatusRequest),
}

impl IntersystemSonInformationRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NgranCellActivation(
				IntersystemCellActivationRequest::decode(data)?,
			)),
			1 => Ok(Self::ResourceStatus(
				IntersystemResourceStatusRequest::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NgranCellActivation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::ResourceStatus(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for IntersystemSonInformationRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationRequest");
			e
		})
	}
}
// IntersystemCellActivationRequest
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemCellActivationRequest {
	pub activation_id: u16,
	pub cells_to_activate_list: CellsToActivateList,
}

impl IntersystemCellActivationRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let activation_id = decode::decode_integer(data, Some(0), Some(16384), true)?.0 as u16;
		let cells_to_activate_list = CellsToActivateList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			activation_id,
			cells_to_activate_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(16384),
			true,
			self.activation_id as i128,
			false,
		)?;
		self.cells_to_activate_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemCellActivationRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemCellActivationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellActivationRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellActivationRequest");
			e
		})
	}
}
// CellsToActivateList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CellsToActivateList(pub NonEmpty<NgranCgi>);

impl CellsToActivateList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for CellsToActivateList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CellsToActivateList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellsToActivateList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CellsToActivateList");
			e
		})
	}
}
// IntersystemResourceStatusRequest
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemResourceStatusRequest {
	pub reporting_system: ReportingSystem,
	pub report_characteristics: ReportCharacteristics,
	pub report_type: ReportType,
}

impl IntersystemResourceStatusRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let reporting_system = ReportingSystem::decode(data)?;
		let report_characteristics = ReportCharacteristics::decode(data)?;
		let report_type = ReportType::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			reporting_system,
			report_characteristics,
			report_type,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.reporting_system.encode(data)?;
		self.report_characteristics.encode(data)?;
		self.report_type.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemResourceStatusRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemResourceStatusRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusRequest");
			e
		})
	}
}
// ReportingSystem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum ReportingSystem {
	#[default]
	Eutran(EutranReportingSystemIEs),
	Ngran(NgranReportingSystemIEs),
	NoReporting,
}

impl ReportingSystem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Eutran(EutranReportingSystemIEs::decode(data)?)),
			1 => Ok(Self::Ngran(NgranReportingSystemIEs::decode(data)?)),
			2 => Ok(Self::NoReporting),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Eutran(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				x.encode(data)
			}
			Self::Ngran(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				x.encode(data)
			}
			Self::NoReporting => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				Ok(())
			}
		}
	}
}

impl PerCodec for ReportingSystem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportingSystem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportingSystem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportingSystem");
			e
		})
	}
}
// EutranReportingSystemIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranReportingSystemIEs {
	pub eutran_cell_to_report_list: EutranCellToReportList,
}

impl EutranReportingSystemIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutran_cell_to_report_list = EutranCellToReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutran_cell_to_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutran_cell_to_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EutranReportingSystemIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranReportingSystemIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranReportingSystemIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranReportingSystemIEs");
			e
		})
	}
}
// NgranReportingSystemIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranReportingSystemIEs {
	pub ngran_cell_to_report_list: NgranCellToReportList,
}

impl NgranReportingSystemIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cell_to_report_list = NgranCellToReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cell_to_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cell_to_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NgranReportingSystemIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranReportingSystemIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranReportingSystemIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranReportingSystemIEs");
			e
		})
	}
}
// EutranCellToReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranCellToReportList(pub NonEmpty<EutranCellToReportItem>);

impl EutranCellToReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EutranCellToReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EutranCellToReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranCellToReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellToReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellToReportList");
			e
		})
	}
}
// EutranCellToReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranCellToReportItem {
	pub ecgi: EutraCgi,
}

impl EutranCellToReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ecgi = EutraCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { ecgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ecgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EutranCellToReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranCellToReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellToReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellToReportItem");
			e
		})
	}
}
// NgranCellToReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranCellToReportList(pub NonEmpty<NgranCellToReportItem>);

impl NgranCellToReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranCellToReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NgranCellToReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranCellToReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellToReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellToReportList");
			e
		})
	}
}
// NgranCellToReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranCellToReportItem {
	pub ngran_cgi: NgranCgi,
}

impl NgranCellToReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cgi = NgranCgi::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { ngran_cgi })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NgranCellToReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranCellToReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellToReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellToReportItem");
			e
		})
	}
}
// ReportCharacteristics
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ReportCharacteristics(pub BitString);

impl ReportCharacteristics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(32),
			Some(32),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
	}
}

impl PerCodec for ReportCharacteristics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportCharacteristics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportCharacteristics");
			e
		})
	}
}
// ReportType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum ReportType {
	#[default]
	EventBasedReporting(EventBasedReportingIEs),
	PeriodicReporting(PeriodicReportingIEs),
}

impl ReportType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EventBasedReporting(EventBasedReportingIEs::decode(
				data,
			)?)),
			1 => Ok(Self::PeriodicReporting(PeriodicReportingIEs::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EventBasedReporting(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::PeriodicReporting(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for ReportType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportType");
			e
		})
	}
}
// EventBasedReportingIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EventBasedReportingIEs {
	pub intersystem_resource_threshold_low: IntersystemResourceThreshold,
	pub intersystem_resource_threshold_high: IntersystemResourceThreshold,
	pub number_of_measurement_reporting_levels: NumberOfMeasurementReportingLevels,
}

impl EventBasedReportingIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let intersystem_resource_threshold_low = IntersystemResourceThreshold::decode(data)?;
		let intersystem_resource_threshold_high = IntersystemResourceThreshold::decode(data)?;
		let number_of_measurement_reporting_levels =
			NumberOfMeasurementReportingLevels::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			intersystem_resource_threshold_low,
			intersystem_resource_threshold_high,
			number_of_measurement_reporting_levels,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.intersystem_resource_threshold_low.encode(data)?;
		self.intersystem_resource_threshold_high.encode(data)?;
		self.number_of_measurement_reporting_levels.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EventBasedReportingIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EventBasedReportingIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventBasedReportingIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EventBasedReportingIEs");
			e
		})
	}
}
// IntersystemResourceThreshold
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct IntersystemResourceThreshold(pub u8);

impl IntersystemResourceThreshold {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(100), false, self.0 as i128, false)
	}
}

impl PerCodec for IntersystemResourceThreshold {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemResourceThreshold::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceThreshold");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceThreshold");
			e
		})
	}
}
// NumberOfMeasurementReportingLevels
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NumberOfMeasurementReportingLevels {
	#[default]
	N2,
	N3,
	N4,
	N5,
	N10,
}

impl NumberOfMeasurementReportingLevels {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
	}
}

impl PerCodec for NumberOfMeasurementReportingLevels {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NumberOfMeasurementReportingLevels::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfMeasurementReportingLevels");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfMeasurementReportingLevels");
			e
		})
	}
}
// PeriodicReportingIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PeriodicReportingIEs {
	pub reporting_periodicity: ReportingPeriodicity,
}

impl PeriodicReportingIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let reporting_periodicity = ReportingPeriodicity::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			reporting_periodicity,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.reporting_periodicity.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PeriodicReportingIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PeriodicReportingIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicReportingIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicReportingIEs");
			e
		})
	}
}
// ReportingPeriodicity
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ReportingPeriodicity {
	#[default]
	Stop,
	Single,
	Ms1000,
	Ms2000,
	Ms5000,
	Ms10000,
}

impl ReportingPeriodicity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for ReportingPeriodicity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportingPeriodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportingPeriodicity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportingPeriodicity");
			e
		})
	}
}
// IntersystemSonInformationReply
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum IntersystemSonInformationReply {
	#[default]
	NgranCellActivation(IntersystemCellActivationReply),
	ResourceStatus(IntersystemResourceStatusReply),
}

impl IntersystemSonInformationReply {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NgranCellActivation(
				IntersystemCellActivationReply::decode(data)?,
			)),
			1 => Ok(Self::ResourceStatus(
				IntersystemResourceStatusReply::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NgranCellActivation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::ResourceStatus(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for IntersystemSonInformationReply {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonInformationReply::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationReply");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationReply");
			e
		})
	}
}
// IntersystemCellActivationReply
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemCellActivationReply {
	pub activated_cell_list: ActivatedCellList,
	pub activation_id: u16,
}

impl IntersystemCellActivationReply {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let activated_cell_list = ActivatedCellList::decode(data)?;
		let activation_id = decode::decode_integer(data, Some(0), Some(16384), true)?.0 as u16;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			activated_cell_list,
			activation_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.activated_cell_list.encode(data)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(16384),
			true,
			self.activation_id as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for IntersystemCellActivationReply {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemCellActivationReply::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellActivationReply");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellActivationReply");
			e
		})
	}
}
// ActivatedCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ActivatedCellList(pub NonEmpty<NgranCgi>);

impl ActivatedCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ActivatedCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ActivatedCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ActivatedCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ActivatedCellList");
			e
		})
	}
}
// IntersystemResourceStatusReply
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemResourceStatusReply {
	pub reportingsystem: ReportingSystem,
}

impl IntersystemResourceStatusReply {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let reportingsystem = ReportingSystem::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { reportingsystem })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.reportingsystem.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemResourceStatusReply {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemResourceStatusReply::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusReply");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusReply");
			e
		})
	}
}
// IntersystemSonInformationReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum IntersystemSonInformationReport {
	#[default]
	HoReportInformation(InterSystemHoReport),
	FailureIndicationInformation(InterSystemFailureIndication),
	IntersystemCellStateIndication(IntersystemCellStateIndication),
	IntersystemResourceStatusReport(IntersystemResourceStatusReport),
}

impl IntersystemSonInformationReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::HoReportInformation(InterSystemHoReport::decode(
				data,
			)?)),
			1 => Ok(Self::FailureIndicationInformation(
				InterSystemFailureIndication::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					292 => Ok(Self::IntersystemCellStateIndication(
						IntersystemCellStateIndication::decode(data)?,
					)),
					293 => Ok(Self::IntersystemResourceStatusReport(
						IntersystemResourceStatusReport::decode(data)?,
					)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::HoReportInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::FailureIndicationInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
			Self::IntersystemCellStateIndication(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 292, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::IntersystemResourceStatusReport(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 293, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for IntersystemSonInformationReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemSonInformationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemSonInformationReport");
			e
		})
	}
}
// IntersystemCellStateIndication
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemCellStateIndication {
	pub notification_cell_list: NotificationCellList,
}

impl IntersystemCellStateIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let notification_cell_list = NotificationCellList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			notification_cell_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.notification_cell_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemCellStateIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemCellStateIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellStateIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemCellStateIndication");
			e
		})
	}
}
// NotificationCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NotificationCellList(pub NonEmpty<NotificationCellItem>);

impl NotificationCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NotificationCellItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NotificationCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotificationCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCellList");
			e
		})
	}
}
// NotificationCellItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NotificationCellItem {
	pub ngran_cgi: NgranCgi,
	pub notify_flag: NotifyFlag,
}

impl NotificationCellItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cgi = NgranCgi::decode(data)?;
		let notify_flag = NotifyFlag::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cgi,
			notify_flag,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;
		self.notify_flag.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NotificationCellItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotificationCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCellItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCellItem");
			e
		})
	}
}
// IntersystemResourceStatusReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemResourceStatusReport {
	pub reporting_system: ResourceStatusReportingSystem,
}

impl IntersystemResourceStatusReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let reporting_system = ResourceStatusReportingSystem::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { reporting_system })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.reporting_system.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemResourceStatusReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemResourceStatusReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemResourceStatusReport");
			e
		})
	}
}
// ResourceStatusReportingSystem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum ResourceStatusReportingSystem {
	#[default]
	EutranReportingStatus(EutranReportingStatusIEs),
	NgranReportingStatus(NgranReportingStatusIEs),
}

impl ResourceStatusReportingSystem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EutranReportingStatus(
				EutranReportingStatusIEs::decode(data)?,
			)),
			1 => Ok(Self::NgranReportingStatus(NgranReportingStatusIEs::decode(
				data,
			)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EutranReportingStatus(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::NgranReportingStatus(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for ResourceStatusReportingSystem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ResourceStatusReportingSystem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResourceStatusReportingSystem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResourceStatusReportingSystem");
			e
		})
	}
}
// EutranReportingStatusIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranReportingStatusIEs {
	pub eutran_cell_report_list: EutranCellReportList,
}

impl EutranReportingStatusIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutran_cell_report_list = EutranCellReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutran_cell_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutran_cell_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EutranReportingStatusIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranReportingStatusIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranReportingStatusIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranReportingStatusIEs");
			e
		})
	}
}
// EutranCellReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranCellReportList(pub NonEmpty<EutranCellReportItem>);

impl EutranCellReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(EutranCellReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for EutranCellReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranCellReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellReportList");
			e
		})
	}
}
// EutranCellReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranCellReportItem {
	pub ecgi: EutraCgi,
	pub eutran_composite_available_capacity_group: EutranCompositeAvailableCapacityGroup,
	pub eutran_number_of_active_ues: Option<EutranNumberOfActiveUes>,
	pub eutran_noof_rrc_connections: Option<NgranNoofRrcConnections>,
	pub eutran_radio_resource_status: Option<EutranRadioResourceStatus>,
}

impl EutranCellReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let ecgi = EutraCgi::decode(data)?;
		let eutran_composite_available_capacity_group =
			EutranCompositeAvailableCapacityGroup::decode(data)?;
		let eutran_number_of_active_ues = if optionals[0] {
			Some(EutranNumberOfActiveUes::decode(data)?)
		} else {
			None
		};
		let eutran_noof_rrc_connections = if optionals[1] {
			Some(NgranNoofRrcConnections::decode(data)?)
		} else {
			None
		};
		let eutran_radio_resource_status = if optionals[2] {
			Some(EutranRadioResourceStatus::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ecgi,
			eutran_composite_available_capacity_group,
			eutran_number_of_active_ues,
			eutran_noof_rrc_connections,
			eutran_radio_resource_status,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.eutran_number_of_active_ues.is_some());
		optionals.push(self.eutran_noof_rrc_connections.is_some());
		optionals.push(self.eutran_radio_resource_status.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ecgi.encode(data)?;
		self.eutran_composite_available_capacity_group
			.encode(data)?;
		if let Some(x) = &self.eutran_number_of_active_ues {
			x.encode(data)?;
		}
		if let Some(x) = &self.eutran_noof_rrc_connections {
			x.encode(data)?;
		}
		if let Some(x) = &self.eutran_radio_resource_status {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for EutranCellReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranCellReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCellReportItem");
			e
		})
	}
}
// EutranCompositeAvailableCapacityGroup
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranCompositeAvailableCapacityGroup {
	pub dl_composite_available_capacity: CompositeAvailableCapacity,
	pub ul_composite_available_capacity: CompositeAvailableCapacity,
}

impl EutranCompositeAvailableCapacityGroup {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dl_composite_available_capacity = CompositeAvailableCapacity::decode(data)?;
		let ul_composite_available_capacity = CompositeAvailableCapacity::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_composite_available_capacity,
			ul_composite_available_capacity,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_composite_available_capacity.encode(data)?;
		self.ul_composite_available_capacity.encode(data)?;

		Ok(())
	}
}

impl PerCodec for EutranCompositeAvailableCapacityGroup {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranCompositeAvailableCapacityGroup::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCompositeAvailableCapacityGroup");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranCompositeAvailableCapacityGroup");
			e
		})
	}
}
// CompositeAvailableCapacity
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct CompositeAvailableCapacity {
	pub cell_capacity_class_value: Option<u8>,
	pub capacity_value: u8,
}

impl CompositeAvailableCapacity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cell_capacity_class_value = if optionals[0] {
			Some(decode::decode_integer(data, Some(1), Some(100), true)?.0 as u8)
		} else {
			None
		};
		let capacity_value = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cell_capacity_class_value,
			capacity_value,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.cell_capacity_class_value.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.cell_capacity_class_value {
			encode::encode_integer(data, Some(1), Some(100), true, *x as i128, false)?;
		}
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.capacity_value as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for CompositeAvailableCapacity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CompositeAvailableCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompositeAvailableCapacity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CompositeAvailableCapacity");
			e
		})
	}
}
// EutranNumberOfActiveUes
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct EutranNumberOfActiveUes(pub u32);

impl EutranNumberOfActiveUes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(16777215), true)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(16777215), true, self.0 as i128, false)
	}
}

impl PerCodec for EutranNumberOfActiveUes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranNumberOfActiveUes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranNumberOfActiveUes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranNumberOfActiveUes");
			e
		})
	}
}
// EutranRadioResourceStatus
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct EutranRadioResourceStatus {
	pub dl_gbr_prb_usage: u8,
	pub ul_gbr_prb_usage: u8,
	pub dl_non_gbr_prb_usage: u8,
	pub ul_non_gbr_prb_usage: u8,
	pub dl_total_prb_usage: u8,
	pub ul_total_prb_usage: u8,
	pub dl_scheduling_pdcch_cce_usage: Option<u8>,
	pub ul_scheduling_pdcch_cce_usage: Option<u8>,
}

impl EutranRadioResourceStatus {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let dl_gbr_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_gbr_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let dl_non_gbr_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_non_gbr_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let dl_total_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_total_prb_usage = decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let dl_scheduling_pdcch_cce_usage = if optionals[0] {
			Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
		} else {
			None
		};
		let ul_scheduling_pdcch_cce_usage = if optionals[1] {
			Some(decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_gbr_prb_usage,
			ul_gbr_prb_usage,
			dl_non_gbr_prb_usage,
			ul_non_gbr_prb_usage,
			dl_total_prb_usage,
			ul_total_prb_usage,
			dl_scheduling_pdcch_cce_usage,
			ul_scheduling_pdcch_cce_usage,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.dl_scheduling_pdcch_cce_usage.is_some());
		optionals.push(self.ul_scheduling_pdcch_cce_usage.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_gbr_prb_usage as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_gbr_prb_usage as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_non_gbr_prb_usage as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_non_gbr_prb_usage as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_total_prb_usage as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_total_prb_usage as i128,
			false,
		)?;
		if let Some(x) = &self.dl_scheduling_pdcch_cce_usage {
			encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
		}
		if let Some(x) = &self.ul_scheduling_pdcch_cce_usage {
			encode::encode_integer(data, Some(0), Some(100), false, *x as i128, false)?;
		}

		Ok(())
	}
}

impl PerCodec for EutranRadioResourceStatus {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EutranRadioResourceStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranRadioResourceStatus");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EutranRadioResourceStatus");
			e
		})
	}
}
// NgranReportingStatusIEs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranReportingStatusIEs {
	pub ngran_cell_report_list: NgranCellReportList,
}

impl NgranReportingStatusIEs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_cell_report_list = NgranCellReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cell_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cell_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NgranReportingStatusIEs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranReportingStatusIEs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranReportingStatusIEs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranReportingStatusIEs");
			e
		})
	}
}
// NgranCellReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranCellReportList(pub NonEmpty<NgranCellReportItem>);

impl NgranCellReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranCellReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NgranCellReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranCellReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellReportList");
			e
		})
	}
}
// NgranCellReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranCellReportItem {
	pub ngran_cgi: NgranCgi,
	pub ngran_composite_available_capacity_group: EutranCompositeAvailableCapacityGroup,
	pub ngran_number_of_active_ues: Option<NgranNumberOfActiveUes>,
	pub ngran_noof_rrc_connections: Option<NgranNoofRrcConnections>,
	pub ngran_radio_resource_status: Option<NgranRadioResourceStatus>,
}

impl NgranCellReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let ngran_cgi = NgranCgi::decode(data)?;
		let ngran_composite_available_capacity_group =
			EutranCompositeAvailableCapacityGroup::decode(data)?;
		let ngran_number_of_active_ues = if optionals[0] {
			Some(NgranNumberOfActiveUes::decode(data)?)
		} else {
			None
		};
		let ngran_noof_rrc_connections = if optionals[1] {
			Some(NgranNoofRrcConnections::decode(data)?)
		} else {
			None
		};
		let ngran_radio_resource_status = if optionals[2] {
			Some(NgranRadioResourceStatus::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cgi,
			ngran_composite_available_capacity_group,
			ngran_number_of_active_ues,
			ngran_noof_rrc_connections,
			ngran_radio_resource_status,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ngran_number_of_active_ues.is_some());
		optionals.push(self.ngran_noof_rrc_connections.is_some());
		optionals.push(self.ngran_radio_resource_status.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;
		self.ngran_composite_available_capacity_group.encode(data)?;
		if let Some(x) = &self.ngran_number_of_active_ues {
			x.encode(data)?;
		}
		if let Some(x) = &self.ngran_noof_rrc_connections {
			x.encode(data)?;
		}
		if let Some(x) = &self.ngran_radio_resource_status {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NgranCellReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranCellReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCellReportItem");
			e
		})
	}
}
// NgranNumberOfActiveUes
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NgranNumberOfActiveUes(pub u32);

impl NgranNumberOfActiveUes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(16777215), true)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(16777215), true, self.0 as i128, false)
	}
}

impl PerCodec for NgranNumberOfActiveUes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranNumberOfActiveUes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranNumberOfActiveUes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranNumberOfActiveUes");
			e
		})
	}
}
// NgranNoofRrcConnections
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NgranNoofRrcConnections(pub u32);

impl NgranNoofRrcConnections {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(65536), true)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(65536), true, self.0 as i128, false)
	}
}

impl PerCodec for NgranNoofRrcConnections {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranNoofRrcConnections::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranNoofRrcConnections");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranNoofRrcConnections");
			e
		})
	}
}
// NgranRadioResourceStatus
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranRadioResourceStatus {
	pub dl_gbr_prb_usage_for_mimo: u8,
	pub ul_gbr_prb_usage_for_mimo: u8,
	pub dl_non_gbr_prb_usage_for_mimo: u8,
	pub ul_non_gbr_prb_usage_for_mimo: u8,
	pub dl_total_prb_usage_for_mimo: u8,
	pub ul_total_prb_usage_for_mimo: u8,
}

impl NgranRadioResourceStatus {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let dl_gbr_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_gbr_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let dl_non_gbr_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_non_gbr_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let dl_total_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;
		let ul_total_prb_usage_for_mimo =
			decode::decode_integer(data, Some(0), Some(100), false)?.0 as u8;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_gbr_prb_usage_for_mimo,
			ul_gbr_prb_usage_for_mimo,
			dl_non_gbr_prb_usage_for_mimo,
			ul_non_gbr_prb_usage_for_mimo,
			dl_total_prb_usage_for_mimo,
			ul_total_prb_usage_for_mimo,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_gbr_prb_usage_for_mimo as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_gbr_prb_usage_for_mimo as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_non_gbr_prb_usage_for_mimo as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_non_gbr_prb_usage_for_mimo as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.dl_total_prb_usage_for_mimo as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(100),
			false,
			self.ul_total_prb_usage_for_mimo as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for NgranRadioResourceStatus {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranRadioResourceStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranRadioResourceStatus");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranRadioResourceStatus");
			e
		})
	}
}
// InterSystemHoReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct InterSystemHoReport {
	pub handover_report_type: InterSystemHandoverReportType,
}

impl InterSystemHoReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let handover_report_type = InterSystemHandoverReportType::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			handover_report_type,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.handover_report_type.encode(data)?;

		Ok(())
	}
}

impl PerCodec for InterSystemHoReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		InterSystemHoReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemHoReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemHoReport");
			e
		})
	}
}
// InterSystemHandoverReportType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum InterSystemHandoverReportType {
	#[default]
	TooearlyIntersystemHo(TooearlyIntersystemHo),
	IntersystemUnnecessaryHo(IntersystemUnnecessaryHo),
}

impl InterSystemHandoverReportType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::TooearlyIntersystemHo(TooearlyIntersystemHo::decode(
				data,
			)?)),
			1 => Ok(Self::IntersystemUnnecessaryHo(
				IntersystemUnnecessaryHo::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::TooearlyIntersystemHo(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::IntersystemUnnecessaryHo(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for InterSystemHandoverReportType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		InterSystemHandoverReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemHandoverReportType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("InterSystemHandoverReportType");
			e
		})
	}
}
// IntersystemUnnecessaryHo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct IntersystemUnnecessaryHo {
	pub sourcecell_id: NgranCgi,
	pub targetcell_id: EutraCgi,
	pub early_iratho: EarlyIratho,
	pub candidate_cell_list: CandidateCellList,
}

impl IntersystemUnnecessaryHo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let sourcecell_id = NgranCgi::decode(data)?;
		let targetcell_id = EutraCgi::decode(data)?;
		let early_iratho = EarlyIratho::decode(data)?;
		let candidate_cell_list = CandidateCellList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			sourcecell_id,
			targetcell_id,
			early_iratho,
			candidate_cell_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.sourcecell_id.encode(data)?;
		self.targetcell_id.encode(data)?;
		self.early_iratho.encode(data)?;
		self.candidate_cell_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for IntersystemUnnecessaryHo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IntersystemUnnecessaryHo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemUnnecessaryHo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IntersystemUnnecessaryHo");
			e
		})
	}
}
// Lac
#[derive(Clone, Debug)]
pub struct Lac(pub [u8; 2]);
impl Default for Lac {
	fn default() -> Lac {
		let init = std::mem::MaybeUninit::<[u8; 2]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		Lac(default_value)
	}
}
impl Lac {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(2), Some(2), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
	}
}

impl PerCodec for Lac {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Lac::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Lac");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Lac");
			e
		})
	}
}
// Lai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Lai {
	pub plmn_identity: PlmnIdentity,
	pub lac: Lac,
}

impl Lai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let lac = Lac::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { plmn_identity, lac })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.lac.encode(data)?;

		Ok(())
	}
}

impl PerCodec for Lai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Lai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Lai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Lai");
			e
		})
	}
}
// LastVisitedCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum LastVisitedCellInformation {
	#[default]
	NgranCell(LastVisitedNgranCellInformation),
	EutranCell(LastVisitedEutranCellInformation),
	UtranCell(LastVisitedUtranCellInformation),
	GeranCell(LastVisitedGeranCellInformation),
}

impl LastVisitedCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NgranCell(LastVisitedNgranCellInformation::decode(
				data,
			)?)),
			1 => Ok(Self::EutranCell(LastVisitedEutranCellInformation::decode(
				data,
			)?)),
			2 => Ok(Self::UtranCell(LastVisitedUtranCellInformation::decode(
				data,
			)?)),
			3 => Ok(Self::GeranCell(LastVisitedGeranCellInformation::decode(
				data,
			)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NgranCell(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				x.encode(data)
			}
			Self::EutranCell(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				x.encode(data)
			}
			Self::UtranCell(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				x.encode(data)
			}
			Self::GeranCell(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for LastVisitedCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedCellInformation");
			e
		})
	}
}
// LastVisitedCellItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedCellItem {
	pub last_visited_cell_information: LastVisitedCellInformation,
}

impl LastVisitedCellItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let last_visited_cell_information = LastVisitedCellInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			last_visited_cell_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.last_visited_cell_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for LastVisitedCellItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedCellItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedCellItem");
			e
		})
	}
}
// LastVisitedEutranCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedEutranCellInformation(pub Vec<u8>);

impl LastVisitedEutranCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for LastVisitedEutranCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedEutranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedEutranCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedEutranCellInformation");
			e
		})
	}
}
// LastVisitedGeranCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedGeranCellInformation(pub Vec<u8>);

impl LastVisitedGeranCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for LastVisitedGeranCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedGeranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedGeranCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedGeranCellInformation");
			e
		})
	}
}
// LastVisitedNgranCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedNgranCellInformation {
	pub global_cell_id: NgranCgi,
	pub cell_type: CellType,
	pub time_ue_stayed_in_cell: TimeUeStayedInCell,
	pub time_ue_stayed_in_cell_enhanced_granularity: Option<TimeUeStayedInCellEnhancedGranularity>,
	pub ho_cause_value: Option<Cause>,
	pub last_visited_ps_cell_list: Option<LastVisitedPsCellList>,
}

impl LastVisitedNgranCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let global_cell_id = NgranCgi::decode(data)?;
		let cell_type = CellType::decode(data)?;
		let time_ue_stayed_in_cell = TimeUeStayedInCell::decode(data)?;
		let time_ue_stayed_in_cell_enhanced_granularity = if optionals[0] {
			Some(TimeUeStayedInCellEnhancedGranularity::decode(data)?)
		} else {
			None
		};
		let ho_cause_value = if optionals[1] {
			Some(Cause::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut last_visited_ps_cell_list: Option<LastVisitedPsCellList> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					289 => last_visited_ps_cell_list = Some(LastVisitedPsCellList::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_cell_id,
			cell_type,
			time_ue_stayed_in_cell,
			time_ue_stayed_in_cell_enhanced_granularity,
			ho_cause_value,
			last_visited_ps_cell_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.last_visited_ps_cell_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 289, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.time_ue_stayed_in_cell_enhanced_granularity.is_some());
		optionals.push(self.ho_cause_value.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_cell_id.encode(data)?;
		self.cell_type.encode(data)?;
		self.time_ue_stayed_in_cell.encode(data)?;
		if let Some(x) = &self.time_ue_stayed_in_cell_enhanced_granularity {
			x.encode(data)?;
		}
		if let Some(x) = &self.ho_cause_value {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for LastVisitedNgranCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedNgranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedNgranCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedNgranCellInformation");
			e
		})
	}
}
// LastVisitedPsCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedPsCellList(pub NonEmpty<LastVisitedPsCellInformation>);

impl LastVisitedPsCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(LastVisitedPsCellInformation::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for LastVisitedPsCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedPsCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedPsCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedPsCellList");
			e
		})
	}
}
// LastVisitedPsCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedPsCellInformation {
	pub ps_cell_id: Option<NgranCgi>,
	pub time_stay: u16,
}

impl LastVisitedPsCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ps_cell_id = if optionals[0] {
			Some(NgranCgi::decode(data)?)
		} else {
			None
		};
		let time_stay = decode::decode_integer(data, Some(0), Some(40950), false)?.0 as u16;

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ps_cell_id,
			time_stay,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ps_cell_id.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.ps_cell_id {
			x.encode(data)?;
		}
		encode::encode_integer(
			data,
			Some(0),
			Some(40950),
			false,
			self.time_stay as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for LastVisitedPsCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedPsCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedPsCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedPsCellInformation");
			e
		})
	}
}
// LastVisitedUtranCellInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LastVisitedUtranCellInformation(pub Vec<u8>);

impl LastVisitedUtranCellInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for LastVisitedUtranCellInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LastVisitedUtranCellInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedUtranCellInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LastVisitedUtranCellInformation");
			e
		})
	}
}
// LineType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LineType {
	#[default]
	Dsl,
	Pon,
}

impl LineType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for LineType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LineType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LineType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LineType");
			e
		})
	}
}
// LocationReportingAdditionalInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LocationReportingAdditionalInfo {
	#[default]
	IncludePsCell,
}

impl LocationReportingAdditionalInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for LocationReportingAdditionalInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LocationReportingAdditionalInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingAdditionalInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingAdditionalInfo");
			e
		})
	}
}
// LocationReportingReferenceId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct LocationReportingReferenceId(pub u8);

impl LocationReportingReferenceId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(64), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(64), true, self.0 as i128, false)
	}
}

impl PerCodec for LocationReportingReferenceId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LocationReportingReferenceId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingReferenceId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingReferenceId");
			e
		})
	}
}
// LocationReportingRequestType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LocationReportingRequestType {
	pub event_type: EventType,
	pub report_area: ReportArea,
	pub area_of_interest_list: Option<AreaOfInterestList>,
	pub location_reporting_reference_id_to_be_cancelled: Option<LocationReportingReferenceId>,
	pub location_reporting_additional_info: Option<LocationReportingAdditionalInfo>,
}

impl LocationReportingRequestType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let event_type = EventType::decode(data)?;
		let report_area = ReportArea::decode(data)?;
		let area_of_interest_list = if optionals[0] {
			Some(AreaOfInterestList::decode(data)?)
		} else {
			None
		};
		let location_reporting_reference_id_to_be_cancelled = if optionals[1] {
			Some(LocationReportingReferenceId::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut location_reporting_additional_info: Option<LocationReportingAdditionalInfo> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					170 => {
						location_reporting_additional_info =
							Some(LocationReportingAdditionalInfo::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			event_type,
			report_area,
			area_of_interest_list,
			location_reporting_reference_id_to_be_cancelled,
			location_reporting_additional_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.location_reporting_additional_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 170, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.area_of_interest_list.is_some());
		optionals.push(
			self.location_reporting_reference_id_to_be_cancelled
				.is_some(),
		);
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.event_type.encode(data)?;
		self.report_area.encode(data)?;
		if let Some(x) = &self.area_of_interest_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.location_reporting_reference_id_to_be_cancelled {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for LocationReportingRequestType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LocationReportingRequestType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingRequestType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LocationReportingRequestType");
			e
		})
	}
}
// LoggedMdtNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LoggedMdtNr {
	pub logging_interval: LoggingInterval,
	pub logging_duration: LoggingDuration,
	pub logged_mdt_trigger: LoggedMdtTrigger,
	pub bluetooth_measurement_configuration: Option<BluetoothMeasurementConfiguration>,
	pub wlan_measurement_configuration: Option<WlanMeasurementConfiguration>,
	pub sensor_measurement_configuration: Option<SensorMeasurementConfiguration>,
	pub area_scope_of_neigh_cells_list: Option<AreaScopeOfNeighCellsList>,
	pub early_measurement: Option<EarlyMeasurement>,
}

impl LoggedMdtNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let logging_interval = LoggingInterval::decode(data)?;
		let logging_duration = LoggingDuration::decode(data)?;
		let logged_mdt_trigger = LoggedMdtTrigger::decode(data)?;
		let bluetooth_measurement_configuration = if optionals[0] {
			Some(BluetoothMeasurementConfiguration::decode(data)?)
		} else {
			None
		};
		let wlan_measurement_configuration = if optionals[1] {
			Some(WlanMeasurementConfiguration::decode(data)?)
		} else {
			None
		};
		let sensor_measurement_configuration = if optionals[2] {
			Some(SensorMeasurementConfiguration::decode(data)?)
		} else {
			None
		};
		let area_scope_of_neigh_cells_list = if optionals[3] {
			Some(AreaScopeOfNeighCellsList::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut early_measurement: Option<EarlyMeasurement> = None;

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					360 => early_measurement = Some(EarlyMeasurement::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			logging_interval,
			logging_duration,
			logged_mdt_trigger,
			bluetooth_measurement_configuration,
			wlan_measurement_configuration,
			sensor_measurement_configuration,
			area_scope_of_neigh_cells_list,
			early_measurement,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.early_measurement {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 360, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.bluetooth_measurement_configuration.is_some());
		optionals.push(self.wlan_measurement_configuration.is_some());
		optionals.push(self.sensor_measurement_configuration.is_some());
		optionals.push(self.area_scope_of_neigh_cells_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.logging_interval.encode(data)?;
		self.logging_duration.encode(data)?;
		self.logged_mdt_trigger.encode(data)?;
		if let Some(x) = &self.bluetooth_measurement_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.wlan_measurement_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.sensor_measurement_configuration {
			x.encode(data)?;
		}
		if let Some(x) = &self.area_scope_of_neigh_cells_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for LoggedMdtNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LoggedMdtNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggedMdtNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggedMdtNr");
			e
		})
	}
}
// LoggingInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LoggingInterval {
	#[default]
	Ms320,
	Ms640,
	Ms1280,
	Ms2560,
	Ms5120,
	Ms10240,
	Ms20480,
	Ms30720,
	Ms40960,
	Ms61440,
	Infinity,
}

impl LoggingInterval {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(10), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(10), true, *self as i128, false)
	}
}

impl PerCodec for LoggingInterval {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LoggingInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggingInterval");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggingInterval");
			e
		})
	}
}
// LoggingDuration
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LoggingDuration {
	#[default]
	M10,
	M20,
	M40,
	M60,
	M90,
	M120,
}

impl LoggingDuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for LoggingDuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LoggingDuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggingDuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggingDuration");
			e
		})
	}
}
// LinksToLog
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LinksToLog {
	#[default]
	Uplink,
	Downlink,
	BothUplinkAndDownlink,
}

impl LinksToLog {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for LinksToLog {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LinksToLog::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LinksToLog");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LinksToLog");
			e
		})
	}
}
// LoggedMdtTrigger
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum LoggedMdtTrigger {
	#[default]
	Periodical,
	EventTrigger(EventTrigger),
}

impl LoggedMdtTrigger {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Periodical),
			1 => Ok(Self::EventTrigger(EventTrigger::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Periodical => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				Ok(())
			}
			Self::EventTrigger(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for LoggedMdtTrigger {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LoggedMdtTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggedMdtTrigger");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LoggedMdtTrigger");
			e
		})
	}
}
// LtemIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum LtemIndication {
	#[default]
	LteM,
}

impl LtemIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for LtemIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LtemIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LtemIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LtemIndication");
			e
		})
	}
}
// LteUeRlfReportContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LteUeRlfReportContainer(pub Vec<u8>);

impl LteUeRlfReportContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for LteUeRlfReportContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LteUeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LteUeRlfReportContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LteUeRlfReportContainer");
			e
		})
	}
}
// Ltev2xServicesAuthorized
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Ltev2xServicesAuthorized {
	pub vehicle_ue: Option<VehicleUe>,
	pub pedestrian_ue: Option<PedestrianUe>,
}

impl Ltev2xServicesAuthorized {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let vehicle_ue = if optionals[0] {
			Some(VehicleUe::decode(data)?)
		} else {
			None
		};
		let pedestrian_ue = if optionals[1] {
			Some(PedestrianUe::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			vehicle_ue,
			pedestrian_ue,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.vehicle_ue.is_some());
		optionals.push(self.pedestrian_ue.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.vehicle_ue {
			x.encode(data)?;
		}
		if let Some(x) = &self.pedestrian_ue {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for Ltev2xServicesAuthorized {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ltev2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Ltev2xServicesAuthorized");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Ltev2xServicesAuthorized");
			e
		})
	}
}
// LteUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct LteUeSidelinkAggregateMaximumBitrate {
	pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
}

impl LteUeSidelinkAggregateMaximumBitrate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_sidelink_aggregate_maximum_bit_rate = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_sidelink_aggregate_maximum_bit_rate,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_sidelink_aggregate_maximum_bit_rate.encode(data)?;

		Ok(())
	}
}

impl PerCodec for LteUeSidelinkAggregateMaximumBitrate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		LteUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LteUeSidelinkAggregateMaximumBitrate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("LteUeSidelinkAggregateMaximumBitrate");
			e
		})
	}
}
// MaskedImeisv
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MaskedImeisv(pub BitString);

impl MaskedImeisv {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(64),
			Some(64),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(64), Some(64), false, &self.0, false)
	}
}

impl PerCodec for MaskedImeisv {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MaskedImeisv::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaskedImeisv");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaskedImeisv");
			e
		})
	}
}
// MaximumDataBurstVolume
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MaximumDataBurstVolume(pub i128);

impl MaximumDataBurstVolume {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4095), true)?.0,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(4095), true, self.0, false)
	}
}

impl PerCodec for MaximumDataBurstVolume {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MaximumDataBurstVolume::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaximumDataBurstVolume");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaximumDataBurstVolume");
			e
		})
	}
}
// MessageIdentifier
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MessageIdentifier(pub BitString);

impl MessageIdentifier {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for MessageIdentifier {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MessageIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MessageIdentifier");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MessageIdentifier");
			e
		})
	}
}
// MaximumIntegrityProtectedDataRate
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MaximumIntegrityProtectedDataRate {
	#[default]
	Bitrate64kbs,
	MaximumUeRate,
}

impl MaximumIntegrityProtectedDataRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for MaximumIntegrityProtectedDataRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MaximumIntegrityProtectedDataRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaximumIntegrityProtectedDataRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaximumIntegrityProtectedDataRate");
			e
		})
	}
}
// MbsAreaSessionId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MbsAreaSessionId(pub u16);

impl MbsAreaSessionId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(65535), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(65535), true, self.0 as i128, false)
	}
}

impl PerCodec for MbsAreaSessionId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsAreaSessionId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsAreaSessionId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsAreaSessionId");
			e
		})
	}
}
// MbsDataForwardingResponseMrbList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDataForwardingResponseMrbList(pub NonEmpty<MbsDataForwardingResponseMrbItem>);

impl MbsDataForwardingResponseMrbList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsDataForwardingResponseMrbItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsDataForwardingResponseMrbList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDataForwardingResponseMrbList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDataForwardingResponseMrbList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDataForwardingResponseMrbList");
			e
		})
	}
}
// MbsDataForwardingResponseMrbItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDataForwardingResponseMrbItem {
	pub mrb_id: MrbId,
	pub dl_forwarding_up_tnl_information: UpTransportLayerInformation,
	pub mrb_progress_information: Option<MrbProgressInformation>,
}

impl MbsDataForwardingResponseMrbItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mrb_id = MrbId::decode(data)?;
		let dl_forwarding_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let mrb_progress_information = if optionals[0] {
			Some(MrbProgressInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mrb_id,
			dl_forwarding_up_tnl_information,
			mrb_progress_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mrb_progress_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mrb_id.encode(data)?;
		self.dl_forwarding_up_tnl_information.encode(data)?;
		if let Some(x) = &self.mrb_progress_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsDataForwardingResponseMrbItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDataForwardingResponseMrbItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDataForwardingResponseMrbItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDataForwardingResponseMrbItem");
			e
		})
	}
}
// MbsMappingandDataForwardingRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsMappingandDataForwardingRequestList(
	pub NonEmpty<MbsMappingandDataForwardingRequestItem>,
);

impl MbsMappingandDataForwardingRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsMappingandDataForwardingRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsMappingandDataForwardingRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsMappingandDataForwardingRequestList::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsMappingandDataForwardingRequestList");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsMappingandDataForwardingRequestList");
			e
		})
	}
}
// MbsMappingandDataForwardingRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsMappingandDataForwardingRequestItem {
	pub mrb_id: MrbId,
	pub mbs_qos_flow_list: MbsQosFlowList,
	pub mrb_progress_information: Option<MrbProgressInformation>,
}

impl MbsMappingandDataForwardingRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mrb_id = MrbId::decode(data)?;
		let mbs_qos_flow_list = MbsQosFlowList::decode(data)?;
		let mrb_progress_information = if optionals[0] {
			Some(MrbProgressInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mrb_id,
			mbs_qos_flow_list,
			mrb_progress_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mrb_progress_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mrb_id.encode(data)?;
		self.mbs_qos_flow_list.encode(data)?;
		if let Some(x) = &self.mrb_progress_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsMappingandDataForwardingRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsMappingandDataForwardingRequestItem::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsMappingandDataForwardingRequestItem");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsMappingandDataForwardingRequestItem");
			e
		})
	}
}
// MbsQosFlowList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsQosFlowList(pub NonEmpty<QosFlowIdentifier>);

impl MbsQosFlowList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowIdentifier::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsQosFlowList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsQosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowList");
			e
		})
	}
}
// MrbProgressInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MrbProgressInformation {
	#[default]
	PdcpSnLength12(u16),
	PdcpSnLength18(u32),
}

impl MrbProgressInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::PdcpSnLength12(
				decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
			)),
			1 => Ok(Self::PdcpSnLength18(
				decode::decode_integer(data, Some(0), Some(262143), false)?.0 as u32,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::PdcpSnLength12(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)
			}
			Self::PdcpSnLength18(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				encode::encode_integer(data, Some(0), Some(262143), false, *x as i128, false)
			}
		}
	}
}

impl PerCodec for MrbProgressInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MrbProgressInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MrbProgressInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MrbProgressInformation");
			e
		})
	}
}
// MbsQosFlowsToBeSetupList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsQosFlowsToBeSetupList(pub NonEmpty<MbsQosFlowsToBeSetupItem>);

impl MbsQosFlowsToBeSetupList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsQosFlowsToBeSetupItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsQosFlowsToBeSetupList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsQosFlowsToBeSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowsToBeSetupList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowsToBeSetupList");
			e
		})
	}
}
// MbsQosFlowsToBeSetupItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsQosFlowsToBeSetupItem {
	pub mbs_qos_flow_identifier: QosFlowIdentifier,
	pub mbs_qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
}

impl MbsQosFlowsToBeSetupItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let mbs_qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_qos_flow_identifier,
			mbs_qos_flow_level_qos_parameters,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_qos_flow_identifier.encode(data)?;
		self.mbs_qos_flow_level_qos_parameters.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsQosFlowsToBeSetupItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsQosFlowsToBeSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowsToBeSetupItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsQosFlowsToBeSetupItem");
			e
		})
	}
}
// MbsServiceArea
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MbsServiceArea {
	#[default]
	Locationindependent(MbsServiceAreaInformation),
	Locationdependent(MbsServiceAreaInformationList),
}

impl MbsServiceArea {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Locationindependent(
				MbsServiceAreaInformation::decode(data)?,
			)),
			1 => Ok(Self::Locationdependent(
				MbsServiceAreaInformationList::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Locationindependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Locationdependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MbsServiceArea {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceArea::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceArea");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceArea");
			e
		})
	}
}
// MbsServiceAreaInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsServiceAreaInformationList(pub NonEmpty<MbsServiceAreaInformationItem>);

impl MbsServiceAreaInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsServiceAreaInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsServiceAreaInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceAreaInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformationList");
			e
		})
	}
}
// MbsServiceAreaInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsServiceAreaInformationItem {
	pub mbs_area_session_id: MbsAreaSessionId,
	pub mbs_service_area_information: MbsServiceAreaInformation,
}

impl MbsServiceAreaInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_area_session_id = MbsAreaSessionId::decode(data)?;
		let mbs_service_area_information = MbsServiceAreaInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_area_session_id,
			mbs_service_area_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_area_session_id.encode(data)?;
		self.mbs_service_area_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsServiceAreaInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformationItem");
			e
		})
	}
}
// MbsServiceAreaInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsServiceAreaInformation {
	pub mbs_service_area_cell_list: Option<MbsServiceAreaCellList>,
	pub mbs_service_area_tai_list: Option<MbsServiceAreaTaiList>,
}

impl MbsServiceAreaInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mbs_service_area_cell_list = if optionals[0] {
			Some(MbsServiceAreaCellList::decode(data)?)
		} else {
			None
		};
		let mbs_service_area_tai_list = if optionals[1] {
			Some(MbsServiceAreaTaiList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_service_area_cell_list,
			mbs_service_area_tai_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_service_area_cell_list.is_some());
		optionals.push(self.mbs_service_area_tai_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.mbs_service_area_cell_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.mbs_service_area_tai_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsServiceAreaInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaInformation");
			e
		})
	}
}
// MbsServiceAreaCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsServiceAreaCellList(pub NonEmpty<NrCgi>);

impl MbsServiceAreaCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8192), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8192), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsServiceAreaCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceAreaCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaCellList");
			e
		})
	}
}
// MbsServiceAreaTaiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsServiceAreaTaiList(pub NonEmpty<Tai>);

impl MbsServiceAreaTaiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsServiceAreaTaiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsServiceAreaTaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaTaiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsServiceAreaTaiList");
			e
		})
	}
}
// MbsSessionId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionId {
	pub tmgi: Tmgi,
	pub nid: Option<Nid>,
}

impl MbsSessionId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let tmgi = Tmgi::decode(data)?;
		let nid = if optionals[0] {
			Some(Nid::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tmgi, nid })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.nid.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tmgi.encode(data)?;
		if let Some(x) = &self.nid {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionId");
			e
		})
	}
}
// MbsSessionFailedtoSetupList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionFailedtoSetupList(pub NonEmpty<MbsSessionFailedtoSetupItem>);

impl MbsSessionFailedtoSetupList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionFailedtoSetupItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionFailedtoSetupList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionFailedtoSetupList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFailedtoSetupList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFailedtoSetupList");
			e
		})
	}
}
// MbsSessionFailedtoSetupItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionFailedtoSetupItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub cause: Cause,
}

impl MbsSessionFailedtoSetupItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsSessionFailedtoSetupItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionFailedtoSetupItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFailedtoSetupItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFailedtoSetupItem");
			e
		})
	}
}
// MbsActiveSessionInformationSourcetoTargetList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsActiveSessionInformationSourcetoTargetList(
	pub NonEmpty<MbsActiveSessionInformationSourcetoTargetItem>,
);

impl MbsActiveSessionInformationSourcetoTargetList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsActiveSessionInformationSourcetoTargetItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsActiveSessionInformationSourcetoTargetList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsActiveSessionInformationSourcetoTargetList::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsActiveSessionInformationSourcetoTargetList");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsActiveSessionInformationSourcetoTargetList");
			e
		})
	}
}
// MbsActiveSessionInformationSourcetoTargetItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsActiveSessionInformationSourcetoTargetItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub mbs_service_area: Option<MbsServiceArea>,
	pub mbs_qos_flows_to_be_setup_list: MbsQosFlowsToBeSetupList,
	pub mbs_mappingand_data_forwarding_request_list: Option<MbsMappingandDataForwardingRequestList>,
}

impl MbsActiveSessionInformationSourcetoTargetItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let mbs_service_area = if optionals[1] {
			Some(MbsServiceArea::decode(data)?)
		} else {
			None
		};
		let mbs_qos_flows_to_be_setup_list = MbsQosFlowsToBeSetupList::decode(data)?;
		let mbs_mappingand_data_forwarding_request_list = if optionals[2] {
			Some(MbsMappingandDataForwardingRequestList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			mbs_service_area,
			mbs_qos_flows_to_be_setup_list,
			mbs_mappingand_data_forwarding_request_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.mbs_service_area.is_some());
		optionals.push(self.mbs_mappingand_data_forwarding_request_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.mbs_service_area {
			x.encode(data)?;
		}
		self.mbs_qos_flows_to_be_setup_list.encode(data)?;
		if let Some(x) = &self.mbs_mappingand_data_forwarding_request_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsActiveSessionInformationSourcetoTargetItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsActiveSessionInformationSourcetoTargetItem::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsActiveSessionInformationSourcetoTargetItem");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsActiveSessionInformationSourcetoTargetItem");
			e
		})
	}
}
// MbsActiveSessionInformationTargettoSourceList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsActiveSessionInformationTargettoSourceList(
	pub NonEmpty<MbsActiveSessionInformationTargettoSourceItem>,
);

impl MbsActiveSessionInformationTargettoSourceList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsActiveSessionInformationTargettoSourceItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsActiveSessionInformationTargettoSourceList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsActiveSessionInformationTargettoSourceList::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsActiveSessionInformationTargettoSourceList");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsActiveSessionInformationTargettoSourceList");
			e
		})
	}
}
// MbsActiveSessionInformationTargettoSourceItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsActiveSessionInformationTargettoSourceItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_data_forwarding_response_mrb_list: Option<MbsDataForwardingResponseMrbList>,
}

impl MbsActiveSessionInformationTargettoSourceItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_data_forwarding_response_mrb_list = if optionals[0] {
			Some(MbsDataForwardingResponseMrbList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_data_forwarding_response_mrb_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_data_forwarding_response_mrb_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_data_forwarding_response_mrb_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsActiveSessionInformationTargettoSourceItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsActiveSessionInformationTargettoSourceItem::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsActiveSessionInformationTargettoSourceItem");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsActiveSessionInformationTargettoSourceItem");
			e
		})
	}
}
// MbsSessionSetupOrModFailureTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupOrModFailureTransfer {
	pub cause: Cause,
	pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MbsSessionSetupOrModFailureTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cause = Cause::decode(data)?;
		let criticality_diagnostics = if optionals[0] {
			Some(CriticalityDiagnostics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cause,
			criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;
		if let Some(x) = &self.criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionSetupOrModFailureTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupOrModFailureTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModFailureTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModFailureTransfer");
			e
		})
	}
}
// MbsSessionSetupResponseList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupResponseList(pub NonEmpty<MbsSessionSetupResponseItem>);

impl MbsSessionSetupResponseList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionSetupResponseItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionSetupResponseList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupResponseList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupResponseList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupResponseList");
			e
		})
	}
}
// MbsSessionSetupResponseItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupResponseItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
}

impl MbsSessionSetupResponseItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionSetupResponseItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupResponseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupResponseItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupResponseItem");
			e
		})
	}
}
// MbsSessionSetupOrModRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupOrModRequestTransfer {
	pub mbs_session_tnl_info_5gc: Option<MbsSessionTnlInfo5gc>,
	pub mbs_qos_flows_to_be_setup_mod_list: MbsQosFlowsToBeSetupList,
	pub mbs_session_fsaid_list: Option<MbsSessionFsaidList>,
}

impl MbsSessionSetupOrModRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let _ = decode::decode_sequence_header(data, true, 0)?;
		let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

		let mut mbs_session_tnl_info_5gc: Option<MbsSessionTnlInfo5gc> = None;
		let mut mbs_qos_flows_to_be_setup_mod_list: Option<MbsQosFlowsToBeSetupList> = None;
		let mut mbs_session_fsaid_list: Option<MbsSessionFsaidList> = None;

		for _ in 0..num_ies {
			let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
			let _ = Criticality::decode(data)?;
			let _ = decode::decode_length_determinent(data, None, None, false)?;
			match id {
				352 => mbs_session_tnl_info_5gc = Some(MbsSessionTnlInfo5gc::decode(data)?),
				297 => {
					mbs_qos_flows_to_be_setup_mod_list =
						Some(MbsQosFlowsToBeSetupList::decode(data)?)
				}
				357 => mbs_session_fsaid_list = Some(MbsSessionFsaidList::decode(data)?),
				x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
			}
			data.decode_align()?;
		}
		let mbs_qos_flows_to_be_setup_mod_list =
			mbs_qos_flows_to_be_setup_mod_list.ok_or(PerCodecError::new(format!(
				"Missing mandatory IE mbs_qos_flows_to_be_setup_mod_list"
			)))?;
		Ok(Self {
			mbs_session_tnl_info_5gc,
			mbs_qos_flows_to_be_setup_mod_list,
			mbs_session_fsaid_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();

		if let Some(x) = &self.mbs_session_tnl_info_5gc {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 352, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let ie = &mut Allocator::new_codec_data();
		self.mbs_qos_flows_to_be_setup_mod_list.encode(ie)?;
		encode::encode_integer(ies, Some(0), Some(65535), false, 297, false)?;
		Criticality::Reject.encode(ies)?;
		encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
		ies.append_aligned(ie);
		num_ies += 1;

		if let Some(x) = &self.mbs_session_fsaid_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 357, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		encode::encode_sequence_header(data, true, &BitString::new(), false)?;
		encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
		data.append_aligned(ies);
		Ok(())
	}
}

impl PerCodec for MbsSessionSetupOrModRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupOrModRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModRequestTransfer");
			e
		})
	}
}
// MbsSessionFsaidList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionFsaidList(pub NonEmpty<MbsSessionFsaid>);

impl MbsSessionFsaidList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionFsaid::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionFsaidList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionFsaidList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFsaidList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFsaidList");
			e
		})
	}
}
// MbsSessionFsaid
#[derive(Clone, Debug)]
pub struct MbsSessionFsaid(pub [u8; 3]);
impl Default for MbsSessionFsaid {
	fn default() -> MbsSessionFsaid {
		let init = std::mem::MaybeUninit::<[u8; 3]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		MbsSessionFsaid(default_value)
	}
}
impl MbsSessionFsaid {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(3), Some(3), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
	}
}

impl PerCodec for MbsSessionFsaid {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionFsaid::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFsaid");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionFsaid");
			e
		})
	}
}
// MbsSessionReleaseResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionReleaseResponseTransfer {
	pub mbs_session_tnl_info_ngran: Option<MbsSessionTnlInfoNgran>,
}

impl MbsSessionReleaseResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_session_tnl_info_ngran = if optionals[0] {
			Some(MbsSessionTnlInfoNgran::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_tnl_info_ngran,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_session_tnl_info_ngran.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.mbs_session_tnl_info_ngran {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionReleaseResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionReleaseResponseTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionReleaseResponseTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionReleaseResponseTransfer");
			e
		})
	}
}
// MbsSessionSetupOrModResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupOrModResponseTransfer {
	pub mbs_session_tnl_info_ngran: Option<MbsSessionTnlInfoNgran>,
}

impl MbsSessionSetupOrModResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_session_tnl_info_ngran = if optionals[0] {
			Some(MbsSessionTnlInfoNgran::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_tnl_info_ngran,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_session_tnl_info_ngran.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.mbs_session_tnl_info_ngran {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionSetupOrModResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupOrModResponseTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModResponseTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupOrModResponseTransfer");
			e
		})
	}
}
// MbsSupportIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MbsSupportIndicator {
	#[default]
	True,
}

impl MbsSupportIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for MbsSupportIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSupportIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSupportIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSupportIndicator");
			e
		})
	}
}
// MbsSessionTnlInfo5gc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MbsSessionTnlInfo5gc {
	#[default]
	Locationindependent(SharedNguMulticastTnlInformation),
	Locationdependent(MbsSessionTnlInfo5gcList),
}

impl MbsSessionTnlInfo5gc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Locationindependent(
				SharedNguMulticastTnlInformation::decode(data)?,
			)),
			1 => Ok(Self::Locationdependent(MbsSessionTnlInfo5gcList::decode(
				data,
			)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Locationindependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Locationdependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MbsSessionTnlInfo5gc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfo5gc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gc");
			e
		})
	}
}
// MbsSessionTnlInfo5gcList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionTnlInfo5gcList(pub NonEmpty<MbsSessionTnlInfo5gcItem>);

impl MbsSessionTnlInfo5gcList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionTnlInfo5gcItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionTnlInfo5gcList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfo5gcList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gcList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gcList");
			e
		})
	}
}
// MbsSessionTnlInfo5gcItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionTnlInfo5gcItem {
	pub mbs_area_session_id: MbsAreaSessionId,
	pub shared_ngu_multicast_tnl_information: SharedNguMulticastTnlInformation,
}

impl MbsSessionTnlInfo5gcItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_area_session_id = MbsAreaSessionId::decode(data)?;
		let shared_ngu_multicast_tnl_information = SharedNguMulticastTnlInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_area_session_id,
			shared_ngu_multicast_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_area_session_id.encode(data)?;
		self.shared_ngu_multicast_tnl_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsSessionTnlInfo5gcItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfo5gcItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gcItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfo5gcItem");
			e
		})
	}
}
// MbsSessionTnlInfoNgran
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MbsSessionTnlInfoNgran {
	#[default]
	Locationindependent(UpTransportLayerInformation),
	Locationdependent(MbsSessionTnlInfoNgranList),
}

impl MbsSessionTnlInfoNgran {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Locationindependent(
				UpTransportLayerInformation::decode(data)?,
			)),
			1 => Ok(Self::Locationdependent(MbsSessionTnlInfoNgranList::decode(
				data,
			)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Locationindependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Locationdependent(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MbsSessionTnlInfoNgran {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfoNgran::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgran");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgran");
			e
		})
	}
}
// MbsSessionTnlInfoNgranList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionTnlInfoNgranList(pub NonEmpty<MbsSessionTnlInfoNgranItem>);

impl MbsSessionTnlInfoNgranList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionTnlInfoNgranItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionTnlInfoNgranList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfoNgranList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgranList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgranList");
			e
		})
	}
}
// MbsSessionTnlInfoNgranItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionTnlInfoNgranItem {
	pub mbs_area_session_id: MbsAreaSessionId,
	pub shared_ngu_unicast_tnl_information: Option<UpTransportLayerInformation>,
}

impl MbsSessionTnlInfoNgranItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mbs_area_session_id = MbsAreaSessionId::decode(data)?;
		let shared_ngu_unicast_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_area_session_id,
			shared_ngu_unicast_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.shared_ngu_unicast_tnl_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_area_session_id.encode(data)?;
		if let Some(x) = &self.shared_ngu_unicast_tnl_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionTnlInfoNgranItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionTnlInfoNgranItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgranItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionTnlInfoNgranItem");
			e
		})
	}
}
// MbsDistributionReleaseRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDistributionReleaseRequestTransfer {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub shared_ngu_unicast_tnl_information: Option<UpTransportLayerInformation>,
	pub cause: Cause,
}

impl MbsDistributionReleaseRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let shared_ngu_unicast_tnl_information = if optionals[1] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			shared_ngu_unicast_tnl_information,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.shared_ngu_unicast_tnl_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.shared_ngu_unicast_tnl_information {
			x.encode(data)?;
		}
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsDistributionReleaseRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDistributionReleaseRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionReleaseRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionReleaseRequestTransfer");
			e
		})
	}
}
// MbsDistributionSetupRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDistributionSetupRequestTransfer {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub shared_ngu_unicast_tnl_information: Option<UpTransportLayerInformation>,
}

impl MbsDistributionSetupRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let shared_ngu_unicast_tnl_information = if optionals[1] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			shared_ngu_unicast_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.shared_ngu_unicast_tnl_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.shared_ngu_unicast_tnl_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsDistributionSetupRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDistributionSetupRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionSetupRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionSetupRequestTransfer");
			e
		})
	}
}
// MbsDistributionSetupResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDistributionSetupResponseTransfer {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub shared_ngu_multicast_tnl_information: Option<SharedNguMulticastTnlInformation>,
	pub mbs_qos_flows_to_be_setup_list: MbsQosFlowsToBeSetupList,
	pub mbs_session_status: MbsSessionStatus,
	pub mbs_service_area: Option<MbsServiceArea>,
}

impl MbsDistributionSetupResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let shared_ngu_multicast_tnl_information = if optionals[1] {
			Some(SharedNguMulticastTnlInformation::decode(data)?)
		} else {
			None
		};
		let mbs_qos_flows_to_be_setup_list = MbsQosFlowsToBeSetupList::decode(data)?;
		let mbs_session_status = MbsSessionStatus::decode(data)?;
		let mbs_service_area = if optionals[2] {
			Some(MbsServiceArea::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			shared_ngu_multicast_tnl_information,
			mbs_qos_flows_to_be_setup_list,
			mbs_session_status,
			mbs_service_area,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.shared_ngu_multicast_tnl_information.is_some());
		optionals.push(self.mbs_service_area.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.shared_ngu_multicast_tnl_information {
			x.encode(data)?;
		}
		self.mbs_qos_flows_to_be_setup_list.encode(data)?;
		self.mbs_session_status.encode(data)?;
		if let Some(x) = &self.mbs_service_area {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsDistributionSetupResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDistributionSetupResponseTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionSetupResponseTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionSetupResponseTransfer");
			e
		})
	}
}
// MbsDistributionSetupUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsDistributionSetupUnsuccessfulTransfer {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub cause: Cause,
	pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl MbsDistributionSetupUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let cause = Cause::decode(data)?;
		let criticality_diagnostics = if optionals[1] {
			Some(CriticalityDiagnostics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			cause,
			criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		self.cause.encode(data)?;
		if let Some(x) = &self.criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsDistributionSetupUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsDistributionSetupUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MbsDistributionSetupUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsDistributionSetupUnsuccessfulTransfer");
			e
		})
	}
}
// MbsSessionSetupRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupRequestList(pub NonEmpty<MbsSessionSetupRequestItem>);

impl MbsSessionSetupRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionSetupRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionSetupRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupRequestList");
			e
		})
	}
}
// MbsSessionSetupRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetupRequestItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub associated_mbs_qos_flow_setup_request_list: Option<AssociatedMbsQosFlowSetupRequestList>,
}

impl MbsSessionSetupRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let associated_mbs_qos_flow_setup_request_list = if optionals[1] {
			Some(AssociatedMbsQosFlowSetupRequestList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			associated_mbs_qos_flow_setup_request_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(self.associated_mbs_qos_flow_setup_request_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.associated_mbs_qos_flow_setup_request_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionSetupRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetupRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetupRequestItem");
			e
		})
	}
}
// MbsSessionSetuporModifyRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetuporModifyRequestList(pub NonEmpty<MbsSessionSetuporModifyRequestItem>);

impl MbsSessionSetuporModifyRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionSetuporModifyRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionSetuporModifyRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetuporModifyRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetuporModifyRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetuporModifyRequestList");
			e
		})
	}
}
// MbsSessionSetuporModifyRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionSetuporModifyRequestItem {
	pub mbs_session_id: MbsSessionId,
	pub mbs_area_session_id: Option<MbsAreaSessionId>,
	pub associated_mbs_qos_flow_setupor_modify_request_list:
		Option<AssociatedMbsQosFlowSetuporModifyRequestList>,
	pub mbs_qos_flow_to_release_list: Option<QosFlowListWithCause>,
}

impl MbsSessionSetuporModifyRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let mbs_area_session_id = if optionals[0] {
			Some(MbsAreaSessionId::decode(data)?)
		} else {
			None
		};
		let associated_mbs_qos_flow_setupor_modify_request_list = if optionals[1] {
			Some(AssociatedMbsQosFlowSetuporModifyRequestList::decode(data)?)
		} else {
			None
		};
		let mbs_qos_flow_to_release_list = if optionals[2] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			mbs_area_session_id,
			associated_mbs_qos_flow_setupor_modify_request_list,
			mbs_qos_flow_to_release_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mbs_area_session_id.is_some());
		optionals.push(
			self.associated_mbs_qos_flow_setupor_modify_request_list
				.is_some(),
		);
		optionals.push(self.mbs_qos_flow_to_release_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		if let Some(x) = &self.mbs_area_session_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.associated_mbs_qos_flow_setupor_modify_request_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.mbs_qos_flow_to_release_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MbsSessionSetuporModifyRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionSetuporModifyRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetuporModifyRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionSetuporModifyRequestItem");
			e
		})
	}
}
// MbsSessionToReleaseList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionToReleaseList(pub NonEmpty<MbsSessionToReleaseItem>);

impl MbsSessionToReleaseList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MbsSessionToReleaseItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsSessionToReleaseList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionToReleaseList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionToReleaseList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionToReleaseList");
			e
		})
	}
}
// MbsSessionToReleaseItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsSessionToReleaseItem {
	pub mbs_session_id: MbsSessionId,
	pub cause: Cause,
}

impl MbsSessionToReleaseItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_session_id = MbsSessionId::decode(data)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mbs_session_id,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MbsSessionToReleaseItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionToReleaseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionToReleaseItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionToReleaseItem");
			e
		})
	}
}
// MbsSessionStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MbsSessionStatus {
	#[default]
	Activated,
	Deactivated,
}

impl MbsSessionStatus {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for MbsSessionStatus {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsSessionStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionStatus");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsSessionStatus");
			e
		})
	}
}
// MicoAllPlmn
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MicoAllPlmn {
	#[default]
	True,
}

impl MicoAllPlmn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for MicoAllPlmn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MicoAllPlmn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MicoAllPlmn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MicoAllPlmn");
			e
		})
	}
}
// MicoModeIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MicoModeIndication {
	#[default]
	True,
}

impl MicoModeIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for MicoModeIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MicoModeIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MicoModeIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MicoModeIndication");
			e
		})
	}
}
// MobilityInformation
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MobilityInformation(pub BitString);

impl MobilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for MobilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MobilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MobilityInformation");
			e
		})
	}
}
// ExtendedMobilityInformation
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ExtendedMobilityInformation(pub BitString);

impl ExtendedMobilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(32),
			Some(32),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(32), Some(32), false, &self.0, false)
	}
}

impl PerCodec for ExtendedMobilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedMobilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedMobilityInformation");
			e
		})
	}
}
// MobilityRestrictionList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MobilityRestrictionList {
	pub serving_plmn: PlmnIdentity,
	pub equivalent_plmns: Option<EquivalentPlmns>,
	pub rat_restrictions: Option<RatRestrictions>,
	pub forbidden_area_information: Option<ForbiddenAreaInformation>,
	pub service_area_information: Option<ServiceAreaInformation>,
	pub last_eutran_plmn_identity: Option<PlmnIdentity>,
	pub cn_type_restrictions_for_serving: Option<CnTypeRestrictionsForServing>,
	pub cn_type_restrictions_for_equivalent: Option<CnTypeRestrictionsForEquivalent>,
	pub npn_mobility_information: Option<NpnMobilityInformation>,
}

impl MobilityRestrictionList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 5)?;
		let serving_plmn = PlmnIdentity::decode(data)?;
		let equivalent_plmns = if optionals[0] {
			Some(EquivalentPlmns::decode(data)?)
		} else {
			None
		};
		let rat_restrictions = if optionals[1] {
			Some(RatRestrictions::decode(data)?)
		} else {
			None
		};
		let forbidden_area_information = if optionals[2] {
			Some(ForbiddenAreaInformation::decode(data)?)
		} else {
			None
		};
		let service_area_information = if optionals[3] {
			Some(ServiceAreaInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut last_eutran_plmn_identity: Option<PlmnIdentity> = None;
		let mut cn_type_restrictions_for_serving: Option<CnTypeRestrictionsForServing> = None;
		let mut cn_type_restrictions_for_equivalent: Option<CnTypeRestrictionsForEquivalent> = None;
		let mut npn_mobility_information: Option<NpnMobilityInformation> = None;

		if optionals[4] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					150 => last_eutran_plmn_identity = Some(PlmnIdentity::decode(data)?),
					161 => {
						cn_type_restrictions_for_serving =
							Some(CnTypeRestrictionsForServing::decode(data)?)
					}
					160 => {
						cn_type_restrictions_for_equivalent =
							Some(CnTypeRestrictionsForEquivalent::decode(data)?)
					}
					261 => npn_mobility_information = Some(NpnMobilityInformation::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			serving_plmn,
			equivalent_plmns,
			rat_restrictions,
			forbidden_area_information,
			service_area_information,
			last_eutran_plmn_identity,
			cn_type_restrictions_for_serving,
			cn_type_restrictions_for_equivalent,
			npn_mobility_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.last_eutran_plmn_identity {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 150, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_type_restrictions_for_serving {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 161, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_type_restrictions_for_equivalent {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 160, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.npn_mobility_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 261, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.equivalent_plmns.is_some());
		optionals.push(self.rat_restrictions.is_some());
		optionals.push(self.forbidden_area_information.is_some());
		optionals.push(self.service_area_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.serving_plmn.encode(data)?;
		if let Some(x) = &self.equivalent_plmns {
			x.encode(data)?;
		}
		if let Some(x) = &self.rat_restrictions {
			x.encode(data)?;
		}
		if let Some(x) = &self.forbidden_area_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.service_area_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for MobilityRestrictionList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MobilityRestrictionList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MobilityRestrictionList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MobilityRestrictionList");
			e
		})
	}
}
// MdtAlignmentInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MdtAlignmentInfo {
	#[default]
	SBasedMdt(NgranTraceId),
}

impl MdtAlignmentInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::SBasedMdt(NgranTraceId::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::SBasedMdt(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MdtAlignmentInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtAlignmentInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtAlignmentInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtAlignmentInfo");
			e
		})
	}
}
// MdtPlmnList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtPlmnList(pub NonEmpty<PlmnIdentity>);

impl MdtPlmnList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PlmnIdentity::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MdtPlmnList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtPlmnList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtPlmnList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtPlmnList");
			e
		})
	}
}
// MdtPlmnModificationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtPlmnModificationList(pub Vec<PlmnIdentity>);

impl MdtPlmnModificationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(0), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PlmnIdentity::decode(data)?);
			}
			items
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(0), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MdtPlmnModificationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtPlmnModificationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtPlmnModificationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtPlmnModificationList");
			e
		})
	}
}
// MdtConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtConfiguration {
	pub mdt_config_nr: Option<MdtConfigurationNr>,
	pub mdt_config_eutra: Option<MdtConfigurationEutra>,
}

impl MdtConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let mdt_config_nr = if optionals[0] {
			Some(MdtConfigurationNr::decode(data)?)
		} else {
			None
		};
		let mdt_config_eutra = if optionals[1] {
			Some(MdtConfigurationEutra::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mdt_config_nr,
			mdt_config_eutra,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.mdt_config_nr.is_some());
		optionals.push(self.mdt_config_eutra.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.mdt_config_nr {
			x.encode(data)?;
		}
		if let Some(x) = &self.mdt_config_eutra {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MdtConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfiguration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfiguration");
			e
		})
	}
}
// MdtConfigurationNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtConfigurationNr {
	pub mdt_activation: MdtActivation,
	pub area_scope_of_mdt: AreaScopeOfMdtNr,
	pub mdt_mode_nr: MdtModeNr,
	pub signalling_based_mdt_plmn_list: Option<MdtPlmnList>,
}

impl MdtConfigurationNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mdt_activation = MdtActivation::decode(data)?;
		let area_scope_of_mdt = AreaScopeOfMdtNr::decode(data)?;
		let mdt_mode_nr = MdtModeNr::decode(data)?;
		let signalling_based_mdt_plmn_list = if optionals[0] {
			Some(MdtPlmnList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mdt_activation,
			area_scope_of_mdt,
			mdt_mode_nr,
			signalling_based_mdt_plmn_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.signalling_based_mdt_plmn_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mdt_activation.encode(data)?;
		self.area_scope_of_mdt.encode(data)?;
		self.mdt_mode_nr.encode(data)?;
		if let Some(x) = &self.signalling_based_mdt_plmn_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MdtConfigurationNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtConfigurationNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfigurationNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfigurationNr");
			e
		})
	}
}
// MdtConfigurationEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtConfigurationEutra {
	pub mdt_activation: MdtActivation,
	pub area_scope_of_mdt: AreaScopeOfMdtEutra,
	pub mdt_mode: MdtModeEutra,
	pub signalling_based_mdt_plmn_list: Option<MdtPlmnList>,
}

impl MdtConfigurationEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let mdt_activation = MdtActivation::decode(data)?;
		let area_scope_of_mdt = AreaScopeOfMdtEutra::decode(data)?;
		let mdt_mode = MdtModeEutra::decode(data)?;
		let signalling_based_mdt_plmn_list = if optionals[0] {
			Some(MdtPlmnList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mdt_activation,
			area_scope_of_mdt,
			mdt_mode,
			signalling_based_mdt_plmn_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.signalling_based_mdt_plmn_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mdt_activation.encode(data)?;
		self.area_scope_of_mdt.encode(data)?;
		self.mdt_mode.encode(data)?;
		if let Some(x) = &self.signalling_based_mdt_plmn_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MdtConfigurationEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtConfigurationEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfigurationEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtConfigurationEutra");
			e
		})
	}
}
// MdtActivation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum MdtActivation {
	#[default]
	ImmediateMdtOnly,
	LoggedMdtOnly,
	ImmediateMdtAndTrace,
}

impl MdtActivation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for MdtActivation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtActivation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtActivation");
			e
		})
	}
}
// MdtModeNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum MdtModeNr {
	#[default]
	ImmediateMdtNr(ImmediateMdtNr),
	LoggedMdtNr(LoggedMdtNr),
}

impl MdtModeNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::ImmediateMdtNr(ImmediateMdtNr::decode(data)?)),
			1 => Ok(Self::LoggedMdtNr(LoggedMdtNr::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::ImmediateMdtNr(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::LoggedMdtNr(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for MdtModeNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtModeNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtModeNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtModeNr");
			e
		})
	}
}
// MdtModeEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtModeEutra(pub Vec<u8>);

impl MdtModeEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for MdtModeEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtModeEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtModeEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtModeEutra");
			e
		})
	}
}
// MeasurementsToActivate
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MeasurementsToActivate(pub BitString);

impl MeasurementsToActivate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for MeasurementsToActivate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MeasurementsToActivate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MeasurementsToActivate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MeasurementsToActivate");
			e
		})
	}
}
// MrbId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MrbId(pub u16);

impl MrbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(512), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(512), true, self.0 as i128, false)
	}
}

impl PerCodec for MrbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MrbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MrbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MrbId");
			e
		})
	}
}
// MulticastSessionActivationRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastSessionActivationRequestTransfer {
	pub mbs_session_id: MbsSessionId,
}

impl MulticastSessionActivationRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_session_id = MbsSessionId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { mbs_session_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MulticastSessionActivationRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastSessionActivationRequestTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MulticastSessionActivationRequestTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastSessionActivationRequestTransfer");
			e
		})
	}
}
// MulticastSessionDeactivationRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastSessionDeactivationRequestTransfer {
	pub mbs_session_id: MbsSessionId,
}

impl MulticastSessionDeactivationRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_session_id = MbsSessionId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { mbs_session_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_session_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MulticastSessionDeactivationRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastSessionDeactivationRequestTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("MulticastSessionDeactivationRequestTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastSessionDeactivationRequestTransfer");
			e
		})
	}
}
// MulticastSessionUpdateRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastSessionUpdateRequestTransfer {
	pub mbs_session_id: MbsSessionId,
	pub mbs_service_area: Option<MbsServiceArea>,
	pub mbs_qos_flows_to_be_setup_mod_list: Option<MbsQosFlowsToBeSetupList>,
	pub mbs_qos_flow_to_release_list: Option<QosFlowListWithCause>,
	pub mbs_session_tnl_info_5gc: Option<MbsSessionTnlInfo5gc>,
}

impl MulticastSessionUpdateRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let _ = decode::decode_sequence_header(data, true, 0)?;
		let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

		let mut mbs_session_id: Option<MbsSessionId> = None;
		let mut mbs_service_area: Option<MbsServiceArea> = None;
		let mut mbs_qos_flows_to_be_setup_mod_list: Option<MbsQosFlowsToBeSetupList> = None;
		let mut mbs_qos_flow_to_release_list: Option<QosFlowListWithCause> = None;
		let mut mbs_session_tnl_info_5gc: Option<MbsSessionTnlInfo5gc> = None;

		for _ in 0..num_ies {
			let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
			let _ = Criticality::decode(data)?;
			let _ = decode::decode_length_determinent(data, None, None, false)?;
			match id {
				299 => mbs_session_id = Some(MbsSessionId::decode(data)?),
				298 => mbs_service_area = Some(MbsServiceArea::decode(data)?),
				297 => {
					mbs_qos_flows_to_be_setup_mod_list =
						Some(MbsQosFlowsToBeSetupList::decode(data)?)
				}
				351 => mbs_qos_flow_to_release_list = Some(QosFlowListWithCause::decode(data)?),
				352 => mbs_session_tnl_info_5gc = Some(MbsSessionTnlInfo5gc::decode(data)?),
				x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
			}
			data.decode_align()?;
		}
		let mbs_session_id = mbs_session_id.ok_or(PerCodecError::new(format!(
			"Missing mandatory IE mbs_session_id"
		)))?;
		Ok(Self {
			mbs_session_id,
			mbs_service_area,
			mbs_qos_flows_to_be_setup_mod_list,
			mbs_qos_flow_to_release_list,
			mbs_session_tnl_info_5gc,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();

		let ie = &mut Allocator::new_codec_data();
		self.mbs_session_id.encode(ie)?;
		encode::encode_integer(ies, Some(0), Some(65535), false, 299, false)?;
		Criticality::Reject.encode(ies)?;
		encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
		ies.append_aligned(ie);
		num_ies += 1;

		if let Some(x) = &self.mbs_service_area {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 298, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_qos_flows_to_be_setup_mod_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 297, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_qos_flow_to_release_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 351, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_tnl_info_5gc {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 352, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		encode::encode_sequence_header(data, true, &BitString::new(), false)?;
		encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
		data.append_aligned(ies);
		Ok(())
	}
}

impl PerCodec for MulticastSessionUpdateRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastSessionUpdateRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastSessionUpdateRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastSessionUpdateRequestTransfer");
			e
		})
	}
}
// MulticastGroupPagingAreaList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastGroupPagingAreaList(pub NonEmpty<MulticastGroupPagingAreaItem>);

impl MulticastGroupPagingAreaList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(MulticastGroupPagingAreaItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MulticastGroupPagingAreaList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastGroupPagingAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingAreaList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingAreaList");
			e
		})
	}
}
// MulticastGroupPagingAreaItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastGroupPagingAreaItem {
	pub multicast_group_paging_area: MulticastGroupPagingArea,
	pub ue_paging_list: Option<UePagingList>,
}

impl MulticastGroupPagingAreaItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let multicast_group_paging_area = MulticastGroupPagingArea::decode(data)?;
		let ue_paging_list = if optionals[0] {
			Some(UePagingList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			multicast_group_paging_area,
			ue_paging_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ue_paging_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.multicast_group_paging_area.encode(data)?;
		if let Some(x) = &self.ue_paging_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for MulticastGroupPagingAreaItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastGroupPagingAreaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingAreaItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingAreaItem");
			e
		})
	}
}
// MbsAreaTaiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MbsAreaTaiList(pub NonEmpty<Tai>);

impl MbsAreaTaiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for MbsAreaTaiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MbsAreaTaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsAreaTaiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MbsAreaTaiList");
			e
		})
	}
}
// MulticastGroupPagingArea
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MulticastGroupPagingArea {
	pub mbs_area_tai_list: MbsAreaTaiList,
}

impl MulticastGroupPagingArea {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mbs_area_tai_list = MbsAreaTaiList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { mbs_area_tai_list })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mbs_area_tai_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MulticastGroupPagingArea {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MulticastGroupPagingArea::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingArea");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MulticastGroupPagingArea");
			e
		})
	}
}
// UePagingList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UePagingList(pub NonEmpty<UePagingItem>);

impl UePagingList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(4096), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UePagingItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(4096), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UePagingList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePagingList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingList");
			e
		})
	}
}
// UePagingItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UePagingItem {
	pub ue_identity_index_value: UeIdentityIndexValue,
	pub paging_drx: Option<PagingDrx>,
}

impl UePagingItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ue_identity_index_value = UeIdentityIndexValue::decode(data)?;
		let paging_drx = if optionals[0] {
			Some(PagingDrx::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_identity_index_value,
			paging_drx,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.paging_drx.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_identity_index_value.encode(data)?;
		if let Some(x) = &self.paging_drx {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UePagingItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePagingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingItem");
			e
		})
	}
}
// M1Configuration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M1Configuration {
	pub m1reporting_trigger: M1ReportingTrigger,
	pub m1threshold_event_a2: Option<M1ThresholdEventA2>,
	pub m1periodic_reporting: Option<M1PeriodicReporting>,
	pub include_beam_measurements_indication: Option<IncludeBeamMeasurementsIndication>,
	pub beam_measurements_report_configuration: Option<BeamMeasurementsReportConfiguration>,
}

impl M1Configuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let m1reporting_trigger = M1ReportingTrigger::decode(data)?;
		let m1threshold_event_a2 = if optionals[0] {
			Some(M1ThresholdEventA2::decode(data)?)
		} else {
			None
		};
		let m1periodic_reporting = if optionals[1] {
			Some(M1PeriodicReporting::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut include_beam_measurements_indication: Option<IncludeBeamMeasurementsIndication> =
			None;
		let mut beam_measurements_report_configuration: Option<
			BeamMeasurementsReportConfiguration,
		> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					340 => {
						include_beam_measurements_indication =
							Some(IncludeBeamMeasurementsIndication::decode(data)?)
					}
					361 => {
						beam_measurements_report_configuration =
							Some(BeamMeasurementsReportConfiguration::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			m1reporting_trigger,
			m1threshold_event_a2,
			m1periodic_reporting,
			include_beam_measurements_indication,
			beam_measurements_report_configuration,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.include_beam_measurements_indication {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 340, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.beam_measurements_report_configuration {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 361, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.m1threshold_event_a2.is_some());
		optionals.push(self.m1periodic_reporting.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m1reporting_trigger.encode(data)?;
		if let Some(x) = &self.m1threshold_event_a2 {
			x.encode(data)?;
		}
		if let Some(x) = &self.m1periodic_reporting {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M1Configuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M1Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1Configuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1Configuration");
			e
		})
	}
}
// IncludeBeamMeasurementsIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum IncludeBeamMeasurementsIndication {
	#[default]
	True,
}

impl IncludeBeamMeasurementsIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for IncludeBeamMeasurementsIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		IncludeBeamMeasurementsIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IncludeBeamMeasurementsIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("IncludeBeamMeasurementsIndication");
			e
		})
	}
}
// MaxNrofRsIndexesToReport
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MaxNrofRsIndexesToReport(pub u8);

impl MaxNrofRsIndexesToReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(64), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(64), true, self.0 as i128, false)
	}
}

impl PerCodec for MaxNrofRsIndexesToReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MaxNrofRsIndexesToReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaxNrofRsIndexesToReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MaxNrofRsIndexesToReport");
			e
		})
	}
}
// M1ReportingTrigger
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M1ReportingTrigger {
	#[default]
	Periodic,
	A2eventtriggered,
	A2eventtriggeredPeriodic,
}

impl M1ReportingTrigger {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for M1ReportingTrigger {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M1ReportingTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ReportingTrigger");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ReportingTrigger");
			e
		})
	}
}
// M1ThresholdEventA2
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M1ThresholdEventA2 {
	pub m1_threshold_type: M1ThresholdType,
}

impl M1ThresholdEventA2 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let m1_threshold_type = M1ThresholdType::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { m1_threshold_type })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m1_threshold_type.encode(data)?;

		Ok(())
	}
}

impl PerCodec for M1ThresholdEventA2 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M1ThresholdEventA2::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ThresholdEventA2");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ThresholdEventA2");
			e
		})
	}
}
// M1ThresholdType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum M1ThresholdType {
	#[default]
	ThresholdRsrp(ThresholdRsrp),
	ThresholdRsrq(ThresholdRsrq),
	ThresholdSiNr(ThresholdSiNr),
}

impl M1ThresholdType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::ThresholdRsrp(ThresholdRsrp::decode(data)?)),
			1 => Ok(Self::ThresholdRsrq(ThresholdRsrq::decode(data)?)),
			2 => Ok(Self::ThresholdSiNr(ThresholdSiNr::decode(data)?)),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::ThresholdRsrp(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				x.encode(data)
			}
			Self::ThresholdRsrq(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				x.encode(data)
			}
			Self::ThresholdSiNr(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for M1ThresholdType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M1ThresholdType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ThresholdType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1ThresholdType");
			e
		})
	}
}
// M1PeriodicReporting
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M1PeriodicReporting {
	pub report_interval: ReportIntervalMdt,
	pub report_amount: ReportAmountMdt,
	pub extended_report_interval_mdt: Option<ExtendedReportIntervalMdt>,
}

impl M1PeriodicReporting {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let report_interval = ReportIntervalMdt::decode(data)?;
		let report_amount = ReportAmountMdt::decode(data)?;

		// Process the extension container
		let mut extended_report_interval_mdt: Option<ExtendedReportIntervalMdt> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					285 => {
						extended_report_interval_mdt =
							Some(ExtendedReportIntervalMdt::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			report_interval,
			report_amount,
			extended_report_interval_mdt,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.extended_report_interval_mdt {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 285, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.report_interval.encode(data)?;
		self.report_amount.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M1PeriodicReporting {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M1PeriodicReporting::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1PeriodicReporting");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M1PeriodicReporting");
			e
		})
	}
}
// M4Configuration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M4Configuration {
	pub m4period: M4period,
	pub m4_links_to_log: LinksToLog,
	pub m4_report_amount: Option<M4ReportAmountMdt>,
}

impl M4Configuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let m4period = M4period::decode(data)?;
		let m4_links_to_log = LinksToLog::decode(data)?;

		// Process the extension container
		let mut m4_report_amount: Option<M4ReportAmountMdt> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					336 => m4_report_amount = Some(M4ReportAmountMdt::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			m4period,
			m4_links_to_log,
			m4_report_amount,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.m4_report_amount {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 336, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m4period.encode(data)?;
		self.m4_links_to_log.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M4Configuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M4Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4Configuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4Configuration");
			e
		})
	}
}
// M4ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M4ReportAmountMdt {
	#[default]
	R1,
	R2,
	R4,
	R8,
	R16,
	R32,
	R64,
	Infinity,
}

impl M4ReportAmountMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
	}
}

impl PerCodec for M4ReportAmountMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M4ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4ReportAmountMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4ReportAmountMdt");
			e
		})
	}
}
// M4period
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M4period {
	#[default]
	Ms1024,
	Ms2048,
	Ms5120,
	Ms10240,
	Min1,
}

impl M4period {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
	}
}

impl PerCodec for M4period {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M4period::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4period");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M4period");
			e
		})
	}
}
// M5Configuration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M5Configuration {
	pub m5period: M5period,
	pub m5_links_to_log: LinksToLog,
	pub m5_report_amount: Option<M5ReportAmountMdt>,
}

impl M5Configuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let m5period = M5period::decode(data)?;
		let m5_links_to_log = LinksToLog::decode(data)?;

		// Process the extension container
		let mut m5_report_amount: Option<M5ReportAmountMdt> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					337 => m5_report_amount = Some(M5ReportAmountMdt::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			m5period,
			m5_links_to_log,
			m5_report_amount,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.m5_report_amount {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 337, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m5period.encode(data)?;
		self.m5_links_to_log.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M5Configuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M5Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5Configuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5Configuration");
			e
		})
	}
}
// M5ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M5ReportAmountMdt {
	#[default]
	R1,
	R2,
	R4,
	R8,
	R16,
	R32,
	R64,
	Infinity,
}

impl M5ReportAmountMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
	}
}

impl PerCodec for M5ReportAmountMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M5ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5ReportAmountMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5ReportAmountMdt");
			e
		})
	}
}
// M5period
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M5period {
	#[default]
	Ms1024,
	Ms2048,
	Ms5120,
	Ms10240,
	Min1,
}

impl M5period {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
	}
}

impl PerCodec for M5period {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M5period::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5period");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M5period");
			e
		})
	}
}
// M6Configuration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M6Configuration {
	pub m6report_interval: M6reportInterval,
	pub m6_links_to_log: LinksToLog,
	pub m6_report_amount: Option<M6ReportAmountMdt>,
	pub excess_packet_delay_threshold_configuration:
		Option<ExcessPacketDelayThresholdConfiguration>,
}

impl M6Configuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let m6report_interval = M6reportInterval::decode(data)?;
		let m6_links_to_log = LinksToLog::decode(data)?;

		// Process the extension container
		let mut m6_report_amount: Option<M6ReportAmountMdt> = None;
		let mut excess_packet_delay_threshold_configuration: Option<
			ExcessPacketDelayThresholdConfiguration,
		> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					338 => m6_report_amount = Some(M6ReportAmountMdt::decode(data)?),
					341 => {
						excess_packet_delay_threshold_configuration =
							Some(ExcessPacketDelayThresholdConfiguration::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			m6report_interval,
			m6_links_to_log,
			m6_report_amount,
			excess_packet_delay_threshold_configuration,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.m6_report_amount {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 338, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.excess_packet_delay_threshold_configuration {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 341, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m6report_interval.encode(data)?;
		self.m6_links_to_log.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M6Configuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M6Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6Configuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6Configuration");
			e
		})
	}
}
// M6ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M6ReportAmountMdt {
	#[default]
	R1,
	R2,
	R4,
	R8,
	R16,
	R32,
	R64,
	Infinity,
}

impl M6ReportAmountMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
	}
}

impl PerCodec for M6ReportAmountMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M6ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6ReportAmountMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6ReportAmountMdt");
			e
		})
	}
}
// M6reportInterval
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M6reportInterval {
	#[default]
	Ms120,
	Ms240,
	Ms480,
	Ms640,
	Ms1024,
	Ms2048,
	Ms5120,
	Ms10240,
	Ms20480,
	Ms40960,
	Min1,
	Min6,
	Min12,
	Min30,
}

impl M6reportInterval {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
	}
}

impl PerCodec for M6reportInterval {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M6reportInterval::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6reportInterval");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M6reportInterval");
			e
		})
	}
}
// M7Configuration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct M7Configuration {
	pub m7period: M7period,
	pub m7_links_to_log: LinksToLog,
	pub m7_report_amount: Option<M7ReportAmountMdt>,
}

impl M7Configuration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let m7period = M7period::decode(data)?;
		let m7_links_to_log = LinksToLog::decode(data)?;

		// Process the extension container
		let mut m7_report_amount: Option<M7ReportAmountMdt> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					339 => m7_report_amount = Some(M7ReportAmountMdt::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			m7period,
			m7_links_to_log,
			m7_report_amount,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.m7_report_amount {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 339, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.m7period.encode(data)?;
		self.m7_links_to_log.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for M7Configuration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M7Configuration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7Configuration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7Configuration");
			e
		})
	}
}
// M7ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum M7ReportAmountMdt {
	#[default]
	R1,
	R2,
	R4,
	R8,
	R16,
	R32,
	R64,
	Infinity,
}

impl M7ReportAmountMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
	}
}

impl PerCodec for M7ReportAmountMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M7ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7ReportAmountMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7ReportAmountMdt");
			e
		})
	}
}
// M7period
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct M7period(pub u8);

impl M7period {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(60), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(60), true, self.0 as i128, false)
	}
}

impl PerCodec for M7period {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		M7period::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7period");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("M7period");
			e
		})
	}
}
// MdtLocationInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct MdtLocationInfo {
	pub mdt_location_information: MdtLocationInformation,
}

impl MdtLocationInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let mdt_location_information = MdtLocationInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			mdt_location_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.mdt_location_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for MdtLocationInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtLocationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtLocationInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtLocationInfo");
			e
		})
	}
}
// MdtLocationInformation
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct MdtLocationInformation(pub BitString);

impl MdtLocationInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for MdtLocationInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		MdtLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtLocationInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("MdtLocationInformation");
			e
		})
	}
}
// N3IwfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum N3IwfId {
	#[default]
	N3IwfId(BitString),
}

impl N3IwfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::N3IwfId(decode::decode_bitstring(
				data,
				Some(16),
				Some(16),
				false,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::N3IwfId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(16), Some(16), false, &x, false)
			}
		}
	}
}

impl PerCodec for N3IwfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		N3IwfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("N3IwfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("N3IwfId");
			e
		})
	}
}
// NasPdu
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NasPdu(pub Vec<u8>);

impl NasPdu {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for NasPdu {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NasPdu::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NasPdu");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NasPdu");
			e
		})
	}
}
// NasSecurityParametersFromNgran
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NasSecurityParametersFromNgran(pub Vec<u8>);

impl NasSecurityParametersFromNgran {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for NasSecurityParametersFromNgran {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NasSecurityParametersFromNgran::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NasSecurityParametersFromNgran");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NasSecurityParametersFromNgran");
			e
		})
	}
}
// NbIotDefaultPagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NbIotDefaultPagingDrx {
	#[default]
	Rf128,
	Rf256,
	Rf512,
	Rf1024,
}

impl NbIotDefaultPagingDrx {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
	}
}

impl PerCodec for NbIotDefaultPagingDrx {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotDefaultPagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotDefaultPagingDrx");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotDefaultPagingDrx");
			e
		})
	}
}
// NbIotPagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NbIotPagingDrx {
	#[default]
	Rf32,
	Rf64,
	Rf128,
	Rf256,
	Rf512,
	Rf1024,
}

impl NbIotPagingDrx {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for NbIotPagingDrx {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotPagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingDrx");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingDrx");
			e
		})
	}
}
// NbIotPagingEDrxCycle
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NbIotPagingEDrxCycle {
	#[default]
	Hf2,
	Hf4,
	Hf6,
	Hf8,
	Hf10,
	Hf12,
	Hf14,
	Hf16,
	Hf32,
	Hf64,
	Hf128,
	Hf256,
	Hf512,
	Hf1024,
}

impl NbIotPagingEDrxCycle {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(13), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(13), true, *self as i128, false)
	}
}

impl PerCodec for NbIotPagingEDrxCycle {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotPagingEDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingEDrxCycle");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingEDrxCycle");
			e
		})
	}
}
// NbIotPagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NbIotPagingTimeWindow {
	#[default]
	S1,
	S2,
	S3,
	S4,
	S5,
	S6,
	S7,
	S8,
	S9,
	S10,
	S11,
	S12,
	S13,
	S14,
	S15,
	S16,
}

impl NbIotPagingTimeWindow {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
	}
}

impl PerCodec for NbIotPagingTimeWindow {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotPagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingTimeWindow");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingTimeWindow");
			e
		})
	}
}
// NbIotPagingEDrxInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NbIotPagingEDrxInfo {
	pub nb_iot_paging_e_drx_cycle: NbIotPagingEDrxCycle,
	pub nb_iot_paging_time_window: Option<NbIotPagingTimeWindow>,
}

impl NbIotPagingEDrxInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let nb_iot_paging_e_drx_cycle = NbIotPagingEDrxCycle::decode(data)?;
		let nb_iot_paging_time_window = if optionals[0] {
			Some(NbIotPagingTimeWindow::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nb_iot_paging_e_drx_cycle,
			nb_iot_paging_time_window,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.nb_iot_paging_time_window.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nb_iot_paging_e_drx_cycle.encode(data)?;
		if let Some(x) = &self.nb_iot_paging_time_window {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NbIotPagingEDrxInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotPagingEDrxInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingEDrxInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotPagingEDrxInfo");
			e
		})
	}
}
// NbIotUePriority
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NbIotUePriority(pub u8);

impl NbIotUePriority {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
	}
}

impl PerCodec for NbIotUePriority {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NbIotUePriority::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotUePriority");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NbIotUePriority");
			e
		})
	}
}
// NetworkInstance
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NetworkInstance(pub u16);

impl NetworkInstance {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(256), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(256), true, self.0 as i128, false)
	}
}

impl PerCodec for NetworkInstance {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NetworkInstance::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NetworkInstance");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NetworkInstance");
			e
		})
	}
}
// NewSecurityContextInd
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NewSecurityContextInd {
	#[default]
	True,
}

impl NewSecurityContextInd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for NewSecurityContextInd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NewSecurityContextInd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NewSecurityContextInd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NewSecurityContextInd");
			e
		})
	}
}
// NextHopChainingCount
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NextHopChainingCount(pub u8);

impl NextHopChainingCount {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(7), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(7), false, self.0 as i128, false)
	}
}

impl PerCodec for NextHopChainingCount {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NextHopChainingCount::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NextHopChainingCount");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NextHopChainingCount");
			e
		})
	}
}
// NextPagingAreaScope
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NextPagingAreaScope {
	#[default]
	Same,
	Changed,
}

impl NextPagingAreaScope {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for NextPagingAreaScope {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NextPagingAreaScope::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NextPagingAreaScope");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NextPagingAreaScope");
			e
		})
	}
}
// NgapieSupportInformationRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgapieSupportInformationRequestList(pub NonEmpty<NgapieSupportInformationRequestItem>);

impl NgapieSupportInformationRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgapieSupportInformationRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NgapieSupportInformationRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapieSupportInformationRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationRequestList");
			e
		})
	}
}
// NgapieSupportInformationRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgapieSupportInformationRequestItem {
	pub ngap_protocol_ie_id: ProtocolIeId,
}

impl NgapieSupportInformationRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngap_protocol_ie_id = ProtocolIeId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngap_protocol_ie_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngap_protocol_ie_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NgapieSupportInformationRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapieSupportInformationRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationRequestItem");
			e
		})
	}
}
// NgapieSupportInformationResponseList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgapieSupportInformationResponseList(pub NonEmpty<NgapieSupportInformationResponseItem>);

impl NgapieSupportInformationResponseList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgapieSupportInformationResponseItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NgapieSupportInformationResponseList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapieSupportInformationResponseList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationResponseList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationResponseList");
			e
		})
	}
}
// NgapieSupportInformationResponseItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgapieSupportInformationResponseItem {
	pub ngap_protocol_ie_id: ProtocolIeId,
	pub ngap_protocol_ie_support_info: NgapProtocolIeSupportInfo,
	pub ngap_protocol_ie_presence_info: NgapProtocolIePresenceInfo,
}

impl NgapieSupportInformationResponseItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngap_protocol_ie_id = ProtocolIeId::decode(data)?;
		let ngap_protocol_ie_support_info = NgapProtocolIeSupportInfo::decode(data)?;
		let ngap_protocol_ie_presence_info = NgapProtocolIePresenceInfo::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngap_protocol_ie_id,
			ngap_protocol_ie_support_info,
			ngap_protocol_ie_presence_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngap_protocol_ie_id.encode(data)?;
		self.ngap_protocol_ie_support_info.encode(data)?;
		self.ngap_protocol_ie_presence_info.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NgapieSupportInformationResponseItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapieSupportInformationResponseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationResponseItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapieSupportInformationResponseItem");
			e
		})
	}
}
// NgEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NgEnbId {
	#[default]
	MacroNgEnbId(BitString),
	ShortMacroNgEnbId(BitString),
	LongMacroNgEnbId(BitString),
}

impl NgEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::MacroNgEnbId(decode::decode_bitstring(
				data,
				Some(20),
				Some(20),
				false,
			)?)),
			1 => Ok(Self::ShortMacroNgEnbId(decode::decode_bitstring(
				data,
				Some(18),
				Some(18),
				false,
			)?)),
			2 => Ok(Self::LongMacroNgEnbId(decode::decode_bitstring(
				data,
				Some(21),
				Some(21),
				false,
			)?)),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::MacroNgEnbId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				encode::encode_bitstring(data, Some(20), Some(20), false, &x, false)
			}
			Self::ShortMacroNgEnbId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				encode::encode_bitstring(data, Some(18), Some(18), false, &x, false)
			}
			Self::LongMacroNgEnbId(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				encode::encode_bitstring(data, Some(21), Some(21), false, &x, false)
			}
		}
	}
}

impl PerCodec for NgEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgEnbId");
			e
		})
	}
}
// NotifySourceNgranNode
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NotifySourceNgranNode {
	#[default]
	NotifySource,
}

impl NotifySourceNgranNode {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for NotifySourceNgranNode {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotifySourceNgranNode::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotifySourceNgranNode");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotifySourceNgranNode");
			e
		})
	}
}
// NgranCgi
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NgranCgi {
	#[default]
	NrCgi(NrCgi),
	EutraCgi(EutraCgi),
}

impl NgranCgi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NrCgi(NrCgi::decode(data)?)),
			1 => Ok(Self::EutraCgi(EutraCgi::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NrCgi(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::EutraCgi(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for NgranCgi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCgi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranCgi");
			e
		})
	}
}
// NgranTnlAssociationToRemoveList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranTnlAssociationToRemoveList(pub NonEmpty<NgranTnlAssociationToRemoveItem>);

impl NgranTnlAssociationToRemoveList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NgranTnlAssociationToRemoveItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NgranTnlAssociationToRemoveList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranTnlAssociationToRemoveList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTnlAssociationToRemoveList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTnlAssociationToRemoveList");
			e
		})
	}
}
// NgranTnlAssociationToRemoveItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NgranTnlAssociationToRemoveItem {
	pub tnl_association_transport_layer_address: CpTransportLayerInformation,
	pub tnl_association_transport_layer_address_amf: Option<CpTransportLayerInformation>,
}

impl NgranTnlAssociationToRemoveItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, false, 2)?;
		let tnl_association_transport_layer_address = CpTransportLayerInformation::decode(data)?;
		let tnl_association_transport_layer_address_amf = if optionals[0] {
			Some(CpTransportLayerInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tnl_association_transport_layer_address,
			tnl_association_transport_layer_address_amf,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.tnl_association_transport_layer_address_amf.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, false, &optionals, false)?;
		self.tnl_association_transport_layer_address.encode(data)?;
		if let Some(x) = &self.tnl_association_transport_layer_address_amf {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NgranTnlAssociationToRemoveItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranTnlAssociationToRemoveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTnlAssociationToRemoveItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTnlAssociationToRemoveItem");
			e
		})
	}
}
// NgranTraceId
#[derive(Clone, Debug)]
pub struct NgranTraceId(pub [u8; 8]);
impl Default for NgranTraceId {
	fn default() -> NgranTraceId {
		let init = std::mem::MaybeUninit::<[u8; 8]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		NgranTraceId(default_value)
	}
}
impl NgranTraceId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(8), Some(8), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(8), Some(8), false, &(self.0).into(), false)
	}
}

impl PerCodec for NgranTraceId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgranTraceId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTraceId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgranTraceId");
			e
		})
	}
}
// Nid
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct Nid(pub BitString);

impl Nid {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(44),
			Some(44),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(44), Some(44), false, &self.0, false)
	}
}

impl PerCodec for Nid {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Nid::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Nid");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Nid");
			e
		})
	}
}
// NonDynamic5qiDescriptor
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NonDynamic5qiDescriptor {
	pub five_qi: FiveQi,
	pub priority_level_qos: Option<PriorityLevelQos>,
	pub averaging_window: Option<AveragingWindow>,
	pub maximum_data_burst_volume: Option<MaximumDataBurstVolume>,
	pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
	pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl NonDynamic5qiDescriptor {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let five_qi = FiveQi::decode(data)?;
		let priority_level_qos = if optionals[0] {
			Some(PriorityLevelQos::decode(data)?)
		} else {
			None
		};
		let averaging_window = if optionals[1] {
			Some(AveragingWindow::decode(data)?)
		} else {
			None
		};
		let maximum_data_burst_volume = if optionals[2] {
			Some(MaximumDataBurstVolume::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
		let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					187 => {
						cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					188 => {
						cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			five_qi,
			priority_level_qos,
			averaging_window,
			maximum_data_burst_volume,
			cn_packet_delay_budget_dl,
			cn_packet_delay_budget_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.cn_packet_delay_budget_dl {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_packet_delay_budget_ul {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.priority_level_qos.is_some());
		optionals.push(self.averaging_window.is_some());
		optionals.push(self.maximum_data_burst_volume.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.five_qi.encode(data)?;
		if let Some(x) = &self.priority_level_qos {
			x.encode(data)?;
		}
		if let Some(x) = &self.averaging_window {
			x.encode(data)?;
		}
		if let Some(x) = &self.maximum_data_burst_volume {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for NonDynamic5qiDescriptor {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NonDynamic5qiDescriptor::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NonDynamic5qiDescriptor");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NonDynamic5qiDescriptor");
			e
		})
	}
}
// NotAllowedTaCs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NotAllowedTaCs(pub NonEmpty<Tac>);

impl NotAllowedTaCs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NotAllowedTaCs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotAllowedTaCs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotAllowedTaCs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotAllowedTaCs");
			e
		})
	}
}
// NotificationCause
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NotificationCause {
	#[default]
	Fulfilled,
	NotFulfilled,
}

impl NotificationCause {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for NotificationCause {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotificationCause::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCause");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationCause");
			e
		})
	}
}
// NotificationControl
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NotificationControl {
	#[default]
	NotificationRequested,
}

impl NotificationControl {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for NotificationControl {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotificationControl::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationControl");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotificationControl");
			e
		})
	}
}
// NpnAccessInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NpnAccessInformation {
	#[default]
	PniNpnAccessInformation(CellCagList),
}

impl NpnAccessInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::PniNpnAccessInformation(CellCagList::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::PniNpnAccessInformation(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for NpnAccessInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NpnAccessInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnAccessInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnAccessInformation");
			e
		})
	}
}
// NpnMobilityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NpnMobilityInformation {
	#[default]
	SnpnMobilityInformation(SnpnMobilityInformation),
	PniNpnMobilityInformation(PniNpnMobilityInformation),
}

impl NpnMobilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::SnpnMobilityInformation(
				SnpnMobilityInformation::decode(data)?,
			)),
			1 => Ok(Self::PniNpnMobilityInformation(
				PniNpnMobilityInformation::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::SnpnMobilityInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::PniNpnMobilityInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for NpnMobilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnMobilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnMobilityInformation");
			e
		})
	}
}
// NpnPagingAssistanceInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NpnPagingAssistanceInformation {
	#[default]
	PniNpnPagingAssistance(AllowedPniNpnList),
}

impl NpnPagingAssistanceInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::PniNpnPagingAssistance(AllowedPniNpnList::decode(
				data,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::PniNpnPagingAssistance(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for NpnPagingAssistanceInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NpnPagingAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnPagingAssistanceInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnPagingAssistanceInformation");
			e
		})
	}
}
// NpnSupport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum NpnSupport {
	#[default]
	Snpn(Nid),
}

impl NpnSupport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Snpn(Nid::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Snpn(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for NpnSupport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NpnSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnSupport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NpnSupport");
			e
		})
	}
}
// NrCellIdentity
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrCellIdentity(pub BitString);

impl NrCellIdentity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(36),
			Some(36),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(36), Some(36), false, &self.0, false)
	}
}

impl PerCodec for NrCellIdentity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrCellIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCellIdentity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCellIdentity");
			e
		})
	}
}
// NrCgi
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrCgi {
	pub plmn_identity: PlmnIdentity,
	pub nr_cell_identity: NrCellIdentity,
}

impl NrCgi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let nr_cell_identity = NrCellIdentity::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			nr_cell_identity,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.nr_cell_identity.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NrCgi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrCgi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgi");
			e
		})
	}
}
// NrCgiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrCgiList(pub NonEmpty<NrCgi>);

impl NrCgiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16384), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16384), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NrCgiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrCgiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgiList");
			e
		})
	}
}
// NrCgiListForWarning
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrCgiListForWarning(pub NonEmpty<NrCgi>);

impl NrCgiListForWarning {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrCgi::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NrCgiListForWarning {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrCgiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgiListForWarning");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrCgiListForWarning");
			e
		})
	}
}
// NrPagingeDrxInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrPagingeDrxInformation {
	pub nr_paging_e_drx_cycle: NrPagingEDrxCycle,
	pub nr_paging_time_window: Option<NrPagingTimeWindow>,
}

impl NrPagingeDrxInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let nr_paging_e_drx_cycle = NrPagingEDrxCycle::decode(data)?;
		let nr_paging_time_window = if optionals[0] {
			Some(NrPagingTimeWindow::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_paging_e_drx_cycle,
			nr_paging_time_window,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.nr_paging_time_window.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_paging_e_drx_cycle.encode(data)?;
		if let Some(x) = &self.nr_paging_time_window {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NrPagingeDrxInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrPagingeDrxInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingeDrxInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingeDrxInformation");
			e
		})
	}
}
// NrPagingEDrxCycle
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NrPagingEDrxCycle {
	#[default]
	Hfquarter,
	Hfhalf,
	Hf1,
	Hf2,
	Hf4,
	Hf8,
	Hf16,
	Hf32,
	Hf64,
	Hf128,
	Hf256,
	Hf512,
	Hf1024,
}

impl NrPagingEDrxCycle {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(12), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(12), true, *self as i128, false)
	}
}

impl PerCodec for NrPagingEDrxCycle {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrPagingEDrxCycle::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingEDrxCycle");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingEDrxCycle");
			e
		})
	}
}
// NrPagingTimeWindow
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NrPagingTimeWindow {
	#[default]
	S1,
	S2,
	S3,
	S4,
	S5,
	S6,
	S7,
	S8,
	S9,
	S10,
	S11,
	S12,
	S13,
	S14,
	S15,
	S16,
}

impl NrPagingTimeWindow {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(15), true, *self as i128, false)
	}
}

impl PerCodec for NrPagingTimeWindow {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrPagingTimeWindow::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingTimeWindow");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPagingTimeWindow");
			e
		})
	}
}
// NrEncryptionAlgorithms
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrEncryptionAlgorithms(pub BitString);

impl NrEncryptionAlgorithms {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
	}
}

impl PerCodec for NrEncryptionAlgorithms {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrEncryptionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrEncryptionAlgorithms");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrEncryptionAlgorithms");
			e
		})
	}
}
// NrIntegrityProtectionAlgorithms
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrIntegrityProtectionAlgorithms(pub BitString);

impl NrIntegrityProtectionAlgorithms {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), true, &self.0, false)
	}
}

impl PerCodec for NrIntegrityProtectionAlgorithms {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrIntegrityProtectionAlgorithms::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrIntegrityProtectionAlgorithms");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrIntegrityProtectionAlgorithms");
			e
		})
	}
}
// NrMobilityHistoryReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrMobilityHistoryReport(pub Vec<u8>);

impl NrMobilityHistoryReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for NrMobilityHistoryReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrMobilityHistoryReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrMobilityHistoryReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrMobilityHistoryReport");
			e
		})
	}
}
// NrPPaPdu
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrPPaPdu(pub Vec<u8>);

impl NrPPaPdu {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for NrPPaPdu {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrPPaPdu::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPPaPdu");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPPaPdu");
			e
		})
	}
}
// NrUeRlfReportContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrUeRlfReportContainer(pub Vec<u8>);

impl NrUeRlfReportContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for NrUeRlfReportContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrUeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrUeRlfReportContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrUeRlfReportContainer");
			e
		})
	}
}
// NrNtntaiInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrNtntaiInformation {
	pub serving_plmn: PlmnIdentity,
	pub tac_list_in_nr_ntn: TacListInNrNtn,
	pub ue_location_derived_tac_in_nr_ntn: Option<Tac>,
}

impl NrNtntaiInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let serving_plmn = PlmnIdentity::decode(data)?;
		let tac_list_in_nr_ntn = TacListInNrNtn::decode(data)?;
		let ue_location_derived_tac_in_nr_ntn = if optionals[0] {
			Some(Tac::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			serving_plmn,
			tac_list_in_nr_ntn,
			ue_location_derived_tac_in_nr_ntn,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ue_location_derived_tac_in_nr_ntn.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.serving_plmn.encode(data)?;
		self.tac_list_in_nr_ntn.encode(data)?;
		if let Some(x) = &self.ue_location_derived_tac_in_nr_ntn {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NrNtntaiInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrNtntaiInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrNtntaiInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrNtntaiInformation");
			e
		})
	}
}
// NumberOfBroadcasts
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NumberOfBroadcasts(pub u16);

impl NumberOfBroadcasts {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
	}
}

impl PerCodec for NumberOfBroadcasts {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NumberOfBroadcasts::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfBroadcasts");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfBroadcasts");
			e
		})
	}
}
// NumberOfBroadcastsRequested
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NumberOfBroadcastsRequested(pub u16);

impl NumberOfBroadcastsRequested {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(65535), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(65535), false, self.0 as i128, false)
	}
}

impl PerCodec for NumberOfBroadcastsRequested {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NumberOfBroadcastsRequested::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfBroadcastsRequested");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NumberOfBroadcastsRequested");
			e
		})
	}
}
// NrArfcn
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrArfcn(pub u32);

impl NrArfcn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(3279165), false)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(3279165), false, self.0 as i128, false)
	}
}

impl PerCodec for NrArfcn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrArfcn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrArfcn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrArfcn");
			e
		})
	}
}
// NrFrequencyBand
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrFrequencyBand(pub u16);

impl NrFrequencyBand {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(1024), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(1024), true, self.0 as i128, false)
	}
}

impl PerCodec for NrFrequencyBand {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrFrequencyBand::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBand");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBand");
			e
		})
	}
}
// NrFrequencyBandList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrFrequencyBandList(pub NonEmpty<NrFrequencyBandItem>);

impl NrFrequencyBandList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrFrequencyBandItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for NrFrequencyBandList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrFrequencyBandList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBandList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBandList");
			e
		})
	}
}
// NrFrequencyBandItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrFrequencyBandItem {
	pub nr_frequency_band: NrFrequencyBand,
}

impl NrFrequencyBandItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_frequency_band = NrFrequencyBand::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { nr_frequency_band })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_frequency_band.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NrFrequencyBandItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrFrequencyBandItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBandItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyBandItem");
			e
		})
	}
}
// NrFrequencyInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrFrequencyInfo {
	pub nr_arfcn: NrArfcn,
	pub frequency_band_list: NrFrequencyBandList,
}

impl NrFrequencyInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_arfcn = NrArfcn::decode(data)?;
		let frequency_band_list = NrFrequencyBandList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_arfcn,
			frequency_band_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_arfcn.encode(data)?;
		self.frequency_band_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NrFrequencyInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrFrequencyInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrFrequencyInfo");
			e
		})
	}
}
// NrPci
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NrPci(pub u16);

impl NrPci {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(1007), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(1007), true, self.0 as i128, false)
	}
}

impl PerCodec for NrPci {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrPci::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPci");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrPci");
			e
		})
	}
}
// NrV2xServicesAuthorized
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrV2xServicesAuthorized {
	pub vehicle_ue: Option<VehicleUe>,
	pub pedestrian_ue: Option<PedestrianUe>,
}

impl NrV2xServicesAuthorized {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let vehicle_ue = if optionals[0] {
			Some(VehicleUe::decode(data)?)
		} else {
			None
		};
		let pedestrian_ue = if optionals[1] {
			Some(PedestrianUe::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			vehicle_ue,
			pedestrian_ue,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.vehicle_ue.is_some());
		optionals.push(self.pedestrian_ue.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.vehicle_ue {
			x.encode(data)?;
		}
		if let Some(x) = &self.pedestrian_ue {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for NrV2xServicesAuthorized {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrV2xServicesAuthorized::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrV2xServicesAuthorized");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrV2xServicesAuthorized");
			e
		})
	}
}
// VehicleUe
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum VehicleUe {
	#[default]
	Authorized,
	NotAuthorized,
}

impl VehicleUe {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for VehicleUe {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		VehicleUe::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VehicleUe");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VehicleUe");
			e
		})
	}
}
// PedestrianUe
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PedestrianUe {
	#[default]
	Authorized,
	NotAuthorized,
}

impl PedestrianUe {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PedestrianUe {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PedestrianUe::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PedestrianUe");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PedestrianUe");
			e
		})
	}
}
// NrUeSidelinkAggregateMaximumBitrate
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct NrUeSidelinkAggregateMaximumBitrate {
	pub ue_sidelink_aggregate_maximum_bit_rate: BitRate,
}

impl NrUeSidelinkAggregateMaximumBitrate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_sidelink_aggregate_maximum_bit_rate = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_sidelink_aggregate_maximum_bit_rate,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_sidelink_aggregate_maximum_bit_rate.encode(data)?;

		Ok(())
	}
}

impl PerCodec for NrUeSidelinkAggregateMaximumBitrate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NrUeSidelinkAggregateMaximumBitrate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrUeSidelinkAggregateMaximumBitrate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NrUeSidelinkAggregateMaximumBitrate");
			e
		})
	}
}
// NsagId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct NsagId(pub u8);

impl NsagId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
	}
}

impl PerCodec for NsagId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NsagId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NsagId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NsagId");
			e
		})
	}
}
// OnboardingSupport
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum OnboardingSupport {
	#[default]
	True,
}

impl OnboardingSupport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for OnboardingSupport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OnboardingSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OnboardingSupport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OnboardingSupport");
			e
		})
	}
}
// OverloadAction
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum OverloadAction {
	#[default]
	RejectNonEmergencyMoDt,
	RejectRrcCrSignalling,
	PermitEmergencySessionsAndMobileTerminatedServicesOnly,
	PermitHighPrioritySessionsAndMobileTerminatedServicesOnly,
}

impl OverloadAction {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
	}
}

impl PerCodec for OverloadAction {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OverloadAction::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadAction");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadAction");
			e
		})
	}
}
// OverloadResponse
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum OverloadResponse {
	#[default]
	OverloadAction(OverloadAction),
}

impl OverloadResponse {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::OverloadAction(OverloadAction::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::OverloadAction(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for OverloadResponse {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OverloadResponse::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadResponse");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadResponse");
			e
		})
	}
}
// OverloadStartNssaiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct OverloadStartNssaiList(pub NonEmpty<OverloadStartNssaiItem>);

impl OverloadStartNssaiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(OverloadStartNssaiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for OverloadStartNssaiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OverloadStartNssaiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadStartNssaiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadStartNssaiList");
			e
		})
	}
}
// OverloadStartNssaiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct OverloadStartNssaiItem {
	pub slice_overload_list: SliceOverloadList,
	pub slice_overload_response: Option<OverloadResponse>,
	pub slice_traffic_load_reduction_indication: Option<TrafficLoadReductionIndication>,
}

impl OverloadStartNssaiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let slice_overload_list = SliceOverloadList::decode(data)?;
		let slice_overload_response = if optionals[0] {
			Some(OverloadResponse::decode(data)?)
		} else {
			None
		};
		let slice_traffic_load_reduction_indication = if optionals[1] {
			Some(TrafficLoadReductionIndication::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			slice_overload_list,
			slice_overload_response,
			slice_traffic_load_reduction_indication,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.slice_overload_response.is_some());
		optionals.push(self.slice_traffic_load_reduction_indication.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.slice_overload_list.encode(data)?;
		if let Some(x) = &self.slice_overload_response {
			x.encode(data)?;
		}
		if let Some(x) = &self.slice_traffic_load_reduction_indication {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for OverloadStartNssaiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OverloadStartNssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadStartNssaiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OverloadStartNssaiItem");
			e
		})
	}
}
// PacketDelayBudget
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PacketDelayBudget(pub u16);

impl PacketDelayBudget {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(1023), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(1023), true, self.0 as i128, false)
	}
}

impl PerCodec for PacketDelayBudget {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PacketDelayBudget::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketDelayBudget");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketDelayBudget");
			e
		})
	}
}
// PacketErrorRate
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PacketErrorRate {
	pub per_scalar: u8,
	pub per_exponent: u8,
}

impl PacketErrorRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let per_scalar = decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8;
		let per_exponent = decode::decode_integer(data, Some(0), Some(9), true)?.0 as u8;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			per_scalar,
			per_exponent,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_integer(data, Some(0), Some(9), true, self.per_scalar as i128, false)?;
		encode::encode_integer(
			data,
			Some(0),
			Some(9),
			true,
			self.per_exponent as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PacketErrorRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PacketErrorRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketErrorRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketErrorRate");
			e
		})
	}
}
// PacketLossRate
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PacketLossRate(pub u16);

impl PacketLossRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(1000), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(1000), true, self.0 as i128, false)
	}
}

impl PerCodec for PacketLossRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PacketLossRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketLossRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PacketLossRate");
			e
		})
	}
}
// PagingAssisDataforCEcapabUe
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PagingAssisDataforCEcapabUe {
	pub eutra_cgi: EutraCgi,
	pub coverage_enhancement_level: CoverageEnhancementLevel,
}

impl PagingAssisDataforCEcapabUe {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let eutra_cgi = EutraCgi::decode(data)?;
		let coverage_enhancement_level = CoverageEnhancementLevel::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_cgi,
			coverage_enhancement_level,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;
		self.coverage_enhancement_level.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PagingAssisDataforCEcapabUe {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingAssisDataforCEcapabUe::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAssisDataforCEcapabUe");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAssisDataforCEcapabUe");
			e
		})
	}
}
// PagingAttemptInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PagingAttemptInformation {
	pub paging_attempt_count: PagingAttemptCount,
	pub intended_number_of_paging_attempts: IntendedNumberOfPagingAttempts,
	pub next_paging_area_scope: Option<NextPagingAreaScope>,
}

impl PagingAttemptInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let paging_attempt_count = PagingAttemptCount::decode(data)?;
		let intended_number_of_paging_attempts = IntendedNumberOfPagingAttempts::decode(data)?;
		let next_paging_area_scope = if optionals[0] {
			Some(NextPagingAreaScope::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			paging_attempt_count,
			intended_number_of_paging_attempts,
			next_paging_area_scope,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.next_paging_area_scope.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.paging_attempt_count.encode(data)?;
		self.intended_number_of_paging_attempts.encode(data)?;
		if let Some(x) = &self.next_paging_area_scope {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for PagingAttemptInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingAttemptInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAttemptInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAttemptInformation");
			e
		})
	}
}
// PagingAttemptCount
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PagingAttemptCount(pub u8);

impl PagingAttemptCount {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(16), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(16), true, self.0 as i128, false)
	}
}

impl PerCodec for PagingAttemptCount {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingAttemptCount::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAttemptCount");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingAttemptCount");
			e
		})
	}
}
// PagingCause
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingCause {
	#[default]
	Voice,
}

impl PagingCause {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for PagingCause {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingCause::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingCause");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingCause");
			e
		})
	}
}
// PagingCauseIndicationForVoiceService
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingCauseIndicationForVoiceService {
	#[default]
	Supported,
}

impl PagingCauseIndicationForVoiceService {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for PagingCauseIndicationForVoiceService {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingCauseIndicationForVoiceService::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingCauseIndicationForVoiceService");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingCauseIndicationForVoiceService");
			e
		})
	}
}
// PagingDrx
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingDrx {
	#[default]
	V32,
	V64,
	V128,
	V256,
}

impl PagingDrx {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(3), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(3), true, *self as i128, false)
	}
}

impl PerCodec for PagingDrx {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingDrx::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingDrx");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingDrx");
			e
		})
	}
}
// PagingOrigin
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingOrigin {
	#[default]
	Non3gpp,
}

impl PagingOrigin {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for PagingOrigin {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingOrigin::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingOrigin");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingOrigin");
			e
		})
	}
}
// PagingPriority
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingPriority {
	#[default]
	Priolevel1,
	Priolevel2,
	Priolevel3,
	Priolevel4,
	Priolevel5,
	Priolevel6,
	Priolevel7,
	Priolevel8,
}

impl PagingPriority {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), true, *self as i128, false)
	}
}

impl PerCodec for PagingPriority {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingPriority");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingPriority");
			e
		})
	}
}
// PagingProbabilityInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PagingProbabilityInformation {
	#[default]
	P00,
	P05,
	P10,
	P15,
	P20,
	P25,
	P30,
	P35,
	P40,
	P45,
	P50,
	P55,
	P60,
	P65,
	P70,
	P75,
	P80,
	P85,
	P90,
	P95,
	P100,
}

impl PagingProbabilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(20), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(20), true, *self as i128, false)
	}
}

impl PerCodec for PagingProbabilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PagingProbabilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingProbabilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PagingProbabilityInformation");
			e
		})
	}
}
// PathSwitchRequestAcknowledgeTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PathSwitchRequestAcknowledgeTransfer {
	pub ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub security_indication: Option<SecurityIndication>,
	pub additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
	pub qos_flow_parameters_list: Option<QosFlowParametersList>,
}

impl PathSwitchRequestAcknowledgeTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let ul_ngu_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let security_indication = if optionals[1] {
			Some(SecurityIndication::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList> =
			None;
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_redundant_ngu_up_tnl_information: Option<
			UpTransportLayerInformationPairList,
		> = None;
		let mut qos_flow_parameters_list: Option<QosFlowParametersList> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					154 => {
						additional_ngu_up_tnl_information =
							Some(UpTransportLayerInformationPairList::decode(data)?)
					}
					195 => {
						redundant_ul_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					185 => {
						additional_redundant_ngu_up_tnl_information =
							Some(UpTransportLayerInformationPairList::decode(data)?)
					}
					277 => qos_flow_parameters_list = Some(QosFlowParametersList::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_ngu_up_tnl_information,
			security_indication,
			additional_ngu_up_tnl_information,
			redundant_ul_ngu_up_tnl_information,
			additional_redundant_ngu_up_tnl_information,
			qos_flow_parameters_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 154, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_flow_parameters_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 277, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.ul_ngu_up_tnl_information.is_some());
		optionals.push(self.security_indication.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.ul_ngu_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.security_indication {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PathSwitchRequestAcknowledgeTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PathSwitchRequestAcknowledgeTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestAcknowledgeTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestAcknowledgeTransfer");
			e
		})
	}
}
// PathSwitchRequestSetupFailedTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PathSwitchRequestSetupFailedTransfer {
	pub cause: Cause,
}

impl PathSwitchRequestSetupFailedTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cause })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PathSwitchRequestSetupFailedTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PathSwitchRequestSetupFailedTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestSetupFailedTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestSetupFailedTransfer");
			e
		})
	}
}
// PathSwitchRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PathSwitchRequestTransfer {
	pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
	pub dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused>,
	pub user_plane_security_information: Option<UserPlaneSecurityInformation>,
	pub qos_flow_accepted_list: QosFlowAcceptedList,
	pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub redundant_dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused>,
	pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub used_rsn_information: Option<RedundantPduSessionInformation>,
	pub global_ran_node_id: Option<GlobalRanNodeId>,
	pub mbs_support_indicator: Option<MbsSupportIndicator>,
}

impl PathSwitchRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let dl_ngu_tnl_information_reused = if optionals[0] {
			Some(DlNguTnlInformationReused::decode(data)?)
		} else {
			None
		};
		let user_plane_security_information = if optionals[1] {
			Some(UserPlaneSecurityInformation::decode(data)?)
		} else {
			None
		};
		let qos_flow_accepted_list = QosFlowAcceptedList::decode(data)?;

		// Process the extension container
		let mut additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList> =
			None;
		let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut redundant_dl_ngu_tnl_information_reused: Option<DlNguTnlInformationReused> = None;
		let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
			QosFlowPerTnlInformationList,
		> = None;
		let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
		let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
		let mut mbs_support_indicator: Option<MbsSupportIndicator> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					155 => {
						additional_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					192 => {
						redundant_dl_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					191 => {
						redundant_dl_ngu_tnl_information_reused =
							Some(DlNguTnlInformationReused::decode(data)?)
					}
					184 => {
						additional_redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					198 => {
						used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
					}
					27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
					309 => mbs_support_indicator = Some(MbsSupportIndicator::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_ngu_up_tnl_information,
			dl_ngu_tnl_information_reused,
			user_plane_security_information,
			qos_flow_accepted_list,
			additional_dl_qos_flow_per_tnl_information,
			redundant_dl_ngu_up_tnl_information,
			redundant_dl_ngu_tnl_information_reused,
			additional_redundant_dl_qos_flow_per_tnl_information,
			used_rsn_information,
			global_ran_node_id,
			mbs_support_indicator,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 155, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_ngu_tnl_information_reused {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 191, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.used_rsn_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.global_ran_node_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_support_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_ngu_tnl_information_reused.is_some());
		optionals.push(self.user_plane_security_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_ngu_up_tnl_information.encode(data)?;
		if let Some(x) = &self.dl_ngu_tnl_information_reused {
			x.encode(data)?;
		}
		if let Some(x) = &self.user_plane_security_information {
			x.encode(data)?;
		}
		self.qos_flow_accepted_list.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PathSwitchRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PathSwitchRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestTransfer");
			e
		})
	}
}
// PathSwitchRequestUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PathSwitchRequestUnsuccessfulTransfer {
	pub cause: Cause,
}

impl PathSwitchRequestUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cause })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PathSwitchRequestUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PathSwitchRequestUnsuccessfulTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestUnsuccessfulTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PathSwitchRequestUnsuccessfulTransfer");
			e
		})
	}
}
// Pc5QosParameters
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Pc5QosParameters {
	pub pc_5_qos_flow_list: Pc5QosFlowList,
	pub pc_5_link_aggregate_bit_rates: Option<BitRate>,
}

impl Pc5QosParameters {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let pc_5_qos_flow_list = Pc5QosFlowList::decode(data)?;
		let pc_5_link_aggregate_bit_rates = if optionals[0] {
			Some(BitRate::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pc_5_qos_flow_list,
			pc_5_link_aggregate_bit_rates,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.pc_5_link_aggregate_bit_rates.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pc_5_qos_flow_list.encode(data)?;
		if let Some(x) = &self.pc_5_link_aggregate_bit_rates {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for Pc5QosParameters {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Pc5QosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosParameters");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosParameters");
			e
		})
	}
}
// Pc5QosFlowList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Pc5QosFlowList(pub NonEmpty<Pc5QosFlowItem>);

impl Pc5QosFlowList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Pc5QosFlowItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for Pc5QosFlowList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Pc5QosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosFlowList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosFlowList");
			e
		})
	}
}
// Pc5QosFlowItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Pc5QosFlowItem {
	pub pqi: FiveQi,
	pub pc_5_flow_bit_rates: Option<Pc5FlowBitRates>,
	pub range: Option<Range>,
}

impl Pc5QosFlowItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let pqi = FiveQi::decode(data)?;
		let pc_5_flow_bit_rates = if optionals[0] {
			Some(Pc5FlowBitRates::decode(data)?)
		} else {
			None
		};
		let range = if optionals[1] {
			Some(Range::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pqi,
			pc_5_flow_bit_rates,
			range,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.pc_5_flow_bit_rates.is_some());
		optionals.push(self.range.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pqi.encode(data)?;
		if let Some(x) = &self.pc_5_flow_bit_rates {
			x.encode(data)?;
		}
		if let Some(x) = &self.range {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for Pc5QosFlowItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Pc5QosFlowItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosFlowItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5QosFlowItem");
			e
		})
	}
}
// Pc5FlowBitRates
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Pc5FlowBitRates {
	pub guaranteed_flow_bit_rate: BitRate,
	pub maximum_flow_bit_rate: BitRate,
}

impl Pc5FlowBitRates {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let guaranteed_flow_bit_rate = BitRate::decode(data)?;
		let maximum_flow_bit_rate = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			guaranteed_flow_bit_rate,
			maximum_flow_bit_rate,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.guaranteed_flow_bit_rate.encode(data)?;
		self.maximum_flow_bit_rate.encode(data)?;

		Ok(())
	}
}

impl PerCodec for Pc5FlowBitRates {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Pc5FlowBitRates::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5FlowBitRates");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Pc5FlowBitRates");
			e
		})
	}
}
// PciListForMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PciListForMdt(pub NonEmpty<NrPci>);

impl PciListForMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(NrPci::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PciListForMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PciListForMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PciListForMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PciListForMdt");
			e
		})
	}
}
// PrivacyIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PrivacyIndicator {
	#[default]
	ImmediateMdt,
	LoggedMdt,
}

impl PrivacyIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PrivacyIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PrivacyIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PrivacyIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PrivacyIndicator");
			e
		})
	}
}
// PduSessionAggregateMaximumBitRate
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionAggregateMaximumBitRate {
	pub pdu_session_aggregate_maximum_bit_rate_dl: BitRate,
	pub pdu_session_aggregate_maximum_bit_rate_ul: BitRate,
}

impl PduSessionAggregateMaximumBitRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_aggregate_maximum_bit_rate_dl = BitRate::decode(data)?;
		let pdu_session_aggregate_maximum_bit_rate_ul = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_aggregate_maximum_bit_rate_dl,
			pdu_session_aggregate_maximum_bit_rate_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_aggregate_maximum_bit_rate_dl
			.encode(data)?;
		self.pdu_session_aggregate_maximum_bit_rate_ul
			.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionAggregateMaximumBitRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionAggregateMaximumBitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionAggregateMaximumBitRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionAggregateMaximumBitRate");
			e
		})
	}
}
// PduSessionPairId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PduSessionPairId(pub u8);

impl PduSessionPairId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), true, self.0 as i128, false)
	}
}

impl PerCodec for PduSessionPairId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionPairId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionPairId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionPairId");
			e
		})
	}
}
// PduSessionResourceAdmittedList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceAdmittedList(pub NonEmpty<PduSessionResourceAdmittedItem>);

impl PduSessionResourceAdmittedList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceAdmittedItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceAdmittedList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceAdmittedList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceAdmittedList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceAdmittedList");
			e
		})
	}
}
// PduSessionResourceAdmittedItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceAdmittedItem {
	pub pdu_session_id: PduSessionId,
	pub handover_request_acknowledge_transfer: Vec<u8>,
}

impl PduSessionResourceAdmittedItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let handover_request_acknowledge_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			handover_request_acknowledge_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_request_acknowledge_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceAdmittedItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceAdmittedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceAdmittedItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceAdmittedItem");
			e
		})
	}
}
// PduSessionResourceFailedToModifyListModCfm
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToModifyListModCfm(
	pub NonEmpty<PduSessionResourceFailedToModifyItemModCfm>,
);

impl PduSessionResourceFailedToModifyListModCfm {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToModifyItemModCfm::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToModifyListModCfm {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToModifyListModCfm::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToModifyListModCfm");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToModifyListModCfm");
			e
		})
	}
}
// PduSessionResourceFailedToModifyItemModCfm
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToModifyItemModCfm {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_modify_indication_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToModifyItemModCfm {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_modify_indication_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_modify_indication_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_indication_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToModifyItemModCfm {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToModifyItemModCfm::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToModifyItemModCfm");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToModifyItemModCfm");
			e
		})
	}
}
// PduSessionResourceFailedToModifyListModRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToModifyListModRes(
	pub NonEmpty<PduSessionResourceFailedToModifyItemModRes>,
);

impl PduSessionResourceFailedToModifyListModRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToModifyItemModRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToModifyListModRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToModifyListModRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToModifyListModRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToModifyListModRes");
			e
		})
	}
}
// PduSessionResourceFailedToModifyItemModRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToModifyItemModRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_modify_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToModifyItemModRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_modify_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_modify_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToModifyItemModRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToModifyItemModRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToModifyItemModRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToModifyItemModRes");
			e
		})
	}
}
// PduSessionResourceFailedToResumeListResReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToResumeListResReq(
	pub NonEmpty<PduSessionResourceFailedToResumeItemResReq>,
);

impl PduSessionResourceFailedToResumeListResReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToResumeItemResReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToResumeListResReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToResumeListResReq::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToResumeListResReq");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToResumeListResReq");
			e
		})
	}
}
// PduSessionResourceFailedToResumeItemResReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToResumeItemResReq {
	pub pdu_session_id: PduSessionId,
	pub cause: Cause,
}

impl PduSessionResourceFailedToResumeItemResReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToResumeItemResReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToResumeItemResReq::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToResumeItemResReq");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToResumeItemResReq");
			e
		})
	}
}
// PduSessionResourceFailedToResumeListResRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToResumeListResRes(
	pub NonEmpty<PduSessionResourceFailedToResumeItemResRes>,
);

impl PduSessionResourceFailedToResumeListResRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToResumeItemResRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToResumeListResRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToResumeListResRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToResumeListResRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToResumeListResRes");
			e
		})
	}
}
// PduSessionResourceFailedToResumeItemResRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToResumeItemResRes {
	pub pdu_session_id: PduSessionId,
	pub cause: Cause,
}

impl PduSessionResourceFailedToResumeItemResRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToResumeItemResRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToResumeItemResRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToResumeItemResRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToResumeItemResRes");
			e
		})
	}
}
// PduSessionResourceFailedToSetupListCxtFail
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupListCxtFail(
	pub NonEmpty<PduSessionResourceFailedToSetupItemCxtFail>,
);

impl PduSessionResourceFailedToSetupListCxtFail {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToSetupItemCxtFail::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupListCxtFail {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupListCxtFail::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupListCxtFail");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupListCxtFail");
			e
		})
	}
}
// PduSessionResourceFailedToSetupItemCxtFail
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupItemCxtFail {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemCxtFail {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_setup_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_setup_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupItemCxtFail {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupItemCxtFail::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupItemCxtFail");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupItemCxtFail");
			e
		})
	}
}
// PduSessionResourceFailedToSetupListCxtRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupListCxtRes(
	pub NonEmpty<PduSessionResourceFailedToSetupItemCxtRes>,
);

impl PduSessionResourceFailedToSetupListCxtRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToSetupItemCxtRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupListCxtRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupListCxtRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupListCxtRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupListCxtRes");
			e
		})
	}
}
// PduSessionResourceFailedToSetupItemCxtRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupItemCxtRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemCxtRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_setup_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_setup_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupItemCxtRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupItemCxtRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupItemCxtRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupItemCxtRes");
			e
		})
	}
}
// PduSessionResourceFailedToSetupListHoAck
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupListHoAck(
	pub NonEmpty<PduSessionResourceFailedToSetupItemHoAck>,
);

impl PduSessionResourceFailedToSetupListHoAck {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToSetupItemHoAck::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupListHoAck {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupListHoAck::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupListHoAck");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupListHoAck");
			e
		})
	}
}
// PduSessionResourceFailedToSetupItemHoAck
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupItemHoAck {
	pub pdu_session_id: PduSessionId,
	pub handover_resource_allocation_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemHoAck {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let handover_resource_allocation_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			handover_resource_allocation_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_resource_allocation_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupItemHoAck {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupItemHoAck::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupItemHoAck");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupItemHoAck");
			e
		})
	}
}
// PduSessionResourceFailedToSetupListPsReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupListPsReq(
	pub NonEmpty<PduSessionResourceFailedToSetupItemPsReq>,
);

impl PduSessionResourceFailedToSetupListPsReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToSetupItemPsReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupListPsReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupListPsReq::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupListPsReq");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupListPsReq");
			e
		})
	}
}
// PduSessionResourceFailedToSetupItemPsReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupItemPsReq {
	pub pdu_session_id: PduSessionId,
	pub path_switch_request_setup_failed_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemPsReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let path_switch_request_setup_failed_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			path_switch_request_setup_failed_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.path_switch_request_setup_failed_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupItemPsReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupItemPsReq::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupItemPsReq");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupItemPsReq");
			e
		})
	}
}
// PduSessionResourceFailedToSetupListSuRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupListSuRes(
	pub NonEmpty<PduSessionResourceFailedToSetupItemSuRes>,
);

impl PduSessionResourceFailedToSetupListSuRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceFailedToSetupItemSuRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupListSuRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupListSuRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupListSuRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupListSuRes");
			e
		})
	}
}
// PduSessionResourceFailedToSetupItemSuRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceFailedToSetupItemSuRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_setup_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceFailedToSetupItemSuRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_setup_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_setup_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceFailedToSetupItemSuRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceFailedToSetupItemSuRes::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceFailedToSetupItemSuRes");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceFailedToSetupItemSuRes");
			e
		})
	}
}
// PduSessionResourceHandoverList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceHandoverList(pub NonEmpty<PduSessionResourceHandoverItem>);

impl PduSessionResourceHandoverList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceHandoverItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceHandoverList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceHandoverList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceHandoverList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceHandoverList");
			e
		})
	}
}
// PduSessionResourceHandoverItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceHandoverItem {
	pub pdu_session_id: PduSessionId,
	pub handover_command_transfer: Vec<u8>,
}

impl PduSessionResourceHandoverItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let handover_command_transfer = decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			handover_command_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_command_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceHandoverItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceHandoverItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceHandoverItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceHandoverItem");
			e
		})
	}
}
// PduSessionResourceInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceInformationList(pub NonEmpty<PduSessionResourceInformationItem>);

impl PduSessionResourceInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceInformationList");
			e
		})
	}
}
// PduSessionResourceInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceInformationItem {
	pub pdu_session_id: PduSessionId,
	pub qos_flow_information_list: QosFlowInformationList,
	pub drbs_to_qos_flows_mapping_list: Option<DrbsToQosFlowsMappingList>,
}

impl PduSessionResourceInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let qos_flow_information_list = QosFlowInformationList::decode(data)?;
		let drbs_to_qos_flows_mapping_list = if optionals[0] {
			Some(DrbsToQosFlowsMappingList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			qos_flow_information_list,
			drbs_to_qos_flows_mapping_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.drbs_to_qos_flows_mapping_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		self.qos_flow_information_list.encode(data)?;
		if let Some(x) = &self.drbs_to_qos_flows_mapping_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for PduSessionResourceInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceInformationItem");
			e
		})
	}
}
// PduSessionResourceListCxtRelCpl
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceListCxtRelCpl(pub NonEmpty<PduSessionResourceItemCxtRelCpl>);

impl PduSessionResourceListCxtRelCpl {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceItemCxtRelCpl::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceListCxtRelCpl {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceListCxtRelCpl::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListCxtRelCpl");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListCxtRelCpl");
			e
		})
	}
}
// PduSessionResourceItemCxtRelCpl
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceItemCxtRelCpl {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_release_response_transfer: Option<Vec<u8>>,
}

impl PduSessionResourceItemCxtRelCpl {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;

		// Process the extension container
		let mut pdu_session_resource_release_response_transfer: Option<Vec<u8>> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					145 => {
						pdu_session_resource_release_response_transfer =
							Some(decode::decode_octetstring(data, None, None, false)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_release_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_resource_release_response_transfer {
			let ie = &mut Allocator::new_codec_data();
			encode::encode_octetstring(ie, None, None, false, &x, false)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 145, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceItemCxtRelCpl {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceItemCxtRelCpl::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemCxtRelCpl");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemCxtRelCpl");
			e
		})
	}
}
// PduSessionResourceListCxtRelReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceListCxtRelReq(pub NonEmpty<PduSessionResourceItemCxtRelReq>);

impl PduSessionResourceListCxtRelReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceItemCxtRelReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceListCxtRelReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceListCxtRelReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListCxtRelReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListCxtRelReq");
			e
		})
	}
}
// PduSessionResourceItemCxtRelReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceItemCxtRelReq {
	pub pdu_session_id: PduSessionId,
}

impl PduSessionResourceItemCxtRelReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { pdu_session_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceItemCxtRelReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceItemCxtRelReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemCxtRelReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemCxtRelReq");
			e
		})
	}
}
// PduSessionResourceListHoRqd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceListHoRqd(pub NonEmpty<PduSessionResourceItemHoRqd>);

impl PduSessionResourceListHoRqd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceItemHoRqd::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceListHoRqd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceListHoRqd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListHoRqd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceListHoRqd");
			e
		})
	}
}
// PduSessionResourceItemHoRqd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceItemHoRqd {
	pub pdu_session_id: PduSessionId,
	pub handover_required_transfer: Vec<u8>,
}

impl PduSessionResourceItemHoRqd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let handover_required_transfer = decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			handover_required_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_required_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceItemHoRqd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceItemHoRqd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemHoRqd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceItemHoRqd");
			e
		})
	}
}
// PduSessionResourceModifyConfirmTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyConfirmTransfer {
	pub qos_flow_modify_confirm_list: QosFlowModifyConfirmList,
	pub ulngu_up_tnl_information: UpTransportLayerInformation,
	pub additional_ng_u_up_tnl_information: Option<UpTransportLayerInformationPairList>,
	pub qos_flow_failed_to_modify_list: Option<QosFlowListWithCause>,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
}

impl PduSessionResourceModifyConfirmTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let qos_flow_modify_confirm_list = QosFlowModifyConfirmList::decode(data)?;
		let ulngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let additional_ng_u_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformationPairList::decode(data)?)
		} else {
			None
		};
		let qos_flow_failed_to_modify_list = if optionals[1] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_redundant_ngu_up_tnl_information: Option<
			UpTransportLayerInformationPairList,
		> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					195 => {
						redundant_ul_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					185 => {
						additional_redundant_ngu_up_tnl_information =
							Some(UpTransportLayerInformationPairList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_modify_confirm_list,
			ulngu_up_tnl_information,
			additional_ng_u_up_tnl_information,
			qos_flow_failed_to_modify_list,
			redundant_ul_ngu_up_tnl_information,
			additional_redundant_ngu_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.additional_ng_u_up_tnl_information.is_some());
		optionals.push(self.qos_flow_failed_to_modify_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_modify_confirm_list.encode(data)?;
		self.ulngu_up_tnl_information.encode(data)?;
		if let Some(x) = &self.additional_ng_u_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_failed_to_modify_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyConfirmTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyConfirmTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyConfirmTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyConfirmTransfer");
			e
		})
	}
}
// PduSessionResourceModifyIndicationUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyIndicationUnsuccessfulTransfer {
	pub cause: Cause,
}

impl PduSessionResourceModifyIndicationUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cause })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyIndicationUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyIndicationUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyIndicationUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyIndicationUnsuccessfulTransfer");
			e
		})
	}
}
// PduSessionResourceModifyRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyRequestTransfer {
	pub pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate>,
	pub ul_ngu_up_tnl_modify_list: Option<UlNguUpTnlModifyList>,
	pub network_instance: Option<NetworkInstance>,
	pub qos_flow_add_or_modify_request_list: Option<QosFlowAddOrModifyRequestList>,
	pub qos_flow_to_release_list: Option<QosFlowListWithCause>,
	pub additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub common_network_instance: Option<CommonNetworkInstance>,
	pub additional_redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub redundant_common_network_instance: Option<CommonNetworkInstance>,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub security_indication: Option<SecurityIndication>,
	pub mbs_session_setupor_modify_request_list: Option<MbsSessionSetuporModifyRequestList>,
	pub mbs_session_to_release_list: Option<MbsSessionToReleaseList>,
}

impl PduSessionResourceModifyRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let _ = decode::decode_sequence_header(data, true, 0)?;
		let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

		let mut pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate> =
			None;
		let mut ul_ngu_up_tnl_modify_list: Option<UlNguUpTnlModifyList> = None;
		let mut network_instance: Option<NetworkInstance> = None;
		let mut qos_flow_add_or_modify_request_list: Option<QosFlowAddOrModifyRequestList> = None;
		let mut qos_flow_to_release_list: Option<QosFlowListWithCause> = None;
		let mut additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList> =
			None;
		let mut common_network_instance: Option<CommonNetworkInstance> = None;
		let mut additional_redundant_ul_ngu_up_tnl_information: Option<
			UpTransportLayerInformationList,
		> = None;
		let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut security_indication: Option<SecurityIndication> = None;
		let mut mbs_session_setupor_modify_request_list: Option<
			MbsSessionSetuporModifyRequestList,
		> = None;
		let mut mbs_session_to_release_list: Option<MbsSessionToReleaseList> = None;

		for _ in 0..num_ies {
			let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
			let _ = Criticality::decode(data)?;
			let _ = decode::decode_length_determinent(data, None, None, false)?;
			match id {
				130 => {
					pdu_session_aggregate_maximum_bit_rate =
						Some(PduSessionAggregateMaximumBitRate::decode(data)?)
				}
				140 => ul_ngu_up_tnl_modify_list = Some(UlNguUpTnlModifyList::decode(data)?),
				129 => network_instance = Some(NetworkInstance::decode(data)?),
				135 => {
					qos_flow_add_or_modify_request_list =
						Some(QosFlowAddOrModifyRequestList::decode(data)?)
				}
				137 => qos_flow_to_release_list = Some(QosFlowListWithCause::decode(data)?),
				126 => {
					additional_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformationList::decode(data)?)
				}
				166 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
				186 => {
					additional_redundant_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformationList::decode(data)?)
				}
				190 => {
					redundant_common_network_instance = Some(CommonNetworkInstance::decode(data)?)
				}
				195 => {
					redundant_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformation::decode(data)?)
				}
				138 => security_indication = Some(SecurityIndication::decode(data)?),
				319 => {
					mbs_session_setupor_modify_request_list =
						Some(MbsSessionSetuporModifyRequestList::decode(data)?)
				}
				317 => mbs_session_to_release_list = Some(MbsSessionToReleaseList::decode(data)?),
				x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
			}
			data.decode_align()?;
		}
		Ok(Self {
			pdu_session_aggregate_maximum_bit_rate,
			ul_ngu_up_tnl_modify_list,
			network_instance,
			qos_flow_add_or_modify_request_list,
			qos_flow_to_release_list,
			additional_ul_ngu_up_tnl_information,
			common_network_instance,
			additional_redundant_ul_ngu_up_tnl_information,
			redundant_common_network_instance,
			redundant_ul_ngu_up_tnl_information,
			security_indication,
			mbs_session_setupor_modify_request_list,
			mbs_session_to_release_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();

		if let Some(x) = &self.pdu_session_aggregate_maximum_bit_rate {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ul_ngu_up_tnl_modify_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 140, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_flow_add_or_modify_request_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 135, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_flow_to_release_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 137, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.common_network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 166, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 186, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_common_network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 190, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.security_indication {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_setupor_modify_request_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 319, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_to_release_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 317, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		encode::encode_sequence_header(data, true, &BitString::new(), false)?;
		encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
		data.append_aligned(ies);
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyRequestTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyRequestTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyRequestTransfer");
			e
		})
	}
}
// PduSessionResourceModifyResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyResponseTransfer {
	pub dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub qos_flow_add_or_modify_response_list: Option<QosFlowAddOrModifyResponseList>,
	pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub qos_flow_failed_to_add_or_modify_list: Option<QosFlowListWithCause>,
	pub additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
	pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub additional_redundant_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList>,
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
	pub mbs_support_indicator: Option<MbsSupportIndicator>,
	pub mbs_session_setupor_modify_response_list: Option<MbsSessionSetupResponseList>,
	pub mbs_session_failedto_setupor_modify_list: Option<MbsSessionFailedtoSetupList>,
}

impl PduSessionResourceModifyResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 6)?;
		let dl_ngu_up_tnl_information = if optionals[0] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let ul_ngu_up_tnl_information = if optionals[1] {
			Some(UpTransportLayerInformation::decode(data)?)
		} else {
			None
		};
		let qos_flow_add_or_modify_response_list = if optionals[2] {
			Some(QosFlowAddOrModifyResponseList::decode(data)?)
		} else {
			None
		};
		let additional_dl_qos_flow_per_tnl_information = if optionals[3] {
			Some(QosFlowPerTnlInformationList::decode(data)?)
		} else {
			None
		};
		let qos_flow_failed_to_add_or_modify_list = if optionals[4] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut additional_ngu_up_tnl_information: Option<UpTransportLayerInformationPairList> =
			None;
		let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
			QosFlowPerTnlInformationList,
		> = None;
		let mut additional_redundant_ngu_up_tnl_information: Option<
			UpTransportLayerInformationPairList,
		> = None;
		let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;
		let mut mbs_support_indicator: Option<MbsSupportIndicator> = None;
		let mut mbs_session_setupor_modify_response_list: Option<MbsSessionSetupResponseList> =
			None;
		let mut mbs_session_failedto_setupor_modify_list: Option<MbsSessionFailedtoSetupList> =
			None;

		if optionals[5] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					154 => {
						additional_ngu_up_tnl_information =
							Some(UpTransportLayerInformationPairList::decode(data)?)
					}
					192 => {
						redundant_dl_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					195 => {
						redundant_ul_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					184 => {
						additional_redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					185 => {
						additional_redundant_ngu_up_tnl_information =
							Some(UpTransportLayerInformationPairList::decode(data)?)
					}
					144 => {
						secondary_rat_usage_information =
							Some(SecondaryRatUsageInformation::decode(data)?)
					}
					309 => mbs_support_indicator = Some(MbsSupportIndicator::decode(data)?),
					313 => {
						mbs_session_setupor_modify_response_list =
							Some(MbsSessionSetupResponseList::decode(data)?)
					}
					311 => {
						mbs_session_failedto_setupor_modify_list =
							Some(MbsSessionFailedtoSetupList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_ngu_up_tnl_information,
			ul_ngu_up_tnl_information,
			qos_flow_add_or_modify_response_list,
			additional_dl_qos_flow_per_tnl_information,
			qos_flow_failed_to_add_or_modify_list,
			additional_ngu_up_tnl_information,
			redundant_dl_ngu_up_tnl_information,
			redundant_ul_ngu_up_tnl_information,
			additional_redundant_dl_qos_flow_per_tnl_information,
			additional_redundant_ngu_up_tnl_information,
			secondary_rat_usage_information,
			mbs_support_indicator,
			mbs_session_setupor_modify_response_list,
			mbs_session_failedto_setupor_modify_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.additional_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 154, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 185, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.secondary_rat_usage_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_support_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_setupor_modify_response_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 313, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_failedto_setupor_modify_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 311, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_ngu_up_tnl_information.is_some());
		optionals.push(self.ul_ngu_up_tnl_information.is_some());
		optionals.push(self.qos_flow_add_or_modify_response_list.is_some());
		optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
		optionals.push(self.qos_flow_failed_to_add_or_modify_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.dl_ngu_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.ul_ngu_up_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_add_or_modify_response_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_failed_to_add_or_modify_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyResponseTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyResponseTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyResponseTransfer");
			e
		})
	}
}
// PduSessionResourceModifyIndicationTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyIndicationTransfer {
	pub dl_qos_flow_per_tnl_information: QosFlowPerTnlInformation,
	pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
	pub security_result: Option<SecurityResult>,
	pub redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation>,
	pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub global_ran_node_id: Option<GlobalRanNodeId>,
}

impl PduSessionResourceModifyIndicationTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let dl_qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;
		let additional_dl_qos_flow_per_tnl_information = if optionals[0] {
			Some(QosFlowPerTnlInformationList::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;
		let mut security_result: Option<SecurityResult> = None;
		let mut redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation> = None;
		let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
			QosFlowPerTnlInformationList,
		> = None;
		let mut global_ran_node_id: Option<GlobalRanNodeId> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					144 => {
						secondary_rat_usage_information =
							Some(SecondaryRatUsageInformation::decode(data)?)
					}
					156 => security_result = Some(SecurityResult::decode(data)?),
					193 => {
						redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformation::decode(data)?)
					}
					184 => {
						additional_redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_qos_flow_per_tnl_information,
			additional_dl_qos_flow_per_tnl_information,
			secondary_rat_usage_information,
			security_result,
			redundant_dl_qos_flow_per_tnl_information,
			additional_redundant_dl_qos_flow_per_tnl_information,
			global_ran_node_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.secondary_rat_usage_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.security_result {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 156, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 193, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.global_ran_node_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_qos_flow_per_tnl_information.encode(data)?;
		if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyIndicationTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyIndicationTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyIndicationTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyIndicationTransfer");
			e
		})
	}
}
// PduSessionResourceModifyListModCfm
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyListModCfm(pub NonEmpty<PduSessionResourceModifyItemModCfm>);

impl PduSessionResourceModifyListModCfm {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceModifyItemModCfm::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyListModCfm {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyListModCfm::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModCfm");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModCfm");
			e
		})
	}
}
// PduSessionResourceModifyItemModCfm
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyItemModCfm {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_modify_confirm_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModCfm {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_modify_confirm_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_modify_confirm_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_confirm_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyItemModCfm {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyItemModCfm::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModCfm");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModCfm");
			e
		})
	}
}
// PduSessionResourceModifyListModInd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyListModInd(pub NonEmpty<PduSessionResourceModifyItemModInd>);

impl PduSessionResourceModifyListModInd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceModifyItemModInd::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyListModInd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyListModInd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModInd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModInd");
			e
		})
	}
}
// PduSessionResourceModifyItemModInd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyItemModInd {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_modify_indication_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModInd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_modify_indication_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_modify_indication_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_indication_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyItemModInd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyItemModInd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModInd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModInd");
			e
		})
	}
}
// PduSessionResourceModifyListModReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyListModReq(pub NonEmpty<PduSessionResourceModifyItemModReq>);

impl PduSessionResourceModifyListModReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceModifyItemModReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyListModReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyListModReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModReq");
			e
		})
	}
}
// PduSessionResourceModifyItemModReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyItemModReq {
	pub pdu_session_id: PduSessionId,
	pub nas_pdu: Option<NasPdu>,
	pub pdu_session_resource_modify_request_transfer: Vec<u8>,
	pub snssai: Option<Snssai>,
	pub pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
}

impl PduSessionResourceModifyItemModReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let nas_pdu = if optionals[0] {
			Some(NasPdu::decode(data)?)
		} else {
			None
		};
		let pdu_session_resource_modify_request_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container
		let mut snssai: Option<Snssai> = None;
		let mut pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour> =
			None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					148 => snssai = Some(Snssai::decode(data)?),
					281 => {
						pdu_session_expected_ue_activity_behaviour =
							Some(ExpectedUeActivityBehaviour::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			nas_pdu,
			pdu_session_resource_modify_request_transfer,
			snssai,
			pdu_session_expected_ue_activity_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.snssai {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 148, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.pdu_session_expected_ue_activity_behaviour {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.nas_pdu.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		if let Some(x) = &self.nas_pdu {
			x.encode(data)?;
		}
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_request_transfer,
			false,
		)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyItemModReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyItemModReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModReq");
			e
		})
	}
}
// PduSessionResourceModifyListModRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyListModRes(pub NonEmpty<PduSessionResourceModifyItemModRes>);

impl PduSessionResourceModifyListModRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceModifyItemModRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyListModRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyListModRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyListModRes");
			e
		})
	}
}
// PduSessionResourceModifyItemModRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyItemModRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_modify_response_transfer: Vec<u8>,
}

impl PduSessionResourceModifyItemModRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_modify_response_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_modify_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_modify_response_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyItemModRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyItemModRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyItemModRes");
			e
		})
	}
}
// PduSessionResourceModifyUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceModifyUnsuccessfulTransfer {
	pub cause: Cause,
	pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceModifyUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cause = Cause::decode(data)?;
		let criticality_diagnostics = if optionals[0] {
			Some(CriticalityDiagnostics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cause,
			criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;
		if let Some(x) = &self.criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for PduSessionResourceModifyUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceModifyUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceModifyUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceModifyUnsuccessfulTransfer");
			e
		})
	}
}
// PduSessionResourceNotifyList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceNotifyList(pub NonEmpty<PduSessionResourceNotifyItem>);

impl PduSessionResourceNotifyList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceNotifyItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceNotifyList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyList");
			e
		})
	}
}
// PduSessionResourceNotifyItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceNotifyItem {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_notify_transfer: Vec<u8>,
}

impl PduSessionResourceNotifyItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_notify_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_notify_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_notify_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceNotifyItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyItem");
			e
		})
	}
}
// PduSessionResourceNotifyReleasedTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceNotifyReleasedTransfer {
	pub cause: Cause,
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl PduSessionResourceNotifyReleasedTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container
		let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					144 => {
						secondary_rat_usage_information =
							Some(SecondaryRatUsageInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cause,
			secondary_rat_usage_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.secondary_rat_usage_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceNotifyReleasedTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceNotifyReleasedTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceNotifyReleasedTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyReleasedTransfer");
			e
		})
	}
}
// PduSessionResourceNotifyTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceNotifyTransfer {
	pub qos_flow_notify_list: Option<QosFlowNotifyList>,
	pub qos_flow_released_list: Option<QosFlowListWithCause>,
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
	pub qos_flow_feedback_list: Option<QosFlowFeedbackList>,
}

impl PduSessionResourceNotifyTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let qos_flow_notify_list = if optionals[0] {
			Some(QosFlowNotifyList::decode(data)?)
		} else {
			None
		};
		let qos_flow_released_list = if optionals[1] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;
		let mut qos_flow_feedback_list: Option<QosFlowFeedbackList> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					144 => {
						secondary_rat_usage_information =
							Some(SecondaryRatUsageInformation::decode(data)?)
					}
					278 => qos_flow_feedback_list = Some(QosFlowFeedbackList::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_notify_list,
			qos_flow_released_list,
			secondary_rat_usage_information,
			qos_flow_feedback_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.secondary_rat_usage_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_flow_feedback_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 278, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.qos_flow_notify_list.is_some());
		optionals.push(self.qos_flow_released_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.qos_flow_notify_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_released_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceNotifyTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceNotifyTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceNotifyTransfer");
			e
		})
	}
}
// PduSessionResourceReleaseCommandTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleaseCommandTransfer {
	pub cause: Cause,
}

impl PduSessionResourceReleaseCommandTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { cause })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleaseCommandTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleaseCommandTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceReleaseCommandTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleaseCommandTransfer");
			e
		})
	}
}
// PduSessionResourceReleasedListNot
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedListNot(pub NonEmpty<PduSessionResourceReleasedItemNot>);

impl PduSessionResourceReleasedListNot {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceReleasedItemNot::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedListNot {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedListNot::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListNot");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListNot");
			e
		})
	}
}
// PduSessionResourceReleasedItemNot
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedItemNot {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_notify_released_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemNot {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_notify_released_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_notify_released_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_notify_released_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedItemNot {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedItemNot::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemNot");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemNot");
			e
		})
	}
}
// PduSessionResourceReleasedListPsAck
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedListPsAck(pub NonEmpty<PduSessionResourceReleasedItemPsAck>);

impl PduSessionResourceReleasedListPsAck {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceReleasedItemPsAck::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedListPsAck {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedListPsAck::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListPsAck");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListPsAck");
			e
		})
	}
}
// PduSessionResourceReleasedItemPsAck
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedItemPsAck {
	pub pdu_session_id: PduSessionId,
	pub path_switch_request_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemPsAck {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let path_switch_request_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			path_switch_request_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.path_switch_request_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedItemPsAck {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedItemPsAck::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemPsAck");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemPsAck");
			e
		})
	}
}
// PduSessionResourceReleasedListPsFail
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedListPsFail(pub NonEmpty<PduSessionResourceReleasedItemPsFail>);

impl PduSessionResourceReleasedListPsFail {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceReleasedItemPsFail::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedListPsFail {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedListPsFail::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListPsFail");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListPsFail");
			e
		})
	}
}
// PduSessionResourceReleasedItemPsFail
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedItemPsFail {
	pub pdu_session_id: PduSessionId,
	pub path_switch_request_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemPsFail {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let path_switch_request_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			path_switch_request_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.path_switch_request_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedItemPsFail {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedItemPsFail::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemPsFail");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemPsFail");
			e
		})
	}
}
// PduSessionResourceReleasedListRelRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedListRelRes(pub NonEmpty<PduSessionResourceReleasedItemRelRes>);

impl PduSessionResourceReleasedListRelRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceReleasedItemRelRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedListRelRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedListRelRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListRelRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedListRelRes");
			e
		})
	}
}
// PduSessionResourceReleasedItemRelRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleasedItemRelRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_release_response_transfer: Vec<u8>,
}

impl PduSessionResourceReleasedItemRelRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_release_response_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_release_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_release_response_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleasedItemRelRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleasedItemRelRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemRelRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleasedItemRelRes");
			e
		})
	}
}
// PduSessionResourceReleaseResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceReleaseResponseTransfer {
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl PduSessionResourceReleaseResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;

		// Process the extension container
		let mut secondary_rat_usage_information: Option<SecondaryRatUsageInformation> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					144 => {
						secondary_rat_usage_information =
							Some(SecondaryRatUsageInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			secondary_rat_usage_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.secondary_rat_usage_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 144, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceReleaseResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceReleaseResponseTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceReleaseResponseTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceReleaseResponseTransfer");
			e
		})
	}
}
// PduSessionResourceResumeListResReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceResumeListResReq(pub NonEmpty<PduSessionResourceResumeItemResReq>);

impl PduSessionResourceResumeListResReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceResumeItemResReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceResumeListResReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceResumeListResReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeListResReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeListResReq");
			e
		})
	}
}
// PduSessionResourceResumeItemResReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceResumeItemResReq {
	pub pdu_session_id: PduSessionId,
	pub ue_context_resume_request_transfer: Vec<u8>,
}

impl PduSessionResourceResumeItemResReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let ue_context_resume_request_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			ue_context_resume_request_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.ue_context_resume_request_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceResumeItemResReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceResumeItemResReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeItemResReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeItemResReq");
			e
		})
	}
}
// PduSessionResourceResumeListResRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceResumeListResRes(pub NonEmpty<PduSessionResourceResumeItemResRes>);

impl PduSessionResourceResumeListResRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceResumeItemResRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceResumeListResRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceResumeListResRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeListResRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeListResRes");
			e
		})
	}
}
// PduSessionResourceResumeItemResRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceResumeItemResRes {
	pub pdu_session_id: PduSessionId,
	pub ue_context_resume_response_transfer: Vec<u8>,
}

impl PduSessionResourceResumeItemResRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let ue_context_resume_response_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			ue_context_resume_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.ue_context_resume_response_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceResumeItemResRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceResumeItemResRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeItemResRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceResumeItemResRes");
			e
		})
	}
}
// PduSessionResourceSecondaryRatUsageList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSecondaryRatUsageList(
	pub NonEmpty<PduSessionResourceSecondaryRatUsageItem>,
);

impl PduSessionResourceSecondaryRatUsageList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSecondaryRatUsageItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSecondaryRatUsageList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSecondaryRatUsageList::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceSecondaryRatUsageList");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSecondaryRatUsageList");
			e
		})
	}
}
// PduSessionResourceSecondaryRatUsageItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSecondaryRatUsageItem {
	pub pdu_session_id: PduSessionId,
	pub secondary_rat_data_usage_report_transfer: Vec<u8>,
}

impl PduSessionResourceSecondaryRatUsageItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let secondary_rat_data_usage_report_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			secondary_rat_data_usage_report_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.secondary_rat_data_usage_report_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceSecondaryRatUsageItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSecondaryRatUsageItem::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceSecondaryRatUsageItem");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSecondaryRatUsageItem");
			e
		})
	}
}
// PduSessionResourceSetupListCxtReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupListCxtReq(pub NonEmpty<PduSessionResourceSetupItemCxtReq>);

impl PduSessionResourceSetupListCxtReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSetupItemCxtReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupListCxtReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupListCxtReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListCxtReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListCxtReq");
			e
		})
	}
}
// PduSessionResourceSetupItemCxtReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupItemCxtReq {
	pub pdu_session_id: PduSessionId,
	pub nas_pdu: Option<NasPdu>,
	pub snssai: Snssai,
	pub pdu_session_resource_setup_request_transfer: Vec<u8>,
	pub pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
}

impl PduSessionResourceSetupItemCxtReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let nas_pdu = if optionals[0] {
			Some(NasPdu::decode(data)?)
		} else {
			None
		};
		let snssai = Snssai::decode(data)?;
		let pdu_session_resource_setup_request_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container
		let mut pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour> =
			None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					281 => {
						pdu_session_expected_ue_activity_behaviour =
							Some(ExpectedUeActivityBehaviour::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			nas_pdu,
			snssai,
			pdu_session_resource_setup_request_transfer,
			pdu_session_expected_ue_activity_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_expected_ue_activity_behaviour {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.nas_pdu.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		if let Some(x) = &self.nas_pdu {
			x.encode(data)?;
		}
		self.snssai.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_request_transfer,
			false,
		)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupItemCxtReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupItemCxtReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemCxtReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemCxtReq");
			e
		})
	}
}
// PduSessionResourceSetupListCxtRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupListCxtRes(pub NonEmpty<PduSessionResourceSetupItemCxtRes>);

impl PduSessionResourceSetupListCxtRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSetupItemCxtRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupListCxtRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupListCxtRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListCxtRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListCxtRes");
			e
		})
	}
}
// PduSessionResourceSetupItemCxtRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupItemCxtRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_setup_response_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemCxtRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_setup_response_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_setup_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_response_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupItemCxtRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupItemCxtRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemCxtRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemCxtRes");
			e
		})
	}
}
// PduSessionResourceSetupListHoReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupListHoReq(pub NonEmpty<PduSessionResourceSetupItemHoReq>);

impl PduSessionResourceSetupListHoReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSetupItemHoReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupListHoReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupListHoReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListHoReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListHoReq");
			e
		})
	}
}
// PduSessionResourceSetupItemHoReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupItemHoReq {
	pub pdu_session_id: PduSessionId,
	pub snssai: Snssai,
	pub handover_request_transfer: Vec<u8>,
	pub pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
}

impl PduSessionResourceSetupItemHoReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let snssai = Snssai::decode(data)?;
		let handover_request_transfer = decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container
		let mut pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour> =
			None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					281 => {
						pdu_session_expected_ue_activity_behaviour =
							Some(ExpectedUeActivityBehaviour::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			snssai,
			handover_request_transfer,
			pdu_session_expected_ue_activity_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_expected_ue_activity_behaviour {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		self.snssai.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_request_transfer,
			false,
		)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupItemHoReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupItemHoReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemHoReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemHoReq");
			e
		})
	}
}
// PduSessionResourceSetupListSuReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupListSuReq(pub NonEmpty<PduSessionResourceSetupItemSuReq>);

impl PduSessionResourceSetupListSuReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSetupItemSuReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupListSuReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupListSuReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListSuReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListSuReq");
			e
		})
	}
}
// PduSessionResourceSetupItemSuReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupItemSuReq {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_nas_pdu: Option<NasPdu>,
	pub snssai: Snssai,
	pub pdu_session_resource_setup_request_transfer: Vec<u8>,
	pub pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
}

impl PduSessionResourceSetupItemSuReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_nas_pdu = if optionals[0] {
			Some(NasPdu::decode(data)?)
		} else {
			None
		};
		let snssai = Snssai::decode(data)?;
		let pdu_session_resource_setup_request_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container
		let mut pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour> =
			None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					281 => {
						pdu_session_expected_ue_activity_behaviour =
							Some(ExpectedUeActivityBehaviour::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_nas_pdu,
			snssai,
			pdu_session_resource_setup_request_transfer,
			pdu_session_expected_ue_activity_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_expected_ue_activity_behaviour {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.pdu_session_nas_pdu.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		if let Some(x) = &self.pdu_session_nas_pdu {
			x.encode(data)?;
		}
		self.snssai.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_request_transfer,
			false,
		)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupItemSuReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupItemSuReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemSuReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemSuReq");
			e
		})
	}
}
// PduSessionResourceSetupListSuRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupListSuRes(pub NonEmpty<PduSessionResourceSetupItemSuRes>);

impl PduSessionResourceSetupListSuRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSetupItemSuRes::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupListSuRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupListSuRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListSuRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupListSuRes");
			e
		})
	}
}
// PduSessionResourceSetupItemSuRes
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupItemSuRes {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_setup_response_transfer: Vec<u8>,
}

impl PduSessionResourceSetupItemSuRes {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_setup_response_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_setup_response_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_setup_response_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupItemSuRes {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupItemSuRes::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemSuRes");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupItemSuRes");
			e
		})
	}
}
// PduSessionResourceSetupRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupRequestTransfer {
	pub pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate>,
	pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
	pub additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub data_forwarding_not_possible: Option<DataForwardingNotPossible>,
	pub pdu_session_type: PduSessionType,
	pub security_indication: Option<SecurityIndication>,
	pub network_instance: Option<NetworkInstance>,
	pub qos_flow_setup_request_list: QosFlowSetupRequestList,
	pub common_network_instance: Option<CommonNetworkInstance>,
	pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub additional_redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList>,
	pub redundant_common_network_instance: Option<CommonNetworkInstance>,
	pub redundant_pdu_session_information: Option<RedundantPduSessionInformation>,
	pub mbs_session_setup_request_list: Option<MbsSessionSetupRequestList>,
}

impl PduSessionResourceSetupRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let _ = decode::decode_sequence_header(data, true, 0)?;
		let num_ies = decode::decode_length_determinent(data, Some(0), Some(65535), false)?;

		let mut pdu_session_aggregate_maximum_bit_rate: Option<PduSessionAggregateMaximumBitRate> =
			None;
		let mut ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_ul_ngu_up_tnl_information: Option<UpTransportLayerInformationList> =
			None;
		let mut data_forwarding_not_possible: Option<DataForwardingNotPossible> = None;
		let mut pdu_session_type: Option<PduSessionType> = None;
		let mut security_indication: Option<SecurityIndication> = None;
		let mut network_instance: Option<NetworkInstance> = None;
		let mut qos_flow_setup_request_list: Option<QosFlowSetupRequestList> = None;
		let mut common_network_instance: Option<CommonNetworkInstance> = None;
		let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
			None;
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut additional_redundant_ul_ngu_up_tnl_information: Option<
			UpTransportLayerInformationList,
		> = None;
		let mut redundant_common_network_instance: Option<CommonNetworkInstance> = None;
		let mut redundant_pdu_session_information: Option<RedundantPduSessionInformation> = None;
		let mut mbs_session_setup_request_list: Option<MbsSessionSetupRequestList> = None;

		for _ in 0..num_ies {
			let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
			let _ = Criticality::decode(data)?;
			let _ = decode::decode_length_determinent(data, None, None, false)?;
			match id {
				130 => {
					pdu_session_aggregate_maximum_bit_rate =
						Some(PduSessionAggregateMaximumBitRate::decode(data)?)
				}
				139 => ul_ngu_up_tnl_information = Some(UpTransportLayerInformation::decode(data)?),
				126 => {
					additional_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformationList::decode(data)?)
				}
				127 => {
					data_forwarding_not_possible = Some(DataForwardingNotPossible::decode(data)?)
				}
				134 => pdu_session_type = Some(PduSessionType::decode(data)?),
				138 => security_indication = Some(SecurityIndication::decode(data)?),
				129 => network_instance = Some(NetworkInstance::decode(data)?),
				136 => qos_flow_setup_request_list = Some(QosFlowSetupRequestList::decode(data)?),
				166 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
				22 => {
					direct_forwarding_path_availability =
						Some(DirectForwardingPathAvailability::decode(data)?)
				}
				195 => {
					redundant_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformation::decode(data)?)
				}
				186 => {
					additional_redundant_ul_ngu_up_tnl_information =
						Some(UpTransportLayerInformationList::decode(data)?)
				}
				190 => {
					redundant_common_network_instance = Some(CommonNetworkInstance::decode(data)?)
				}
				197 => {
					redundant_pdu_session_information =
						Some(RedundantPduSessionInformation::decode(data)?)
				}
				318 => {
					mbs_session_setup_request_list = Some(MbsSessionSetupRequestList::decode(data)?)
				}
				x => return Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
			}
			data.decode_align()?;
		}
		let ul_ngu_up_tnl_information = ul_ngu_up_tnl_information.ok_or(PerCodecError::new(
			format!("Missing mandatory IE ul_ngu_up_tnl_information"),
		))?;
		let pdu_session_type = pdu_session_type.ok_or(PerCodecError::new(format!(
			"Missing mandatory IE pdu_session_type"
		)))?;
		let qos_flow_setup_request_list = qos_flow_setup_request_list.ok_or(PerCodecError::new(
			format!("Missing mandatory IE qos_flow_setup_request_list"),
		))?;
		Ok(Self {
			pdu_session_aggregate_maximum_bit_rate,
			ul_ngu_up_tnl_information,
			additional_ul_ngu_up_tnl_information,
			data_forwarding_not_possible,
			pdu_session_type,
			security_indication,
			network_instance,
			qos_flow_setup_request_list,
			common_network_instance,
			direct_forwarding_path_availability,
			redundant_ul_ngu_up_tnl_information,
			additional_redundant_ul_ngu_up_tnl_information,
			redundant_common_network_instance,
			redundant_pdu_session_information,
			mbs_session_setup_request_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();

		if let Some(x) = &self.pdu_session_aggregate_maximum_bit_rate {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 130, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let ie = &mut Allocator::new_codec_data();
		self.ul_ngu_up_tnl_information.encode(ie)?;
		encode::encode_integer(ies, Some(0), Some(65535), false, 139, false)?;
		Criticality::Reject.encode(ies)?;
		encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
		ies.append_aligned(ie);
		num_ies += 1;

		if let Some(x) = &self.additional_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 126, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.data_forwarding_not_possible {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 127, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let ie = &mut Allocator::new_codec_data();
		self.pdu_session_type.encode(ie)?;
		encode::encode_integer(ies, Some(0), Some(65535), false, 134, false)?;
		Criticality::Reject.encode(ies)?;
		encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
		ies.append_aligned(ie);
		num_ies += 1;

		if let Some(x) = &self.security_indication {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 138, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 129, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let ie = &mut Allocator::new_codec_data();
		self.qos_flow_setup_request_list.encode(ie)?;
		encode::encode_integer(ies, Some(0), Some(65535), false, 136, false)?;
		Criticality::Reject.encode(ies)?;
		encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
		ies.append_aligned(ie);
		num_ies += 1;

		if let Some(x) = &self.common_network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 166, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.direct_forwarding_path_availability {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 22, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 186, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_common_network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 190, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_pdu_session_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 197, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_setup_request_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 318, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		encode::encode_sequence_header(data, true, &BitString::new(), false)?;
		encode::encode_length_determinent(data, Some(0), Some(65535), false, num_ies)?;
		data.append_aligned(ies);
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupRequestTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceSetupRequestTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupRequestTransfer");
			e
		})
	}
}
// PduSessionResourceSetupResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupResponseTransfer {
	pub dl_qos_flow_per_tnl_information: QosFlowPerTnlInformation,
	pub additional_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub security_result: Option<SecurityResult>,
	pub qos_flow_failed_to_setup_list: Option<QosFlowListWithCause>,
	pub redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation>,
	pub additional_redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformationList>,
	pub used_rsn_information: Option<RedundantPduSessionInformation>,
	pub global_ran_node_id: Option<GlobalRanNodeId>,
	pub mbs_support_indicator: Option<MbsSupportIndicator>,
	pub mbs_session_setup_response_list: Option<MbsSessionSetupResponseList>,
	pub mbs_session_failedto_setup_list: Option<MbsSessionFailedtoSetupList>,
}

impl PduSessionResourceSetupResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let dl_qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;
		let additional_dl_qos_flow_per_tnl_information = if optionals[0] {
			Some(QosFlowPerTnlInformationList::decode(data)?)
		} else {
			None
		};
		let security_result = if optionals[1] {
			Some(SecurityResult::decode(data)?)
		} else {
			None
		};
		let qos_flow_failed_to_setup_list = if optionals[2] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut redundant_dl_qos_flow_per_tnl_information: Option<QosFlowPerTnlInformation> = None;
		let mut additional_redundant_dl_qos_flow_per_tnl_information: Option<
			QosFlowPerTnlInformationList,
		> = None;
		let mut used_rsn_information: Option<RedundantPduSessionInformation> = None;
		let mut global_ran_node_id: Option<GlobalRanNodeId> = None;
		let mut mbs_support_indicator: Option<MbsSupportIndicator> = None;
		let mut mbs_session_setup_response_list: Option<MbsSessionSetupResponseList> = None;
		let mut mbs_session_failedto_setup_list: Option<MbsSessionFailedtoSetupList> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					193 => {
						redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformation::decode(data)?)
					}
					184 => {
						additional_redundant_dl_qos_flow_per_tnl_information =
							Some(QosFlowPerTnlInformationList::decode(data)?)
					}
					198 => {
						used_rsn_information = Some(RedundantPduSessionInformation::decode(data)?)
					}
					27 => global_ran_node_id = Some(GlobalRanNodeId::decode(data)?),
					309 => mbs_support_indicator = Some(MbsSupportIndicator::decode(data)?),
					312 => {
						mbs_session_setup_response_list =
							Some(MbsSessionSetupResponseList::decode(data)?)
					}
					310 => {
						mbs_session_failedto_setup_list =
							Some(MbsSessionFailedtoSetupList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dl_qos_flow_per_tnl_information,
			additional_dl_qos_flow_per_tnl_information,
			security_result,
			qos_flow_failed_to_setup_list,
			redundant_dl_qos_flow_per_tnl_information,
			additional_redundant_dl_qos_flow_per_tnl_information,
			used_rsn_information,
			global_ran_node_id,
			mbs_support_indicator,
			mbs_session_setup_response_list,
			mbs_session_failedto_setup_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 193, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.additional_redundant_dl_qos_flow_per_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 184, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.used_rsn_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 198, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.global_ran_node_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 27, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_support_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 309, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_setup_response_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 312, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_session_failedto_setup_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 310, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.additional_dl_qos_flow_per_tnl_information.is_some());
		optionals.push(self.security_result.is_some());
		optionals.push(self.qos_flow_failed_to_setup_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.dl_qos_flow_per_tnl_information.encode(data)?;
		if let Some(x) = &self.additional_dl_qos_flow_per_tnl_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.security_result {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flow_failed_to_setup_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupResponseTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceSetupResponseTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupResponseTransfer");
			e
		})
	}
}
// PduSessionResourceSetupUnsuccessfulTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSetupUnsuccessfulTransfer {
	pub cause: Cause,
	pub criticality_diagnostics: Option<CriticalityDiagnostics>,
}

impl PduSessionResourceSetupUnsuccessfulTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cause = Cause::decode(data)?;
		let criticality_diagnostics = if optionals[0] {
			Some(CriticalityDiagnostics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cause,
			criticality_diagnostics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.criticality_diagnostics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.cause.encode(data)?;
		if let Some(x) = &self.criticality_diagnostics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for PduSessionResourceSetupUnsuccessfulTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSetupUnsuccessfulTransfer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("PduSessionResourceSetupUnsuccessfulTransfer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSetupUnsuccessfulTransfer");
			e
		})
	}
}
// PduSessionResourceSuspendListSusReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSuspendListSusReq(pub NonEmpty<PduSessionResourceSuspendItemSusReq>);

impl PduSessionResourceSuspendListSusReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSuspendItemSusReq::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSuspendListSusReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSuspendListSusReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSuspendListSusReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSuspendListSusReq");
			e
		})
	}
}
// PduSessionResourceSuspendItemSusReq
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSuspendItemSusReq {
	pub pdu_session_id: PduSessionId,
	pub ue_context_suspend_request_transfer: Vec<u8>,
}

impl PduSessionResourceSuspendItemSusReq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let ue_context_suspend_request_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			ue_context_suspend_request_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.ue_context_suspend_request_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceSuspendItemSusReq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSuspendItemSusReq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSuspendItemSusReq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSuspendItemSusReq");
			e
		})
	}
}
// PduSessionResourceSwitchedList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSwitchedList(pub NonEmpty<PduSessionResourceSwitchedItem>);

impl PduSessionResourceSwitchedList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceSwitchedItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSwitchedList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSwitchedList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSwitchedList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSwitchedList");
			e
		})
	}
}
// PduSessionResourceSwitchedItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceSwitchedItem {
	pub pdu_session_id: PduSessionId,
	pub path_switch_request_acknowledge_transfer: Vec<u8>,
	pub pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour>,
}

impl PduSessionResourceSwitchedItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let path_switch_request_acknowledge_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container
		let mut pdu_session_expected_ue_activity_behaviour: Option<ExpectedUeActivityBehaviour> =
			None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					281 => {
						pdu_session_expected_ue_activity_behaviour =
							Some(ExpectedUeActivityBehaviour::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			path_switch_request_acknowledge_transfer,
			pdu_session_expected_ue_activity_behaviour,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_expected_ue_activity_behaviour {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 281, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.path_switch_request_acknowledge_transfer,
			false,
		)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceSwitchedItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceSwitchedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSwitchedItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceSwitchedItem");
			e
		})
	}
}
// PduSessionResourceToBeSwitchedDlList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToBeSwitchedDlList(pub NonEmpty<PduSessionResourceToBeSwitchedDlItem>);

impl PduSessionResourceToBeSwitchedDlList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceToBeSwitchedDlItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceToBeSwitchedDlList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToBeSwitchedDlList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToBeSwitchedDlList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToBeSwitchedDlList");
			e
		})
	}
}
// PduSessionResourceToBeSwitchedDlItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToBeSwitchedDlItem {
	pub pdu_session_id: PduSessionId,
	pub path_switch_request_transfer: Vec<u8>,
}

impl PduSessionResourceToBeSwitchedDlItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let path_switch_request_transfer = decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			path_switch_request_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.path_switch_request_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceToBeSwitchedDlItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToBeSwitchedDlItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToBeSwitchedDlItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToBeSwitchedDlItem");
			e
		})
	}
}
// PduSessionResourceToReleaseListHoCmd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToReleaseListHoCmd(pub NonEmpty<PduSessionResourceToReleaseItemHoCmd>);

impl PduSessionResourceToReleaseListHoCmd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceToReleaseItemHoCmd::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceToReleaseListHoCmd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToReleaseListHoCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseListHoCmd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseListHoCmd");
			e
		})
	}
}
// PduSessionResourceToReleaseItemHoCmd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToReleaseItemHoCmd {
	pub pdu_session_id: PduSessionId,
	pub handover_preparation_unsuccessful_transfer: Vec<u8>,
}

impl PduSessionResourceToReleaseItemHoCmd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let handover_preparation_unsuccessful_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			handover_preparation_unsuccessful_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.handover_preparation_unsuccessful_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceToReleaseItemHoCmd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToReleaseItemHoCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseItemHoCmd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseItemHoCmd");
			e
		})
	}
}
// PduSessionResourceToReleaseListRelCmd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToReleaseListRelCmd(
	pub NonEmpty<PduSessionResourceToReleaseItemRelCmd>,
);

impl PduSessionResourceToReleaseListRelCmd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PduSessionResourceToReleaseItemRelCmd::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PduSessionResourceToReleaseListRelCmd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToReleaseListRelCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseListRelCmd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseListRelCmd");
			e
		})
	}
}
// PduSessionResourceToReleaseItemRelCmd
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionResourceToReleaseItemRelCmd {
	pub pdu_session_id: PduSessionId,
	pub pdu_session_resource_release_command_transfer: Vec<u8>,
}

impl PduSessionResourceToReleaseItemRelCmd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let pdu_session_id = PduSessionId::decode(data)?;
		let pdu_session_resource_release_command_transfer =
			decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_id,
			pdu_session_resource_release_command_transfer,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.pdu_session_id.encode(data)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.pdu_session_resource_release_command_transfer,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for PduSessionResourceToReleaseItemRelCmd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionResourceToReleaseItemRelCmd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseItemRelCmd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionResourceToReleaseItemRelCmd");
			e
		})
	}
}
// PduSessionType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PduSessionType {
	#[default]
	Ipv4,
	Ipv6,
	Ipv4v6,
	Ethernet,
	Unstructured,
}

impl PduSessionType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(4), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(4), true, *self as i128, false)
	}
}

impl PerCodec for PduSessionType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionType");
			e
		})
	}
}
// PduSessionUsageReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PduSessionUsageReport {
	pub rat_type: RatType,
	pub pdu_session_timed_report_list: VolumeTimedReportList,
}

impl PduSessionUsageReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let rat_type = RatType::decode(data)?;
		let pdu_session_timed_report_list = VolumeTimedReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			rat_type,
			pdu_session_timed_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.rat_type.encode(data)?;
		self.pdu_session_timed_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PduSessionUsageReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PduSessionUsageReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionUsageReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PduSessionUsageReport");
			e
		})
	}
}
// PeipSassistanceInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PeipSassistanceInformation {
	pub c_nsubgroup_id: CNsubgroupId,
}

impl PeipSassistanceInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let c_nsubgroup_id = CNsubgroupId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { c_nsubgroup_id })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.c_nsubgroup_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PeipSassistanceInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PeipSassistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeipSassistanceInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeipSassistanceInformation");
			e
		})
	}
}
// Periodicity
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct Periodicity(pub u32);

impl Periodicity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(640000), true)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(640000), true, self.0 as i128, false)
	}
}

impl PerCodec for Periodicity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Periodicity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Periodicity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Periodicity");
			e
		})
	}
}
// PeriodicRegistrationUpdateTimer
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PeriodicRegistrationUpdateTimer(pub BitString);

impl PeriodicRegistrationUpdateTimer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), false, &self.0, false)
	}
}

impl PerCodec for PeriodicRegistrationUpdateTimer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PeriodicRegistrationUpdateTimer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicRegistrationUpdateTimer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicRegistrationUpdateTimer");
			e
		})
	}
}
// PlmnIdentity
#[derive(Clone, Debug)]
pub struct PlmnIdentity(pub [u8; 3]);
impl Default for PlmnIdentity {
	fn default() -> PlmnIdentity {
		let init = std::mem::MaybeUninit::<[u8; 3]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		PlmnIdentity(default_value)
	}
}
impl PlmnIdentity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(3), Some(3), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
	}
}

impl PerCodec for PlmnIdentity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlmnIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnIdentity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnIdentity");
			e
		})
	}
}
// PlmnAreaBasedQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PlmnAreaBasedQmc {
	pub plmn_listfor_qmc: PlmnListforQmc,
}

impl PlmnAreaBasedQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_listfor_qmc = PlmnListforQmc::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { plmn_listfor_qmc })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_listfor_qmc.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PlmnAreaBasedQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlmnAreaBasedQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnAreaBasedQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnAreaBasedQmc");
			e
		})
	}
}
// PlmnListforQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PlmnListforQmc(pub NonEmpty<PlmnIdentity>);

impl PlmnListforQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PlmnIdentity::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PlmnListforQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlmnListforQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnListforQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnListforQmc");
			e
		})
	}
}
// PlmnSupportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PlmnSupportList(pub NonEmpty<PlmnSupportItem>);

impl PlmnSupportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(PlmnSupportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for PlmnSupportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlmnSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnSupportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnSupportList");
			e
		})
	}
}
// PlmnSupportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PlmnSupportItem {
	pub plmn_identity: PlmnIdentity,
	pub slice_support_list: SliceSupportList,
	pub npn_support: Option<NpnSupport>,
	pub extended_slice_support_list: Option<ExtendedSliceSupportList>,
	pub onboarding_support: Option<OnboardingSupport>,
}

impl PlmnSupportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let slice_support_list = SliceSupportList::decode(data)?;

		// Process the extension container
		let mut npn_support: Option<NpnSupport> = None;
		let mut extended_slice_support_list: Option<ExtendedSliceSupportList> = None;
		let mut onboarding_support: Option<OnboardingSupport> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					258 => npn_support = Some(NpnSupport::decode(data)?),
					270 => {
						extended_slice_support_list = Some(ExtendedSliceSupportList::decode(data)?)
					}
					325 => onboarding_support = Some(OnboardingSupport::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			slice_support_list,
			npn_support,
			extended_slice_support_list,
			onboarding_support,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.npn_support {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 258, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.extended_slice_support_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 270, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.onboarding_support {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 325, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.slice_support_list.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for PlmnSupportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlmnSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnSupportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlmnSupportItem");
			e
		})
	}
}
// PniNpnMobilityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct PniNpnMobilityInformation {
	pub allowed_pni_npi_list: AllowedPniNpnList,
}

impl PniNpnMobilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let allowed_pni_npi_list = AllowedPniNpnList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			allowed_pni_npi_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.allowed_pni_npi_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for PniNpnMobilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PniNpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PniNpnMobilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PniNpnMobilityInformation");
			e
		})
	}
}
// PortNumber
#[derive(Clone, Debug)]
pub struct PortNumber(pub [u8; 2]);
impl Default for PortNumber {
	fn default() -> PortNumber {
		let init = std::mem::MaybeUninit::<[u8; 2]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		PortNumber(default_value)
	}
}
impl PortNumber {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(2), Some(2), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
	}
}

impl PerCodec for PortNumber {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PortNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PortNumber");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PortNumber");
			e
		})
	}
}
// PreEmptionCapability
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PreEmptionCapability {
	#[default]
	ShallNotTriggerPreEmption,
	MayTriggerPreEmption,
}

impl PreEmptionCapability {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PreEmptionCapability {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PreEmptionCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PreEmptionCapability");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PreEmptionCapability");
			e
		})
	}
}
// PreEmptionVulnerability
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PreEmptionVulnerability {
	#[default]
	NotPreEmptable,
	PreEmptable,
}

impl PreEmptionVulnerability {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PreEmptionVulnerability {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PreEmptionVulnerability::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PreEmptionVulnerability");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PreEmptionVulnerability");
			e
		})
	}
}
// PriorityLevelArp
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PriorityLevelArp(pub u8);

impl PriorityLevelArp {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(15), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(15), false, self.0 as i128, false)
	}
}

impl PerCodec for PriorityLevelArp {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PriorityLevelArp::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PriorityLevelArp");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PriorityLevelArp");
			e
		})
	}
}
// PriorityLevelQos
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct PriorityLevelQos(pub u8);

impl PriorityLevelQos {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(127), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(127), true, self.0 as i128, false)
	}
}

impl PerCodec for PriorityLevelQos {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PriorityLevelQos::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PriorityLevelQos");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PriorityLevelQos");
			e
		})
	}
}
// PwsFailedCellIdList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum PwsFailedCellIdList {
	#[default]
	EutraCgiPwsFailedList(EutraCgiList),
	NrCgiPwsFailedList(NrCgiList),
}

impl PwsFailedCellIdList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EutraCgiPwsFailedList(EutraCgiList::decode(data)?)),
			1 => Ok(Self::NrCgiPwsFailedList(NrCgiList::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EutraCgiPwsFailedList(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::NrCgiPwsFailedList(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for PwsFailedCellIdList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PwsFailedCellIdList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PwsFailedCellIdList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PwsFailedCellIdList");
			e
		})
	}
}
// QmcConfigInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QmcConfigInfo {
	pub ue_app_layer_meas_info_list: UeAppLayerMeasInfoList,
}

impl QmcConfigInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_app_layer_meas_info_list = UeAppLayerMeasInfoList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_app_layer_meas_info_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_app_layer_meas_info_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QmcConfigInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QmcConfigInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QmcConfigInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QmcConfigInfo");
			e
		})
	}
}
// QmcDeactivation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QmcDeactivation {
	pub qo_e_reference_list: QoEReferenceList,
}

impl QmcDeactivation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qo_e_reference_list = QoEReferenceList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qo_e_reference_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qo_e_reference_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QmcDeactivation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QmcDeactivation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QmcDeactivation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QmcDeactivation");
			e
		})
	}
}
// QoEReferenceList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QoEReferenceList(pub NonEmpty<QoEReference>);

impl QoEReferenceList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QoEReference::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QoEReferenceList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QoEReferenceList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEReferenceList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEReferenceList");
			e
		})
	}
}
// QoEReference
#[derive(Clone, Debug)]
pub struct QoEReference(pub [u8; 6]);
impl Default for QoEReference {
	fn default() -> QoEReference {
		let init = std::mem::MaybeUninit::<[u8; 6]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		QoEReference(default_value)
	}
}
impl QoEReference {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(6), Some(6), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(6), Some(6), false, &(self.0).into(), false)
	}
}

impl PerCodec for QoEReference {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QoEReference::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEReference");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEReference");
			e
		})
	}
}
// QosCharacteristics
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum QosCharacteristics {
	#[default]
	NonDynamic5qi(NonDynamic5qiDescriptor),
	Dynamic5qi(Dynamic5qiDescriptor),
}

impl QosCharacteristics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NonDynamic5qi(NonDynamic5qiDescriptor::decode(data)?)),
			1 => Ok(Self::Dynamic5qi(Dynamic5qiDescriptor::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NonDynamic5qi(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Dynamic5qi(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for QosCharacteristics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosCharacteristics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosCharacteristics");
			e
		})
	}
}
// QosFlowAcceptedList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAcceptedList(pub NonEmpty<QosFlowAcceptedItem>);

impl QosFlowAcceptedList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowAcceptedItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAcceptedList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAcceptedList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAcceptedList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAcceptedList");
			e
		})
	}
}
// QosFlowAcceptedItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAcceptedItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowAcceptedItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container
		let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					221 => {
						current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			current_qos_para_set_index,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.current_qos_para_set_index {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAcceptedItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAcceptedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAcceptedItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAcceptedItem");
			e
		})
	}
}
// QosFlowAddOrModifyRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAddOrModifyRequestList(pub NonEmpty<QosFlowAddOrModifyRequestItem>);

impl QosFlowAddOrModifyRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowAddOrModifyRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAddOrModifyRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAddOrModifyRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyRequestList");
			e
		})
	}
}
// QosFlowAddOrModifyRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAddOrModifyRequestItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub qos_flow_level_qos_parameters: Option<QosFlowLevelQosParameters>,
	pub e_rab_id: Option<ERabId>,
	pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
	pub redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator>,
}

impl QosFlowAddOrModifyRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let qos_flow_level_qos_parameters = if optionals[0] {
			Some(QosFlowLevelQosParameters::decode(data)?)
		} else {
			None
		};
		let e_rab_id = if optionals[1] {
			Some(ERabId::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;
		let mut redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					196 => {
						tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
					}
					194 => {
						redundant_qos_flow_indicator =
							Some(RedundantQosFlowIndicator::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			qos_flow_level_qos_parameters,
			e_rab_id,
			tsc_traffic_characteristics,
			redundant_qos_flow_indicator,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tsc_traffic_characteristics {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 196, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_qos_flow_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 194, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.qos_flow_level_qos_parameters.is_some());
		optionals.push(self.e_rab_id.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.qos_flow_level_qos_parameters {
			x.encode(data)?;
		}
		if let Some(x) = &self.e_rab_id {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAddOrModifyRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAddOrModifyRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyRequestItem");
			e
		})
	}
}
// QosFlowAddOrModifyResponseList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAddOrModifyResponseList(pub NonEmpty<QosFlowAddOrModifyResponseItem>);

impl QosFlowAddOrModifyResponseList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowAddOrModifyResponseItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAddOrModifyResponseList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAddOrModifyResponseList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyResponseList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyResponseList");
			e
		})
	}
}
// QosFlowAddOrModifyResponseItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowAddOrModifyResponseItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowAddOrModifyResponseItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container
		let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					221 => {
						current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			current_qos_para_set_index,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.current_qos_para_set_index {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowAddOrModifyResponseItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowAddOrModifyResponseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyResponseItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowAddOrModifyResponseItem");
			e
		})
	}
}
// QosFlowFeedbackList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowFeedbackList(pub NonEmpty<QosFlowFeedbackItem>);

impl QosFlowFeedbackList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowFeedbackItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowFeedbackList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowFeedbackList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowFeedbackList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowFeedbackList");
			e
		})
	}
}
// QosFlowFeedbackItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowFeedbackItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub update_feedback: Option<UpdateFeedback>,
	pub c_npacket_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
	pub c_npacket_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
}

impl QosFlowFeedbackItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let update_feedback = if optionals[0] {
			Some(UpdateFeedback::decode(data)?)
		} else {
			None
		};
		let c_npacket_delay_budget_dl = if optionals[1] {
			Some(ExtendedPacketDelayBudget::decode(data)?)
		} else {
			None
		};
		let c_npacket_delay_budget_ul = if optionals[2] {
			Some(ExtendedPacketDelayBudget::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			update_feedback,
			c_npacket_delay_budget_dl,
			c_npacket_delay_budget_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.update_feedback.is_some());
		optionals.push(self.c_npacket_delay_budget_dl.is_some());
		optionals.push(self.c_npacket_delay_budget_ul.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.update_feedback {
			x.encode(data)?;
		}
		if let Some(x) = &self.c_npacket_delay_budget_dl {
			x.encode(data)?;
		}
		if let Some(x) = &self.c_npacket_delay_budget_ul {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for QosFlowFeedbackItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowFeedbackItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowFeedbackItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowFeedbackItem");
			e
		})
	}
}
// QosFlowIdentifier
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct QosFlowIdentifier(pub u8);

impl QosFlowIdentifier {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(63), true)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(63), true, self.0 as i128, false)
	}
}

impl PerCodec for QosFlowIdentifier {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowIdentifier::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowIdentifier");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowIdentifier");
			e
		})
	}
}
// QosFlowInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowInformationList(pub NonEmpty<QosFlowInformationItem>);

impl QosFlowInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowInformationList");
			e
		})
	}
}
// QosFlowInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowInformationItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub dl_forwarding: Option<DlForwarding>,
	pub ul_forwarding: Option<UlForwarding>,
	pub source_tnl_addr_info: Option<TransportLayerAddress>,
	pub source_node_tnl_addr_info: Option<TransportLayerAddress>,
}

impl QosFlowInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let dl_forwarding = if optionals[0] {
			Some(DlForwarding::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut ul_forwarding: Option<UlForwarding> = None;
		let mut source_tnl_addr_info: Option<TransportLayerAddress> = None;
		let mut source_node_tnl_addr_info: Option<TransportLayerAddress> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					163 => ul_forwarding = Some(UlForwarding::decode(data)?),
					284 => source_tnl_addr_info = Some(TransportLayerAddress::decode(data)?),
					354 => source_node_tnl_addr_info = Some(TransportLayerAddress::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			dl_forwarding,
			ul_forwarding,
			source_tnl_addr_info,
			source_node_tnl_addr_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.ul_forwarding {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 163, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.source_tnl_addr_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 284, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.source_node_tnl_addr_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 354, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.dl_forwarding.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.dl_forwarding {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowInformationItem");
			e
		})
	}
}
// QosFlowLevelQosParameters
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowLevelQosParameters {
	pub qos_characteristics: QosCharacteristics,
	pub allocation_and_retention_priority: AllocationAndRetentionPriority,
	pub gbr_qos_information: Option<GbrQosInformation>,
	pub reflective_qos_attribute: Option<ReflectiveQosAttribute>,
	pub additional_qos_flow_information: Option<AdditionalQosFlowInformation>,
	pub qos_monitoring_request: Option<QosMonitoringRequest>,
	pub qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency>,
}

impl QosFlowLevelQosParameters {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let qos_characteristics = QosCharacteristics::decode(data)?;
		let allocation_and_retention_priority = AllocationAndRetentionPriority::decode(data)?;
		let gbr_qos_information = if optionals[0] {
			Some(GbrQosInformation::decode(data)?)
		} else {
			None
		};
		let reflective_qos_attribute = if optionals[1] {
			Some(ReflectiveQosAttribute::decode(data)?)
		} else {
			None
		};
		let additional_qos_flow_information = if optionals[2] {
			Some(AdditionalQosFlowInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut qos_monitoring_request: Option<QosMonitoringRequest> = None;
		let mut qos_monitoring_reporting_frequency: Option<QosMonitoringReportingFrequency> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					181 => qos_monitoring_request = Some(QosMonitoringRequest::decode(data)?),
					276 => {
						qos_monitoring_reporting_frequency =
							Some(QosMonitoringReportingFrequency::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_characteristics,
			allocation_and_retention_priority,
			gbr_qos_information,
			reflective_qos_attribute,
			additional_qos_flow_information,
			qos_monitoring_request,
			qos_monitoring_reporting_frequency,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.qos_monitoring_request {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 181, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qos_monitoring_reporting_frequency {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 276, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.gbr_qos_information.is_some());
		optionals.push(self.reflective_qos_attribute.is_some());
		optionals.push(self.additional_qos_flow_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_characteristics.encode(data)?;
		self.allocation_and_retention_priority.encode(data)?;
		if let Some(x) = &self.gbr_qos_information {
			x.encode(data)?;
		}
		if let Some(x) = &self.reflective_qos_attribute {
			x.encode(data)?;
		}
		if let Some(x) = &self.additional_qos_flow_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowLevelQosParameters {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowLevelQosParameters::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowLevelQosParameters");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowLevelQosParameters");
			e
		})
	}
}
// QosMonitoringRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum QosMonitoringRequest {
	#[default]
	Ul,
	Dl,
	Both,
}

impl QosMonitoringRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for QosMonitoringRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosMonitoringRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosMonitoringRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosMonitoringRequest");
			e
		})
	}
}
// QosMonitoringReportingFrequency
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct QosMonitoringReportingFrequency(pub u16);

impl QosMonitoringReportingFrequency {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(1800), true)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(1800), true, self.0 as i128, false)
	}
}

impl PerCodec for QosMonitoringReportingFrequency {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosMonitoringReportingFrequency::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosMonitoringReportingFrequency");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosMonitoringReportingFrequency");
			e
		})
	}
}
// QosFlowList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowList(pub NonEmpty<QosFlowIdentifier>);

impl QosFlowList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowIdentifier::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowList");
			e
		})
	}
}
// QosFlowListWithCause
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowListWithCause(pub NonEmpty<QosFlowWithCauseItem>);

impl QosFlowListWithCause {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowWithCauseItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowListWithCause {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowListWithCause::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowListWithCause");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowListWithCause");
			e
		})
	}
}
// QosFlowWithCauseItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowWithCauseItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub cause: Cause,
}

impl QosFlowWithCauseItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowWithCauseItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowWithCauseItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowWithCauseItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowWithCauseItem");
			e
		})
	}
}
// QosFlowModifyConfirmList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowModifyConfirmList(pub NonEmpty<QosFlowModifyConfirmItem>);

impl QosFlowModifyConfirmList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowModifyConfirmItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowModifyConfirmList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowModifyConfirmList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowModifyConfirmList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowModifyConfirmList");
			e
		})
	}
}
// QosFlowModifyConfirmItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowModifyConfirmItem {
	pub qos_flow_identifier: QosFlowIdentifier,
}

impl QosFlowModifyConfirmItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowModifyConfirmItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowModifyConfirmItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowModifyConfirmItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowModifyConfirmItem");
			e
		})
	}
}
// QosFlowNotifyList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowNotifyList(pub NonEmpty<QosFlowNotifyItem>);

impl QosFlowNotifyList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowNotifyItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowNotifyList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowNotifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowNotifyList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowNotifyList");
			e
		})
	}
}
// QosFlowNotifyItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowNotifyItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub notification_cause: NotificationCause,
	pub current_qos_para_set_index: Option<AlternativeQosParaSetNotifyIndex>,
}

impl QosFlowNotifyItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let notification_cause = NotificationCause::decode(data)?;

		// Process the extension container
		let mut current_qos_para_set_index: Option<AlternativeQosParaSetNotifyIndex> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					221 => {
						current_qos_para_set_index =
							Some(AlternativeQosParaSetNotifyIndex::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			notification_cause,
			current_qos_para_set_index,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.current_qos_para_set_index {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		self.notification_cause.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowNotifyItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowNotifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowNotifyItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowNotifyItem");
			e
		})
	}
}
// QosFlowParametersList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowParametersList(pub NonEmpty<QosFlowParametersItem>);

impl QosFlowParametersList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowParametersItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowParametersList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowParametersList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowParametersList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowParametersList");
			e
		})
	}
}
// QosFlowParametersItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowParametersItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub alternative_qos_para_set_list: Option<AlternativeQosParaSetList>,
	pub cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget>,
	pub cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget>,
	pub burst_arrival_time_downlink: Option<BurstArrivalTime>,
}

impl QosFlowParametersItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let alternative_qos_para_set_list = if optionals[0] {
			Some(AlternativeQosParaSetList::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut cn_packet_delay_budget_dl: Option<ExtendedPacketDelayBudget> = None;
		let mut cn_packet_delay_budget_ul: Option<ExtendedPacketDelayBudget> = None;
		let mut burst_arrival_time_downlink: Option<BurstArrivalTime> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					187 => {
						cn_packet_delay_budget_dl = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					188 => {
						cn_packet_delay_budget_ul = Some(ExtendedPacketDelayBudget::decode(data)?)
					}
					279 => burst_arrival_time_downlink = Some(BurstArrivalTime::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			alternative_qos_para_set_list,
			cn_packet_delay_budget_dl,
			cn_packet_delay_budget_ul,
			burst_arrival_time_downlink,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.cn_packet_delay_budget_dl {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 187, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.cn_packet_delay_budget_ul {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 188, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.burst_arrival_time_downlink {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 279, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.alternative_qos_para_set_list.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.alternative_qos_para_set_list {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowParametersItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowParametersItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowParametersItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowParametersItem");
			e
		})
	}
}
// QosFlowPerTnlInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowPerTnlInformation {
	pub up_transport_layer_information: UpTransportLayerInformation,
	pub associated_qos_flow_list: AssociatedQosFlowList,
}

impl QosFlowPerTnlInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let up_transport_layer_information = UpTransportLayerInformation::decode(data)?;
		let associated_qos_flow_list = AssociatedQosFlowList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			up_transport_layer_information,
			associated_qos_flow_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.up_transport_layer_information.encode(data)?;
		self.associated_qos_flow_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowPerTnlInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowPerTnlInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformation");
			e
		})
	}
}
// QosFlowPerTnlInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowPerTnlInformationList(pub NonEmpty<QosFlowPerTnlInformationItem>);

impl QosFlowPerTnlInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowPerTnlInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowPerTnlInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowPerTnlInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformationList");
			e
		})
	}
}
// QosFlowPerTnlInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowPerTnlInformationItem {
	pub qos_flow_per_tnl_information: QosFlowPerTnlInformation,
}

impl QosFlowPerTnlInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_per_tnl_information = QosFlowPerTnlInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_per_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_per_tnl_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowPerTnlInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowPerTnlInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowPerTnlInformationItem");
			e
		})
	}
}
// QosFlowSetupRequestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowSetupRequestList(pub NonEmpty<QosFlowSetupRequestItem>);

impl QosFlowSetupRequestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowSetupRequestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowSetupRequestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowSetupRequestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowSetupRequestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowSetupRequestList");
			e
		})
	}
}
// QosFlowSetupRequestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowSetupRequestItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub qos_flow_level_qos_parameters: QosFlowLevelQosParameters,
	pub e_rab_id: Option<ERabId>,
	pub tsc_traffic_characteristics: Option<TscTrafficCharacteristics>,
	pub redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator>,
}

impl QosFlowSetupRequestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let qos_flow_level_qos_parameters = QosFlowLevelQosParameters::decode(data)?;
		let e_rab_id = if optionals[0] {
			Some(ERabId::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut tsc_traffic_characteristics: Option<TscTrafficCharacteristics> = None;
		let mut redundant_qos_flow_indicator: Option<RedundantQosFlowIndicator> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					196 => {
						tsc_traffic_characteristics = Some(TscTrafficCharacteristics::decode(data)?)
					}
					194 => {
						redundant_qos_flow_indicator =
							Some(RedundantQosFlowIndicator::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			qos_flow_level_qos_parameters,
			e_rab_id,
			tsc_traffic_characteristics,
			redundant_qos_flow_indicator,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tsc_traffic_characteristics {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 196, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_qos_flow_indicator {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 194, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.e_rab_id.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		self.qos_flow_level_qos_parameters.encode(data)?;
		if let Some(x) = &self.e_rab_id {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowSetupRequestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowSetupRequestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowSetupRequestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowSetupRequestItem");
			e
		})
	}
}
// QosFlowListWithDataForwarding
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowListWithDataForwarding(pub NonEmpty<QosFlowItemWithDataForwarding>);

impl QosFlowListWithDataForwarding {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowItemWithDataForwarding::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowListWithDataForwarding {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowListWithDataForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowListWithDataForwarding");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowListWithDataForwarding");
			e
		})
	}
}
// QosFlowItemWithDataForwarding
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowItemWithDataForwarding {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub data_forwarding_accepted: Option<DataForwardingAccepted>,
	pub current_qos_para_set_index: Option<AlternativeQosParaSetIndex>,
}

impl QosFlowItemWithDataForwarding {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let data_forwarding_accepted = if optionals[0] {
			Some(DataForwardingAccepted::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut current_qos_para_set_index: Option<AlternativeQosParaSetIndex> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					221 => {
						current_qos_para_set_index = Some(AlternativeQosParaSetIndex::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			data_forwarding_accepted,
			current_qos_para_set_index,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.current_qos_para_set_index {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 221, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.data_forwarding_accepted.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		if let Some(x) = &self.data_forwarding_accepted {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for QosFlowItemWithDataForwarding {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowItemWithDataForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowItemWithDataForwarding");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowItemWithDataForwarding");
			e
		})
	}
}
// QosFlowToBeForwardedList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowToBeForwardedList(pub NonEmpty<QosFlowToBeForwardedItem>);

impl QosFlowToBeForwardedList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowToBeForwardedItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowToBeForwardedList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowToBeForwardedList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowToBeForwardedList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowToBeForwardedList");
			e
		})
	}
}
// QosFlowToBeForwardedItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowToBeForwardedItem {
	pub qos_flow_identifier: QosFlowIdentifier,
}

impl QosFlowToBeForwardedItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowToBeForwardedItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowToBeForwardedItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowToBeForwardedItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowToBeForwardedItem");
			e
		})
	}
}
// QosFlowsUsageReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowsUsageReportList(pub NonEmpty<QosFlowsUsageReportItem>);

impl QosFlowsUsageReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(QosFlowsUsageReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for QosFlowsUsageReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowsUsageReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowsUsageReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowsUsageReportList");
			e
		})
	}
}
// QosFlowsUsageReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct QosFlowsUsageReportItem {
	pub qos_flow_identifier: QosFlowIdentifier,
	pub rat_type: RatType1,
	pub qos_flows_timed_report_list: VolumeTimedReportList,
}

impl QosFlowsUsageReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let qos_flow_identifier = QosFlowIdentifier::decode(data)?;
		let rat_type = RatType1::decode(data)?;
		let qos_flows_timed_report_list = VolumeTimedReportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_identifier,
			rat_type,
			qos_flows_timed_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qos_flow_identifier.encode(data)?;
		self.rat_type.encode(data)?;
		self.qos_flows_timed_report_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for QosFlowsUsageReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowsUsageReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowsUsageReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowsUsageReportItem");
			e
		})
	}
}
// Range
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum Range {
	#[default]
	M50,
	M80,
	M180,
	M200,
	M350,
	M400,
	M500,
	M700,
	M1000,
}

impl Range {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(8), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(8), true, *self as i128, false)
	}
}

impl PerCodec for Range {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Range::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Range");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Range");
			e
		})
	}
}
// RanNodeName
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RanNodeName(pub String);

impl RanNodeName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_printable_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_printable_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for RanNodeName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanNodeName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeName");
			e
		})
	}
}
// RanNodeNameVisibleString
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RanNodeNameVisibleString(pub String);

impl RanNodeNameVisibleString {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_visible_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_visible_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for RanNodeNameVisibleString {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanNodeNameVisibleString::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeNameVisibleString");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeNameVisibleString");
			e
		})
	}
}
// RanNodeNameUtf8String
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RanNodeNameUtf8String(pub String);

impl RanNodeNameUtf8String {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_utf8_string(
			data,
			Some(1),
			Some(150),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_utf8_string(data, Some(1), Some(150), true, &self.0, false)
	}
}

impl PerCodec for RanNodeNameUtf8String {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanNodeNameUtf8String::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeNameUtf8String");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanNodeNameUtf8String");
			e
		})
	}
}
// RanPagingPriority
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RanPagingPriority(pub u16);

impl RanPagingPriority {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(256), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(256), false, self.0 as i128, false)
	}
}

impl PerCodec for RanPagingPriority {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanPagingPriority::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanPagingPriority");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanPagingPriority");
			e
		})
	}
}
// RanStatusTransferTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RanStatusTransferTransparentContainer {
	pub drbs_subject_to_status_transfer_list: DrbsSubjectToStatusTransferList,
}

impl RanStatusTransferTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let drbs_subject_to_status_transfer_list = DrbsSubjectToStatusTransferList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			drbs_subject_to_status_transfer_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.drbs_subject_to_status_transfer_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RanStatusTransferTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanStatusTransferTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanStatusTransferTransparentContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanStatusTransferTransparentContainer");
			e
		})
	}
}
// RanUeNgapId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RanUeNgapId(pub u32);

impl RanUeNgapId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(
			data,
			Some(0),
			Some(4294967295),
			false,
			self.0 as i128,
			false,
		)
	}
}

impl PerCodec for RanUeNgapId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RanUeNgapId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanUeNgapId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RanUeNgapId");
			e
		})
	}
}
// RatInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RatInformation {
	#[default]
	Unlicensed,
	NbIot,
}

impl RatInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RatInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatInformation");
			e
		})
	}
}
// RatRestrictions
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RatRestrictions(pub NonEmpty<RatRestrictionsItem>);

impl RatRestrictions {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(RatRestrictionsItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for RatRestrictions {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatRestrictions::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictions");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictions");
			e
		})
	}
}
// RatRestrictionsItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RatRestrictionsItem {
	pub plmn_identity: PlmnIdentity,
	pub rat_restriction_information: RatRestrictionInformation,
	pub extended_rat_restriction_information: Option<ExtendedRatRestrictionInformation>,
}

impl RatRestrictionsItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let rat_restriction_information = RatRestrictionInformation::decode(data)?;

		// Process the extension container
		let mut extended_rat_restriction_information: Option<ExtendedRatRestrictionInformation> =
			None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					180 => {
						extended_rat_restriction_information =
							Some(ExtendedRatRestrictionInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			rat_restriction_information,
			extended_rat_restriction_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.extended_rat_restriction_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 180, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.rat_restriction_information.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for RatRestrictionsItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatRestrictionsItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictionsItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictionsItem");
			e
		})
	}
}
// RatRestrictionInformation
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RatRestrictionInformation(pub BitString);

impl RatRestrictionInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), true, &self.0, false)
	}
}

impl PerCodec for RatRestrictionInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatRestrictionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictionInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatRestrictionInformation");
			e
		})
	}
}
// RecommendedCellsForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedCellsForPaging {
	pub recommended_cell_list: RecommendedCellList,
}

impl RecommendedCellsForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let recommended_cell_list = RecommendedCellList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			recommended_cell_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.recommended_cell_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RecommendedCellsForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedCellsForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellsForPaging");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellsForPaging");
			e
		})
	}
}
// RecommendedCellList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedCellList(pub NonEmpty<RecommendedCellItem>);

impl RecommendedCellList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(RecommendedCellItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for RecommendedCellList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedCellList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellList");
			e
		})
	}
}
// RecommendedCellItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedCellItem {
	pub ngran_cgi: NgranCgi,
	pub time_stayed_in_cell: Option<u16>,
}

impl RecommendedCellItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let ngran_cgi = NgranCgi::decode(data)?;
		let time_stayed_in_cell = if optionals[0] {
			Some(decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_cgi,
			time_stayed_in_cell,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.time_stayed_in_cell.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_cgi.encode(data)?;
		if let Some(x) = &self.time_stayed_in_cell {
			encode::encode_integer(data, Some(0), Some(4095), false, *x as i128, false)?;
		}

		Ok(())
	}
}

impl PerCodec for RecommendedCellItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedCellItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedCellItem");
			e
		})
	}
}
// RecommendedRanNodesForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedRanNodesForPaging {
	pub recommended_ran_node_list: RecommendedRanNodeList,
}

impl RecommendedRanNodesForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let recommended_ran_node_list = RecommendedRanNodeList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			recommended_ran_node_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.recommended_ran_node_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RecommendedRanNodesForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedRanNodesForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodesForPaging");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodesForPaging");
			e
		})
	}
}
// RecommendedRanNodeList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedRanNodeList(pub NonEmpty<RecommendedRanNodeItem>);

impl RecommendedRanNodeList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(RecommendedRanNodeItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for RecommendedRanNodeList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedRanNodeList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodeList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodeList");
			e
		})
	}
}
// RecommendedRanNodeItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RecommendedRanNodeItem {
	pub amf_paging_target: AmfPagingTarget,
}

impl RecommendedRanNodeItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let amf_paging_target = AmfPagingTarget::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { amf_paging_target })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_paging_target.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RecommendedRanNodeItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RecommendedRanNodeItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodeItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RecommendedRanNodeItem");
			e
		})
	}
}
// RedCapIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RedCapIndication {
	#[default]
	Redcap,
}

impl RedCapIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for RedCapIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RedCapIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedCapIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedCapIndication");
			e
		})
	}
}
// RedirectionVoiceFallback
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RedirectionVoiceFallback {
	#[default]
	Possible,
	NotPossible,
}

impl RedirectionVoiceFallback {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RedirectionVoiceFallback {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RedirectionVoiceFallback::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedirectionVoiceFallback");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedirectionVoiceFallback");
			e
		})
	}
}
// RedundantPduSessionInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RedundantPduSessionInformation {
	pub rsn: Rsn,
	pub pdu_session_pair_id: Option<PduSessionPairId>,
}

impl RedundantPduSessionInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let rsn = Rsn::decode(data)?;

		// Process the extension container
		let mut pdu_session_pair_id: Option<PduSessionPairId> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					331 => pdu_session_pair_id = Some(PduSessionPairId::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			rsn,
			pdu_session_pair_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.pdu_session_pair_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 331, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.rsn.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for RedundantPduSessionInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RedundantPduSessionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedundantPduSessionInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedundantPduSessionInformation");
			e
		})
	}
}
// RedundantQosFlowIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RedundantQosFlowIndicator {
	#[default]
	True,
	False,
}

impl RedundantQosFlowIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), false)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), false, *self as i128, false)
	}
}

impl PerCodec for RedundantQosFlowIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RedundantQosFlowIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedundantQosFlowIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RedundantQosFlowIndicator");
			e
		})
	}
}
// ReflectiveQosAttribute
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ReflectiveQosAttribute {
	#[default]
	SubjectTo,
}

impl ReflectiveQosAttribute {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ReflectiveQosAttribute {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReflectiveQosAttribute::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReflectiveQosAttribute");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReflectiveQosAttribute");
			e
		})
	}
}
// RelativeAmfCapacity
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RelativeAmfCapacity(pub u8);

impl RelativeAmfCapacity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
	}
}

impl PerCodec for RelativeAmfCapacity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RelativeAmfCapacity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RelativeAmfCapacity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RelativeAmfCapacity");
			e
		})
	}
}
// ReportArea
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ReportArea {
	#[default]
	Cell,
}

impl ReportArea {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ReportArea {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportArea::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportArea");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportArea");
			e
		})
	}
}
// RepetitionPeriod
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RepetitionPeriod(pub u32);

impl RepetitionPeriod {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(131071), false)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(131071), false, self.0 as i128, false)
	}
}

impl PerCodec for RepetitionPeriod {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RepetitionPeriod::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RepetitionPeriod");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RepetitionPeriod");
			e
		})
	}
}
// ResetAll
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ResetAll {
	#[default]
	ResetAll,
}

impl ResetAll {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ResetAll {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ResetAll::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResetAll");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResetAll");
			e
		})
	}
}
// ReportAmountMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ReportAmountMdt {
	#[default]
	R1,
	R2,
	R4,
	R8,
	R16,
	R32,
	R64,
	Rinfinity,
}

impl ReportAmountMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(7), false)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(7), false, *self as i128, false)
	}
}

impl PerCodec for ReportAmountMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportAmountMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportAmountMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportAmountMdt");
			e
		})
	}
}
// ReportIntervalMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ReportIntervalMdt {
	#[default]
	Ms120,
	Ms240,
	Ms480,
	Ms640,
	Ms1024,
	Ms2048,
	Ms5120,
	Ms10240,
	Min1,
	Min6,
	Min12,
	Min30,
	Min60,
}

impl ReportIntervalMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(12), false)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(12), false, *self as i128, false)
	}
}

impl PerCodec for ReportIntervalMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ReportIntervalMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportIntervalMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ReportIntervalMdt");
			e
		})
	}
}
// ExtendedReportIntervalMdt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ExtendedReportIntervalMdt {
	#[default]
	Ms20480,
	Ms40960,
}

impl ExtendedReportIntervalMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for ExtendedReportIntervalMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ExtendedReportIntervalMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedReportIntervalMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ExtendedReportIntervalMdt");
			e
		})
	}
}
// ResetType
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum ResetType {
	#[default]
	NgInterface(ResetAll),
	PartOfNgInterface(UeAssociatedLogicalNgConnectionList),
}

impl ResetType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::NgInterface(ResetAll::decode(data)?)),
			1 => Ok(Self::PartOfNgInterface(
				UeAssociatedLogicalNgConnectionList::decode(data)?,
			)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::NgInterface(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::PartOfNgInterface(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for ResetType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ResetType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResetType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ResetType");
			e
		})
	}
}
// RgLevelWirelineAccessCharacteristics
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RgLevelWirelineAccessCharacteristics(pub Vec<u8>);

impl RgLevelWirelineAccessCharacteristics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for RgLevelWirelineAccessCharacteristics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RgLevelWirelineAccessCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RgLevelWirelineAccessCharacteristics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RgLevelWirelineAccessCharacteristics");
			e
		})
	}
}
// RncId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct RncId(pub u16);

impl RncId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
	}
}

impl PerCodec for RncId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RncId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RncId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RncId");
			e
		})
	}
}
// RoutingId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RoutingId(pub Vec<u8>);

impl RoutingId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for RoutingId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RoutingId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RoutingId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RoutingId");
			e
		})
	}
}
// RrcContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RrcContainer(pub Vec<u8>);

impl RrcContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for RrcContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RrcContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcContainer");
			e
		})
	}
}
// RrcEstablishmentCause
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RrcEstablishmentCause {
	#[default]
	Emergency,
	HighPriorityAccess,
	MtAccess,
	MoSignalling,
	MoData,
	MoVoiceCall,
	MoVideoCall,
	MoSms,
	MpsPriorityAccess,
	McsPriorityAccess,
}

impl RrcEstablishmentCause {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(9), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(9), true, *self as i128, false)
	}
}

impl PerCodec for RrcEstablishmentCause {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RrcEstablishmentCause::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcEstablishmentCause");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcEstablishmentCause");
			e
		})
	}
}
// RrcInactiveTransitionReportRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RrcInactiveTransitionReportRequest {
	#[default]
	SubsequentStateTransitionReport,
	SingleRrcConnectedStateReport,
	CancelReport,
}

impl RrcInactiveTransitionReportRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for RrcInactiveTransitionReportRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RrcInactiveTransitionReportRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcInactiveTransitionReportRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcInactiveTransitionReportRequest");
			e
		})
	}
}
// RrcState
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RrcState {
	#[default]
	Inactive,
	Connected,
}

impl RrcState {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RrcState {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RrcState::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcState");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RrcState");
			e
		})
	}
}
// Rsn
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum Rsn {
	#[default]
	V1,
	V2,
}

impl Rsn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for Rsn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Rsn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsn");
			e
		})
	}
}
// RimInformationTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RimInformationTransfer {
	pub target_ran_node_id_rim: TargetRanNodeIdRim,
	pub source_ran_node_id: SourceRanNodeId,
	pub rim_information: RimInformation,
}

impl RimInformationTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let target_ran_node_id_rim = TargetRanNodeIdRim::decode(data)?;
		let source_ran_node_id = SourceRanNodeId::decode(data)?;
		let rim_information = RimInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			target_ran_node_id_rim,
			source_ran_node_id,
			rim_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.target_ran_node_id_rim.encode(data)?;
		self.source_ran_node_id.encode(data)?;
		self.rim_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RimInformationTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RimInformationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimInformationTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimInformationTransfer");
			e
		})
	}
}
// RimInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct RimInformation {
	pub target_gnb_set_id: GnbSetId,
	pub rim_rs_detection: RimRsDetection,
}

impl RimInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let target_gnb_set_id = GnbSetId::decode(data)?;
		let rim_rs_detection = RimRsDetection::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			target_gnb_set_id,
			rim_rs_detection,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.target_gnb_set_id.encode(data)?;
		self.rim_rs_detection.encode(data)?;

		Ok(())
	}
}

impl PerCodec for RimInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RimInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimInformation");
			e
		})
	}
}
// GnbSetId
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct GnbSetId(pub BitString);

impl GnbSetId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(22),
			Some(22),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(22), Some(22), false, &self.0, false)
	}
}

impl PerCodec for GnbSetId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		GnbSetId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GnbSetId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("GnbSetId");
			e
		})
	}
}
// ScheduledCommunicationTime
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ScheduledCommunicationTime {
	pub dayof_week: Option<BitString>,
	pub timeof_day_start: Option<u32>,
	pub timeof_day_end: Option<u32>,
}

impl ScheduledCommunicationTime {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let dayof_week = if optionals[0] {
			Some(decode::decode_bitstring(data, Some(7), Some(7), false)?)
		} else {
			None
		};
		let timeof_day_start = if optionals[1] {
			Some(decode::decode_integer(data, Some(0), Some(86399), true)?.0 as u32)
		} else {
			None
		};
		let timeof_day_end = if optionals[2] {
			Some(decode::decode_integer(data, Some(0), Some(86399), true)?.0 as u32)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			dayof_week,
			timeof_day_start,
			timeof_day_end,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.dayof_week.is_some());
		optionals.push(self.timeof_day_start.is_some());
		optionals.push(self.timeof_day_end.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.dayof_week {
			encode::encode_bitstring(data, Some(7), Some(7), false, &x, false)?;
		}
		if let Some(x) = &self.timeof_day_start {
			encode::encode_integer(data, Some(0), Some(86399), true, *x as i128, false)?;
		}
		if let Some(x) = &self.timeof_day_end {
			encode::encode_integer(data, Some(0), Some(86399), true, *x as i128, false)?;
		}

		Ok(())
	}
}

impl PerCodec for ScheduledCommunicationTime {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ScheduledCommunicationTime::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ScheduledCommunicationTime");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ScheduledCommunicationTime");
			e
		})
	}
}
// SctpTlAs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SctpTlAs(pub NonEmpty<TransportLayerAddress>);

impl SctpTlAs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TransportLayerAddress::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SctpTlAs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SctpTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SctpTlAs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SctpTlAs");
			e
		})
	}
}
// Sd
#[derive(Clone, Debug)]
pub struct Sd(pub [u8; 3]);
impl Default for Sd {
	fn default() -> Sd {
		let init = std::mem::MaybeUninit::<[u8; 3]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		Sd(default_value)
	}
}
impl Sd {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(3), Some(3), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
	}
}

impl PerCodec for Sd {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Sd::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Sd");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Sd");
			e
		})
	}
}
// SecondaryRatUsageInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SecondaryRatUsageInformation {
	pub pdu_session_usage_report: Option<PduSessionUsageReport>,
	pub qos_flows_usage_report_list: Option<QosFlowsUsageReportList>,
}

impl SecondaryRatUsageInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let pdu_session_usage_report = if optionals[0] {
			Some(PduSessionUsageReport::decode(data)?)
		} else {
			None
		};
		let qos_flows_usage_report_list = if optionals[1] {
			Some(QosFlowsUsageReportList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			pdu_session_usage_report,
			qos_flows_usage_report_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.pdu_session_usage_report.is_some());
		optionals.push(self.qos_flows_usage_report_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.pdu_session_usage_report {
			x.encode(data)?;
		}
		if let Some(x) = &self.qos_flows_usage_report_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SecondaryRatUsageInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecondaryRatUsageInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecondaryRatUsageInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecondaryRatUsageInformation");
			e
		})
	}
}
// SecondaryRatDataUsageReportTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SecondaryRatDataUsageReportTransfer {
	pub secondary_rat_usage_information: Option<SecondaryRatUsageInformation>,
}

impl SecondaryRatDataUsageReportTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let secondary_rat_usage_information = if optionals[0] {
			Some(SecondaryRatUsageInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			secondary_rat_usage_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.secondary_rat_usage_information.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.secondary_rat_usage_information {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SecondaryRatDataUsageReportTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecondaryRatDataUsageReportTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecondaryRatDataUsageReportTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecondaryRatDataUsageReportTransfer");
			e
		})
	}
}
// SecurityContext
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SecurityContext {
	pub next_hop_chaining_count: NextHopChainingCount,
	pub next_hop_nh: SecurityKey,
}

impl SecurityContext {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let next_hop_chaining_count = NextHopChainingCount::decode(data)?;
		let next_hop_nh = SecurityKey::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			next_hop_chaining_count,
			next_hop_nh,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.next_hop_chaining_count.encode(data)?;
		self.next_hop_nh.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SecurityContext {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecurityContext::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityContext");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityContext");
			e
		})
	}
}
// SecurityIndication
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SecurityIndication {
	pub integrity_protection_indication: IntegrityProtectionIndication,
	pub confidentiality_protection_indication: ConfidentialityProtectionIndication,
	pub maximum_integrity_protected_data_rate_ul: Option<MaximumIntegrityProtectedDataRate>,
	pub maximum_integrity_protected_data_rate_dl: Option<MaximumIntegrityProtectedDataRate>,
}

impl SecurityIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let integrity_protection_indication = IntegrityProtectionIndication::decode(data)?;
		let confidentiality_protection_indication =
			ConfidentialityProtectionIndication::decode(data)?;
		let maximum_integrity_protected_data_rate_ul = if optionals[0] {
			Some(MaximumIntegrityProtectedDataRate::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut maximum_integrity_protected_data_rate_dl: Option<
			MaximumIntegrityProtectedDataRate,
		> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					151 => {
						maximum_integrity_protected_data_rate_dl =
							Some(MaximumIntegrityProtectedDataRate::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			integrity_protection_indication,
			confidentiality_protection_indication,
			maximum_integrity_protected_data_rate_ul,
			maximum_integrity_protected_data_rate_dl,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.maximum_integrity_protected_data_rate_dl {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 151, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.maximum_integrity_protected_data_rate_ul.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.integrity_protection_indication.encode(data)?;
		self.confidentiality_protection_indication.encode(data)?;
		if let Some(x) = &self.maximum_integrity_protected_data_rate_ul {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for SecurityIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecurityIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityIndication");
			e
		})
	}
}
// SecurityKey
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct SecurityKey(pub BitString);

impl SecurityKey {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(256),
			Some(256),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(256), Some(256), false, &self.0, false)
	}
}

impl PerCodec for SecurityKey {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecurityKey::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityKey");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityKey");
			e
		})
	}
}
// SecurityResult
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SecurityResult {
	pub integrity_protection_result: IntegrityProtectionResult,
	pub confidentiality_protection_result: ConfidentialityProtectionResult,
}

impl SecurityResult {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let integrity_protection_result = IntegrityProtectionResult::decode(data)?;
		let confidentiality_protection_result = ConfidentialityProtectionResult::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			integrity_protection_result,
			confidentiality_protection_result,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.integrity_protection_result.encode(data)?;
		self.confidentiality_protection_result.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SecurityResult {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SecurityResult::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityResult");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SecurityResult");
			e
		})
	}
}
// SensorMeasurementConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SensorMeasurementConfiguration {
	pub sensor_meas_config: SensorMeasConfig,
	pub sensor_meas_config_name_list: Option<SensorMeasConfigNameList>,
}

impl SensorMeasurementConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let sensor_meas_config = SensorMeasConfig::decode(data)?;
		let sensor_meas_config_name_list = if optionals[0] {
			Some(SensorMeasConfigNameList::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			sensor_meas_config,
			sensor_meas_config_name_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.sensor_meas_config_name_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.sensor_meas_config.encode(data)?;
		if let Some(x) = &self.sensor_meas_config_name_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SensorMeasurementConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SensorMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasurementConfiguration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasurementConfiguration");
			e
		})
	}
}
// SensorMeasConfigNameList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SensorMeasConfigNameList(pub NonEmpty<SensorMeasConfigNameItem>);

impl SensorMeasConfigNameList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SensorMeasConfigNameItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SensorMeasConfigNameList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SensorMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfigNameList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfigNameList");
			e
		})
	}
}
// SensorMeasConfigNameItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SensorMeasConfigNameItem {
	pub sensor_name_config: SensorNameConfig,
}

impl SensorMeasConfigNameItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let sensor_name_config = SensorNameConfig::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { sensor_name_config })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.sensor_name_config.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SensorMeasConfigNameItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SensorMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfigNameItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfigNameItem");
			e
		})
	}
}
// SensorMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SensorMeasConfig {
	#[default]
	Setup,
}

impl SensorMeasConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SensorMeasConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SensorMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorMeasConfig");
			e
		})
	}
}
// SensorNameConfig
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum SensorNameConfig {
	#[default]
	UncompensatedBarometricConfig(UncompensatedBarometricConfig),
	UeSpeedConfig(UeSpeedConfig),
	UeOrientationConfig(UeOrientationConfig),
}

impl SensorNameConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::UncompensatedBarometricConfig(
				UncompensatedBarometricConfig::decode(data)?,
			)),
			1 => Ok(Self::UeSpeedConfig(UeSpeedConfig::decode(data)?)),
			2 => Ok(Self::UeOrientationConfig(UeOrientationConfig::decode(
				data,
			)?)),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::UncompensatedBarometricConfig(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				x.encode(data)
			}
			Self::UeSpeedConfig(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				x.encode(data)
			}
			Self::UeOrientationConfig(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for SensorNameConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SensorNameConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorNameConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SensorNameConfig");
			e
		})
	}
}
// SerialNumber
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct SerialNumber(pub BitString);

impl SerialNumber {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for SerialNumber {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SerialNumber::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SerialNumber");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SerialNumber");
			e
		})
	}
}
// ServedGuamiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ServedGuamiList(pub NonEmpty<ServedGuamiItem>);

impl ServedGuamiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ServedGuamiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ServedGuamiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ServedGuamiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServedGuamiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServedGuamiList");
			e
		})
	}
}
// ServedGuamiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ServedGuamiItem {
	pub guami: Guami,
	pub backup_amf_name: Option<AmfName>,
	pub guami_type: Option<GuamiType>,
}

impl ServedGuamiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let guami = Guami::decode(data)?;
		let backup_amf_name = if optionals[0] {
			Some(AmfName::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut guami_type: Option<GuamiType> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					176 => guami_type = Some(GuamiType::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			guami,
			backup_amf_name,
			guami_type,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.guami_type {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 176, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.backup_amf_name.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.guami.encode(data)?;
		if let Some(x) = &self.backup_amf_name {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for ServedGuamiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ServedGuamiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServedGuamiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServedGuamiItem");
			e
		})
	}
}
// ServiceAreaInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ServiceAreaInformation(pub NonEmpty<ServiceAreaInformationItem>);

impl ServiceAreaInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(ServiceAreaInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for ServiceAreaInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ServiceAreaInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceAreaInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceAreaInformation");
			e
		})
	}
}
// ServiceAreaInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct ServiceAreaInformationItem {
	pub plmn_identity: PlmnIdentity,
	pub allowed_ta_cs: Option<AllowedTaCs>,
	pub not_allowed_ta_cs: Option<NotAllowedTaCs>,
}

impl ServiceAreaInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let allowed_ta_cs = if optionals[0] {
			Some(AllowedTaCs::decode(data)?)
		} else {
			None
		};
		let not_allowed_ta_cs = if optionals[1] {
			Some(NotAllowedTaCs::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			allowed_ta_cs,
			not_allowed_ta_cs,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.allowed_ta_cs.is_some());
		optionals.push(self.not_allowed_ta_cs.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		if let Some(x) = &self.allowed_ta_cs {
			x.encode(data)?;
		}
		if let Some(x) = &self.not_allowed_ta_cs {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for ServiceAreaInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ServiceAreaInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceAreaInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceAreaInformationItem");
			e
		})
	}
}
// ServiceType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ServiceType {
	#[default]
	Streaming,
	Mtsi,
	Vr,
}

impl ServiceType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for ServiceType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ServiceType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ServiceType");
			e
		})
	}
}
// SGnbUeX2apId
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct SGnbUeX2apId(pub u32);

impl SGnbUeX2apId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4294967295), false)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(
			data,
			Some(0),
			Some(4294967295),
			false,
			self.0 as i128,
			false,
		)
	}
}

impl PerCodec for SGnbUeX2apId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SGnbUeX2apId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SGnbUeX2apId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SGnbUeX2apId");
			e
		})
	}
}
// SharedNguMulticastTnlInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SharedNguMulticastTnlInformation {
	pub ip_multicast_address: TransportLayerAddress,
	pub ip_source_address: TransportLayerAddress,
	pub gtp_teid: GtpTeid,
}

impl SharedNguMulticastTnlInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ip_multicast_address = TransportLayerAddress::decode(data)?;
		let ip_source_address = TransportLayerAddress::decode(data)?;
		let gtp_teid = GtpTeid::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ip_multicast_address,
			ip_source_address,
			gtp_teid,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ip_multicast_address.encode(data)?;
		self.ip_source_address.encode(data)?;
		self.gtp_teid.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SharedNguMulticastTnlInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SharedNguMulticastTnlInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SharedNguMulticastTnlInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SharedNguMulticastTnlInformation");
			e
		})
	}
}
// SliceOverloadList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceOverloadList(pub NonEmpty<SliceOverloadItem>);

impl SliceOverloadList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SliceOverloadItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SliceOverloadList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceOverloadList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceOverloadList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceOverloadList");
			e
		})
	}
}
// SliceOverloadItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceOverloadItem {
	pub snssai: Snssai,
}

impl SliceOverloadItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { snssai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SliceOverloadItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceOverloadItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceOverloadItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceOverloadItem");
			e
		})
	}
}
// SliceSupportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceSupportList(pub NonEmpty<SliceSupportItem>);

impl SliceSupportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(1024), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SliceSupportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(1024), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SliceSupportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportList");
			e
		})
	}
}
// SliceSupportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceSupportItem {
	pub snssai: Snssai,
}

impl SliceSupportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { snssai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SliceSupportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportItem");
			e
		})
	}
}
// SliceSupportListQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceSupportListQmc(pub NonEmpty<SliceSupportQmcItem>);

impl SliceSupportListQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SliceSupportQmcItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SliceSupportListQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceSupportListQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportListQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportListQmc");
			e
		})
	}
}
// SliceSupportQmcItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SliceSupportQmcItem {
	pub snssai: Snssai,
}

impl SliceSupportQmcItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { snssai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SliceSupportQmcItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SliceSupportQmcItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportQmcItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SliceSupportQmcItem");
			e
		})
	}
}
// SnpnMobilityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SnpnMobilityInformation {
	pub serving_nid: Nid,
}

impl SnpnMobilityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let serving_nid = Nid::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { serving_nid })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.serving_nid.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SnpnMobilityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SnpnMobilityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SnpnMobilityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SnpnMobilityInformation");
			e
		})
	}
}
// Snssai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Snssai {
	pub sst: Sst,
	pub sd: Option<Sd>,
}

impl Snssai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let sst = Sst::decode(data)?;
		let sd = if optionals[0] {
			Some(Sd::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { sst, sd })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.sd.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.sst.encode(data)?;
		if let Some(x) = &self.sd {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for Snssai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Snssai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Snssai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Snssai");
			e
		})
	}
}
// SonConfigurationTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SonConfigurationTransfer {
	pub target_ran_node_id_son: TargetRanNodeIdSon,
	pub source_ran_node_id: SourceRanNodeId,
	pub son_information: SonInformation,
	pub xn_tnl_configuration_info: Option<XnTnlConfigurationInfo>,
}

impl SonConfigurationTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let target_ran_node_id_son = TargetRanNodeIdSon::decode(data)?;
		let source_ran_node_id = SourceRanNodeId::decode(data)?;
		let son_information = SonInformation::decode(data)?;
		let xn_tnl_configuration_info = if optionals[0] {
			Some(XnTnlConfigurationInfo::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			target_ran_node_id_son,
			source_ran_node_id,
			son_information,
			xn_tnl_configuration_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.xn_tnl_configuration_info.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.target_ran_node_id_son.encode(data)?;
		self.source_ran_node_id.encode(data)?;
		self.son_information.encode(data)?;
		if let Some(x) = &self.xn_tnl_configuration_info {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SonConfigurationTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SonConfigurationTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonConfigurationTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonConfigurationTransfer");
			e
		})
	}
}
// SonInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum SonInformation {
	#[default]
	SonInformationRequest(SonInformationRequest),
	SonInformationReply(SonInformationReply),
	SonInformationReport(SonInformationReport),
}

impl SonInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::SonInformationRequest(SonInformationRequest::decode(
				data,
			)?)),
			1 => Ok(Self::SonInformationReply(SonInformationReply::decode(
				data,
			)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					252 => Ok(Self::SonInformationReport(SonInformationReport::decode(
						data,
					)?)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::SonInformationRequest(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::SonInformationReply(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
			Self::SonInformationReport(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 252, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for SonInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SonInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformation");
			e
		})
	}
}
// SonInformationReply
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SonInformationReply {
	pub xn_tnl_configuration_info: Option<XnTnlConfigurationInfo>,
}

impl SonInformationReply {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let xn_tnl_configuration_info = if optionals[0] {
			Some(XnTnlConfigurationInfo::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			xn_tnl_configuration_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.xn_tnl_configuration_info.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.xn_tnl_configuration_info {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SonInformationReply {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SonInformationReply::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationReply");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationReply");
			e
		})
	}
}
// SonInformationReport
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum SonInformationReport {
	#[default]
	FailureIndicationInformation(FailureIndication),
	HoReportInformation(HoReport),
	SuccessfulHandoverReportList(SuccessfulHandoverReportList),
}

impl SonInformationReport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::FailureIndicationInformation(
				FailureIndication::decode(data)?,
			)),
			1 => Ok(Self::HoReportInformation(HoReport::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					294 => Ok(Self::SuccessfulHandoverReportList(
						SuccessfulHandoverReportList::decode(data)?,
					)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::FailureIndicationInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::HoReportInformation(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
			Self::SuccessfulHandoverReportList(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 294, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for SonInformationReport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SonInformationReport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationReport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationReport");
			e
		})
	}
}
// SuccessfulHandoverReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SuccessfulHandoverReportList(pub NonEmpty<SuccessfulHandoverReportItem>);

impl SuccessfulHandoverReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SuccessfulHandoverReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SuccessfulHandoverReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SuccessfulHandoverReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuccessfulHandoverReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuccessfulHandoverReportList");
			e
		})
	}
}
// SuccessfulHandoverReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SuccessfulHandoverReportItem {
	pub successful_ho_report_container: Vec<u8>,
}

impl SuccessfulHandoverReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let successful_ho_report_container = decode::decode_octetstring(data, None, None, false)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			successful_ho_report_container,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_octetstring(
			data,
			None,
			None,
			false,
			&self.successful_ho_report_container,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for SuccessfulHandoverReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SuccessfulHandoverReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuccessfulHandoverReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuccessfulHandoverReportItem");
			e
		})
	}
}
// SonInformationRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SonInformationRequest {
	#[default]
	XnTnlConfigurationInfo,
}

impl SonInformationRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SonInformationRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SonInformationRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SonInformationRequest");
			e
		})
	}
}
// SourceNgranNodeToTargetNgranNodeTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SourceNgranNodeToTargetNgranNodeTransparentContainer {
	pub rrc_container: RrcContainer,
	pub pdu_session_resource_information_list: Option<PduSessionResourceInformationList>,
	pub e_rab_information_list: Option<ERabInformationList>,
	pub target_cell_id: NgranCgi,
	pub index_to_rfsp: Option<IndexToRfsp>,
	pub ue_history_information: UeHistoryInformation,
	pub s_gnb_ue_x2ap_id: Option<SGnbUeX2apId>,
	pub ue_history_information_from_the_ue: Option<UeHistoryInformationFromTheUe>,
	pub source_node_id: Option<SourceNodeId>,
	pub ue_context_reference_at_source: Option<RanUeNgapId>,
	pub mbs_active_session_information_sourceto_target_list:
		Option<MbsActiveSessionInformationSourcetoTargetList>,
	pub qmc_config_info: Option<QmcConfigInfo>,
	pub ngapie_support_information_request_list: Option<NgapieSupportInformationRequestList>,
}

impl SourceNgranNodeToTargetNgranNodeTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let rrc_container = RrcContainer::decode(data)?;
		let pdu_session_resource_information_list = if optionals[0] {
			Some(PduSessionResourceInformationList::decode(data)?)
		} else {
			None
		};
		let e_rab_information_list = if optionals[1] {
			Some(ERabInformationList::decode(data)?)
		} else {
			None
		};
		let target_cell_id = NgranCgi::decode(data)?;
		let index_to_rfsp = if optionals[2] {
			Some(IndexToRfsp::decode(data)?)
		} else {
			None
		};
		let ue_history_information = UeHistoryInformation::decode(data)?;

		// Process the extension container
		let mut s_gnb_ue_x2ap_id: Option<SGnbUeX2apId> = None;
		let mut ue_history_information_from_the_ue: Option<UeHistoryInformationFromTheUe> = None;
		let mut source_node_id: Option<SourceNodeId> = None;
		let mut ue_context_reference_at_source: Option<RanUeNgapId> = None;
		let mut mbs_active_session_information_sourceto_target_list: Option<
			MbsActiveSessionInformationSourcetoTargetList,
		> = None;
		let mut qmc_config_info: Option<QmcConfigInfo> = None;
		let mut ngapie_support_information_request_list: Option<
			NgapieSupportInformationRequestList,
		> = None;

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					182 => s_gnb_ue_x2ap_id = Some(SGnbUeX2apId::decode(data)?),
					253 => {
						ue_history_information_from_the_ue =
							Some(UeHistoryInformationFromTheUe::decode(data)?)
					}
					286 => source_node_id = Some(SourceNodeId::decode(data)?),
					288 => ue_context_reference_at_source = Some(RanUeNgapId::decode(data)?),
					323 => {
						mbs_active_session_information_sourceto_target_list =
							Some(MbsActiveSessionInformationSourcetoTargetList::decode(data)?)
					}
					328 => qmc_config_info = Some(QmcConfigInfo::decode(data)?),
					355 => {
						ngapie_support_information_request_list =
							Some(NgapieSupportInformationRequestList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			rrc_container,
			pdu_session_resource_information_list,
			e_rab_information_list,
			target_cell_id,
			index_to_rfsp,
			ue_history_information,
			s_gnb_ue_x2ap_id,
			ue_history_information_from_the_ue,
			source_node_id,
			ue_context_reference_at_source,
			mbs_active_session_information_sourceto_target_list,
			qmc_config_info,
			ngapie_support_information_request_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.s_gnb_ue_x2ap_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 182, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ue_history_information_from_the_ue {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 253, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.source_node_id {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 286, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ue_context_reference_at_source {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 288, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_active_session_information_sourceto_target_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 323, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.qmc_config_info {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 328, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ngapie_support_information_request_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 355, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.pdu_session_resource_information_list.is_some());
		optionals.push(self.e_rab_information_list.is_some());
		optionals.push(self.index_to_rfsp.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.rrc_container.encode(data)?;
		if let Some(x) = &self.pdu_session_resource_information_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.e_rab_information_list {
			x.encode(data)?;
		}
		self.target_cell_id.encode(data)?;
		if let Some(x) = &self.index_to_rfsp {
			x.encode(data)?;
		}
		self.ue_history_information.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for SourceNgranNodeToTargetNgranNodeTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceNgranNodeToTargetNgranNodeTransparentContainer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("SourceNgranNodeToTargetNgranNodeTransparentContainer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceNgranNodeToTargetNgranNodeTransparentContainer");
			e
		})
	}
}
// SourceNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum SourceNodeId {
	#[default]
	SourceenGnbId(GlobalGnbId),
}

impl SourceNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::SourceenGnbId(GlobalGnbId::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::SourceenGnbId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for SourceNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceNodeId");
			e
		})
	}
}
// SourceOfUeActivityBehaviourInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SourceOfUeActivityBehaviourInformation {
	#[default]
	SubscriptionInformation,
	Statistics,
}

impl SourceOfUeActivityBehaviourInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for SourceOfUeActivityBehaviourInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceOfUeActivityBehaviourInformation::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("SourceOfUeActivityBehaviourInformation");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceOfUeActivityBehaviourInformation");
			e
		})
	}
}
// SourceRanNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SourceRanNodeId {
	pub global_ran_node_id: GlobalRanNodeId,
	pub selected_tai: Tai,
}

impl SourceRanNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;
		let selected_tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_ran_node_id,
			selected_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;
		self.selected_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for SourceRanNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceRanNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceRanNodeId");
			e
		})
	}
}
// SourceToTargetTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SourceToTargetTransparentContainer(pub Vec<u8>);

impl SourceToTargetTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for SourceToTargetTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceToTargetTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceToTargetTransparentContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceToTargetTransparentContainer");
			e
		})
	}
}
// SourceToTargetAmfInformationReroute
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SourceToTargetAmfInformationReroute {
	pub configured_nssai: Option<ConfiguredNssai>,
	pub rejected_nssa_iin_plmn: Option<RejectedNssaIinPlmn>,
	pub rejected_nssa_iin_ta: Option<RejectedNssaIinTa>,
}

impl SourceToTargetAmfInformationReroute {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let configured_nssai = if optionals[0] {
			Some(ConfiguredNssai::decode(data)?)
		} else {
			None
		};
		let rejected_nssa_iin_plmn = if optionals[1] {
			Some(RejectedNssaIinPlmn::decode(data)?)
		} else {
			None
		};
		let rejected_nssa_iin_ta = if optionals[2] {
			Some(RejectedNssaIinTa::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			configured_nssai,
			rejected_nssa_iin_plmn,
			rejected_nssa_iin_ta,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.configured_nssai.is_some());
		optionals.push(self.rejected_nssa_iin_plmn.is_some());
		optionals.push(self.rejected_nssa_iin_ta.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.configured_nssai {
			x.encode(data)?;
		}
		if let Some(x) = &self.rejected_nssa_iin_plmn {
			x.encode(data)?;
		}
		if let Some(x) = &self.rejected_nssa_iin_ta {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for SourceToTargetAmfInformationReroute {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SourceToTargetAmfInformationReroute::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceToTargetAmfInformationReroute");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SourceToTargetAmfInformationReroute");
			e
		})
	}
}
// SrvccOperationPossible
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SrvccOperationPossible {
	#[default]
	Possible,
	NotPossible,
}

impl SrvccOperationPossible {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for SrvccOperationPossible {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SrvccOperationPossible::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SrvccOperationPossible");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SrvccOperationPossible");
			e
		})
	}
}
// ConfiguredNssai
#[derive(Clone, Debug)]
pub struct ConfiguredNssai(pub [u8; 128]);
impl Default for ConfiguredNssai {
	fn default() -> ConfiguredNssai {
		let init = std::mem::MaybeUninit::<[u8; 128]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		ConfiguredNssai(default_value)
	}
}
impl ConfiguredNssai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(128), Some(128), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(128), Some(128), false, &(self.0).into(), false)
	}
}

impl PerCodec for ConfiguredNssai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ConfiguredNssai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfiguredNssai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ConfiguredNssai");
			e
		})
	}
}
// RejectedNssaIinPlmn
#[derive(Clone, Debug)]
pub struct RejectedNssaIinPlmn(pub [u8; 32]);
impl Default for RejectedNssaIinPlmn {
	fn default() -> RejectedNssaIinPlmn {
		let init = std::mem::MaybeUninit::<[u8; 32]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		RejectedNssaIinPlmn(default_value)
	}
}
impl RejectedNssaIinPlmn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(32), Some(32), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(32), Some(32), false, &(self.0).into(), false)
	}
}

impl PerCodec for RejectedNssaIinPlmn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RejectedNssaIinPlmn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RejectedNssaIinPlmn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RejectedNssaIinPlmn");
			e
		})
	}
}
// RejectedNssaIinTa
#[derive(Clone, Debug)]
pub struct RejectedNssaIinTa(pub [u8; 32]);
impl Default for RejectedNssaIinTa {
	fn default() -> RejectedNssaIinTa {
		let init = std::mem::MaybeUninit::<[u8; 32]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		RejectedNssaIinTa(default_value)
	}
}
impl RejectedNssaIinTa {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(32), Some(32), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(32), Some(32), false, &(self.0).into(), false)
	}
}

impl PerCodec for RejectedNssaIinTa {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RejectedNssaIinTa::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RejectedNssaIinTa");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RejectedNssaIinTa");
			e
		})
	}
}
// Sst
#[derive(Clone, Debug)]
pub struct Sst(pub [u8; 1]);
impl Default for Sst {
	fn default() -> Sst {
		let init = std::mem::MaybeUninit::<[u8; 1]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		Sst(default_value)
	}
}
impl Sst {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(1), Some(1), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(1), Some(1), false, &(self.0).into(), false)
	}
}

impl PerCodec for Sst {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Sst::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Sst");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Sst");
			e
		})
	}
}
// SupportedTaList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SupportedTaList(pub NonEmpty<SupportedTaItem>);

impl SupportedTaList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(SupportedTaItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for SupportedTaList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SupportedTaList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SupportedTaList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SupportedTaList");
			e
		})
	}
}
// SupportedTaItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct SupportedTaItem {
	pub tac: Tac,
	pub broadcast_plmn_list: BroadcastPlmnList,
	pub configured_tac_indication: Option<ConfiguredTacIndication>,
	pub rat_information: Option<RatInformation>,
}

impl SupportedTaItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tac = Tac::decode(data)?;
		let broadcast_plmn_list = BroadcastPlmnList::decode(data)?;

		// Process the extension container
		let mut configured_tac_indication: Option<ConfiguredTacIndication> = None;
		let mut rat_information: Option<RatInformation> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					272 => configured_tac_indication = Some(ConfiguredTacIndication::decode(data)?),
					179 => rat_information = Some(RatInformation::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tac,
			broadcast_plmn_list,
			configured_tac_indication,
			rat_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.configured_tac_indication {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 272, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.rat_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 179, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tac.encode(data)?;
		self.broadcast_plmn_list.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for SupportedTaItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SupportedTaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SupportedTaItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SupportedTaItem");
			e
		})
	}
}
// SuspendIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SuspendIndicator {
	#[default]
	True,
}

impl SuspendIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SuspendIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SuspendIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendIndicator");
			e
		})
	}
}
// SuspendRequestIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SuspendRequestIndication {
	#[default]
	SuspendRequested,
}

impl SuspendRequestIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SuspendRequestIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SuspendRequestIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendRequestIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendRequestIndication");
			e
		})
	}
}
// SuspendResponseIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SuspendResponseIndication {
	#[default]
	SuspendIndicated,
}

impl SuspendResponseIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SuspendResponseIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SuspendResponseIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendResponseIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SuspendResponseIndication");
			e
		})
	}
}
// SurvivalTime
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct SurvivalTime(pub u32);

impl SurvivalTime {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(1920000), true)?.0 as u32,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(1920000), true, self.0 as i128, false)
	}
}

impl PerCodec for SurvivalTime {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SurvivalTime::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SurvivalTime");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SurvivalTime");
			e
		})
	}
}
// Tac
#[derive(Clone, Debug)]
pub struct Tac(pub [u8; 3]);
impl Default for Tac {
	fn default() -> Tac {
		let init = std::mem::MaybeUninit::<[u8; 3]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		Tac(default_value)
	}
}
impl Tac {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(3), Some(3), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(3), Some(3), false, &(self.0).into(), false)
	}
}

impl PerCodec for Tac {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Tac::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tac");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tac");
			e
		})
	}
}
// TacListInNrNtn
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TacListInNrNtn(pub NonEmpty<Tac>);

impl TacListInNrNtn {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(12), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(12), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TacListInNrNtn {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TacListInNrNtn::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TacListInNrNtn");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TacListInNrNtn");
			e
		})
	}
}
// Tai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct Tai {
	pub plmn_identity: PlmnIdentity,
	pub tac: Tac,
}

impl Tai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let tac = Tac::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { plmn_identity, tac })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		self.tac.encode(data)?;

		Ok(())
	}
}

impl PerCodec for Tai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Tai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tai");
			e
		})
	}
}
// TaiBroadcastEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBroadcastEutra(pub NonEmpty<TaiBroadcastEutraItem>);

impl TaiBroadcastEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiBroadcastEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiBroadcastEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBroadcastEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastEutra");
			e
		})
	}
}
// TaiBroadcastEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBroadcastEutraItem {
	pub tai: Tai,
	pub completed_cells_in_tai_eutra: CompletedCellsInTaiEutra,
}

impl TaiBroadcastEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;
		let completed_cells_in_tai_eutra = CompletedCellsInTaiEutra::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tai,
			completed_cells_in_tai_eutra,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;
		self.completed_cells_in_tai_eutra.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiBroadcastEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBroadcastEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastEutraItem");
			e
		})
	}
}
// TaiBroadcastNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBroadcastNr(pub NonEmpty<TaiBroadcastNrItem>);

impl TaiBroadcastNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiBroadcastNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiBroadcastNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBroadcastNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastNr");
			e
		})
	}
}
// TaiBroadcastNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBroadcastNrItem {
	pub tai: Tai,
	pub completed_cells_in_tai_nr: CompletedCellsInTaiNr,
}

impl TaiBroadcastNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;
		let completed_cells_in_tai_nr = CompletedCellsInTaiNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tai,
			completed_cells_in_tai_nr,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;
		self.completed_cells_in_tai_nr.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiBroadcastNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBroadcastNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBroadcastNrItem");
			e
		})
	}
}
// TaiCancelledEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiCancelledEutra(pub NonEmpty<TaiCancelledEutraItem>);

impl TaiCancelledEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiCancelledEutraItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiCancelledEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiCancelledEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledEutra");
			e
		})
	}
}
// TaiCancelledEutraItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiCancelledEutraItem {
	pub tai: Tai,
	pub cancelled_cells_in_tai_eutra: CancelledCellsInTaiEutra,
}

impl TaiCancelledEutraItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;
		let cancelled_cells_in_tai_eutra = CancelledCellsInTaiEutra::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tai,
			cancelled_cells_in_tai_eutra,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;
		self.cancelled_cells_in_tai_eutra.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiCancelledEutraItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiCancelledEutraItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledEutraItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledEutraItem");
			e
		})
	}
}
// TaiCancelledNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiCancelledNr(pub NonEmpty<TaiCancelledNrItem>);

impl TaiCancelledNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiCancelledNrItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiCancelledNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiCancelledNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledNr");
			e
		})
	}
}
// TaiCancelledNrItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiCancelledNrItem {
	pub tai: Tai,
	pub cancelled_cells_in_tai_nr: CancelledCellsInTaiNr,
}

impl TaiCancelledNrItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;
		let cancelled_cells_in_tai_nr = CancelledCellsInTaiNr::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tai,
			cancelled_cells_in_tai_nr,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;
		self.cancelled_cells_in_tai_nr.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiCancelledNrItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiCancelledNrItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledNrItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiCancelledNrItem");
			e
		})
	}
}
// TaiListForInactive
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForInactive(pub NonEmpty<TaiListForInactiveItem>);

impl TaiListForInactive {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiListForInactiveItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListForInactive {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForInactive::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForInactive");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForInactive");
			e
		})
	}
}
// TaiListForInactiveItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForInactiveItem {
	pub tai: Tai,
}

impl TaiListForInactiveItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiListForInactiveItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForInactiveItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForInactiveItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForInactiveItem");
			e
		})
	}
}
// TaiListForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForPaging(pub NonEmpty<TaiListForPagingItem>);

impl TaiListForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TaiListForPagingItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForPaging");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForPaging");
			e
		})
	}
}
// TaiListForPagingItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForPagingItem {
	pub tai: Tai,
}

impl TaiListForPagingItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiListForPagingItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForPagingItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForPagingItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForPagingItem");
			e
		})
	}
}
// TaiListForRestart
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForRestart(pub NonEmpty<Tai>);

impl TaiListForRestart {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2048), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2048), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListForRestart {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForRestart::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForRestart");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForRestart");
			e
		})
	}
}
// TaiListForWarning
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListForWarning(pub NonEmpty<Tai>);

impl TaiListForWarning {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65535), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListForWarning {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListForWarning::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForWarning");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListForWarning");
			e
		})
	}
}
// TainsagSupportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TainsagSupportList(pub NonEmpty<TainsagSupportItem>);

impl TainsagSupportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TainsagSupportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TainsagSupportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TainsagSupportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TainsagSupportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TainsagSupportList");
			e
		})
	}
}
// TainsagSupportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TainsagSupportItem {
	pub nsag_id: NsagId,
	pub nsag_slice_support_list: ExtendedSliceSupportList,
}

impl TainsagSupportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nsag_id = NsagId::decode(data)?;
		let nsag_slice_support_list = ExtendedSliceSupportList::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nsag_id,
			nsag_slice_support_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nsag_id.encode(data)?;
		self.nsag_slice_support_list.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TainsagSupportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TainsagSupportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TainsagSupportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TainsagSupportItem");
			e
		})
	}
}
// TargetEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetEnbId {
	pub global_enb_id: GlobalNgEnbId,
	pub selected_eps_tai: EpsTai,
}

impl TargetEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_enb_id = GlobalNgEnbId::decode(data)?;
		let selected_eps_tai = EpsTai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_enb_id,
			selected_eps_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_enb_id.encode(data)?;
		self.selected_eps_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetEnbId");
			e
		})
	}
}
// TargetHomeEnbId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetHomeEnbId {
	pub plmn_identity: PlmnIdentity,
	pub home_enb_id: BitString,
	pub selected_eps_tai: EpsTai,
}

impl TargetHomeEnbId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let plmn_identity = PlmnIdentity::decode(data)?;
		let home_enb_id = decode::decode_bitstring(data, Some(28), Some(28), false)?;
		let selected_eps_tai = EpsTai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			plmn_identity,
			home_enb_id,
			selected_eps_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.plmn_identity.encode(data)?;
		encode::encode_bitstring(data, Some(28), Some(28), false, &self.home_enb_id, false)?;
		self.selected_eps_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetHomeEnbId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetHomeEnbId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetHomeEnbId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetHomeEnbId");
			e
		})
	}
}
// TargetId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum TargetId {
	#[default]
	TargetRanNodeId(TargetRanNodeId),
	TargetEnbId(TargetEnbId),
	TargetRncId(TargetRncId),
	TargetHomeEnbId(TargetHomeEnbId),
}

impl TargetId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::TargetRanNodeId(TargetRanNodeId::decode(data)?)),
			1 => Ok(Self::TargetEnbId(TargetEnbId::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					178 => Ok(Self::TargetRncId(TargetRncId::decode(data)?)),
					364 => Ok(Self::TargetHomeEnbId(TargetHomeEnbId::decode(data)?)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::TargetRanNodeId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::TargetEnbId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
			Self::TargetRncId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 178, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::TargetHomeEnbId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 364, false)?;
				Criticality::Reject.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for TargetId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetId");
			e
		})
	}
}
// TargetNgranNodeToSourceNgranNodeTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetNgranNodeToSourceNgranNodeTransparentContainer {
	pub rrc_container: RrcContainer,
	pub daps_response_info_list: Option<DapsResponseInfoList>,
	pub direct_forwarding_path_availability: Option<DirectForwardingPathAvailability>,
	pub mbs_active_session_information_targetto_source_list:
		Option<MbsActiveSessionInformationTargettoSourceList>,
	pub ngapie_support_information_response_list: Option<NgapieSupportInformationResponseList>,
}

impl TargetNgranNodeToSourceNgranNodeTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let rrc_container = RrcContainer::decode(data)?;

		// Process the extension container
		let mut daps_response_info_list: Option<DapsResponseInfoList> = None;
		let mut direct_forwarding_path_availability: Option<DirectForwardingPathAvailability> =
			None;
		let mut mbs_active_session_information_targetto_source_list: Option<
			MbsActiveSessionInformationTargettoSourceList,
		> = None;
		let mut ngapie_support_information_response_list: Option<
			NgapieSupportInformationResponseList,
		> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					267 => daps_response_info_list = Some(DapsResponseInfoList::decode(data)?),
					22 => {
						direct_forwarding_path_availability =
							Some(DirectForwardingPathAvailability::decode(data)?)
					}
					324 => {
						mbs_active_session_information_targetto_source_list =
							Some(MbsActiveSessionInformationTargettoSourceList::decode(data)?)
					}
					356 => {
						ngapie_support_information_response_list =
							Some(NgapieSupportInformationResponseList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			rrc_container,
			daps_response_info_list,
			direct_forwarding_path_availability,
			mbs_active_session_information_targetto_source_list,
			ngapie_support_information_response_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.daps_response_info_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 267, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.direct_forwarding_path_availability {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 22, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.mbs_active_session_information_targetto_source_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 324, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.ngapie_support_information_response_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 356, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.rrc_container.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for TargetNgranNodeToSourceNgranNodeTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetNgranNodeToSourceNgranNodeTransparentContainer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("TargetNgranNodeToSourceNgranNodeTransparentContainer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNgranNodeToSourceNgranNodeTransparentContainer");
			e
		})
	}
}
// TargetNgranNodeToSourceNgranNodeFailureTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
	pub cell_cag_information: Option<CellCagInformation>,
	pub ngapie_support_information_response_list: Option<NgapieSupportInformationResponseList>,
}

impl TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let cell_cag_information = if optionals[0] {
			Some(CellCagInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut ngapie_support_information_response_list: Option<
			NgapieSupportInformationResponseList,
		> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					356 => {
						ngapie_support_information_response_list =
							Some(NgapieSupportInformationResponseList::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			cell_cag_information,
			ngapie_support_information_response_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.ngapie_support_information_response_list {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 356, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.cell_cag_information.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.cell_cag_information {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for TargetNgranNodeToSourceNgranNodeFailureTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetNgranNodeToSourceNgranNodeFailureTransparentContainer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("TargetNgranNodeToSourceNgranNodeFailureTransparentContainer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNgranNodeToSourceNgranNodeFailureTransparentContainer");
			e
		})
	}
}
// TargetNssai
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetNssai(pub NonEmpty<TargetNssaiItem>);

impl TargetNssai {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TargetNssaiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TargetNssai {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetNssai::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssai");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssai");
			e
		})
	}
}
// TargetNssaiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetNssaiItem {
	pub snssai: Snssai,
}

impl TargetNssaiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { snssai })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetNssaiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetNssaiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssaiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssaiItem");
			e
		})
	}
}
// TargetNssaiInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetNssaiInformation {
	pub target_nssai: TargetNssai,
	pub index_to_rfsp: IndexToRfsp,
}

impl TargetNssaiInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let target_nssai = TargetNssai::decode(data)?;
		let index_to_rfsp = IndexToRfsp::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			target_nssai,
			index_to_rfsp,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.target_nssai.encode(data)?;
		self.index_to_rfsp.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetNssaiInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetNssaiInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssaiInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetNssaiInformation");
			e
		})
	}
}
// TargetRanNodeId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetRanNodeId {
	pub global_ran_node_id: GlobalRanNodeId,
	pub selected_tai: Tai,
}

impl TargetRanNodeId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;
		let selected_tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_ran_node_id,
			selected_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;
		self.selected_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetRanNodeId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetRanNodeId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeId");
			e
		})
	}
}
// TargetRanNodeIdRim
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetRanNodeIdRim {
	pub global_ran_node_id: GlobalRanNodeId,
	pub selected_tai: Tai,
}

impl TargetRanNodeIdRim {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;
		let selected_tai = Tai::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_ran_node_id,
			selected_tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;
		self.selected_tai.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TargetRanNodeIdRim {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetRanNodeIdRim::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeIdRim");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeIdRim");
			e
		})
	}
}
// TargetRanNodeIdSon
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetRanNodeIdSon {
	pub global_ran_node_id: GlobalRanNodeId,
	pub selected_tai: Tai,
	pub nr_cgi: Option<NrCgi>,
}

impl TargetRanNodeIdSon {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let global_ran_node_id = GlobalRanNodeId::decode(data)?;
		let selected_tai = Tai::decode(data)?;

		// Process the extension container
		let mut nr_cgi: Option<NrCgi> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					45 => nr_cgi = Some(NrCgi::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			global_ran_node_id,
			selected_tai,
			nr_cgi,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.nr_cgi {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 45, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.global_ran_node_id.encode(data)?;
		self.selected_tai.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for TargetRanNodeIdSon {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetRanNodeIdSon::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeIdSon");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRanNodeIdSon");
			e
		})
	}
}
// TargetRncId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetRncId {
	pub lai: Lai,
	pub rnc_id: RncId,
	pub extended_rnc_id: Option<ExtendedRncId>,
}

impl TargetRncId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let lai = Lai::decode(data)?;
		let rnc_id = RncId::decode(data)?;
		let extended_rnc_id = if optionals[0] {
			Some(ExtendedRncId::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			lai,
			rnc_id,
			extended_rnc_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.extended_rnc_id.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.lai.encode(data)?;
		self.rnc_id.encode(data)?;
		if let Some(x) = &self.extended_rnc_id {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for TargetRncId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetRncId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRncId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetRncId");
			e
		})
	}
}
// TargetToSourceTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargetToSourceTransparentContainer(pub Vec<u8>);

impl TargetToSourceTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for TargetToSourceTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargetToSourceTransparentContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetToSourceTransparentContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargetToSourceTransparentContainer");
			e
		})
	}
}
// TargettoSourceFailureTransparentContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TargettoSourceFailureTransparentContainer(pub Vec<u8>);

impl TargettoSourceFailureTransparentContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for TargettoSourceFailureTransparentContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TargettoSourceFailureTransparentContainer::decode_inner(data).map_err(
			|mut e: PerCodecError| {
				e.push_context("TargettoSourceFailureTransparentContainer");
				e
			},
		)
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TargettoSourceFailureTransparentContainer");
			e
		})
	}
}
// TimerApproachForGuamiRemoval
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TimerApproachForGuamiRemoval {
	#[default]
	ApplyTimer,
}

impl TimerApproachForGuamiRemoval {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for TimerApproachForGuamiRemoval {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimerApproachForGuamiRemoval::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimerApproachForGuamiRemoval");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimerApproachForGuamiRemoval");
			e
		})
	}
}
// TimeStamp
#[derive(Clone, Debug)]
pub struct TimeStamp(pub [u8; 4]);
impl Default for TimeStamp {
	fn default() -> TimeStamp {
		let init = std::mem::MaybeUninit::<[u8; 4]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		TimeStamp(default_value)
	}
}
impl TimeStamp {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(4), Some(4), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(4), Some(4), false, &(self.0).into(), false)
	}
}

impl PerCodec for TimeStamp {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeStamp::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeStamp");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeStamp");
			e
		})
	}
}
// TimeSyncAssistanceInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TimeSyncAssistanceInfo {
	pub time_distribution_indication: TimeDistributionIndication,
	pub uu_time_sync_error_budget: Option<u32>,
}

impl TimeSyncAssistanceInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let time_distribution_indication = TimeDistributionIndication::decode(data)?;
		let uu_time_sync_error_budget = if optionals[0] {
			Some(decode::decode_integer(data, Some(1), Some(1000000), true)?.0 as u32)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			time_distribution_indication,
			uu_time_sync_error_budget,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.uu_time_sync_error_budget.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.time_distribution_indication.encode(data)?;
		if let Some(x) = &self.uu_time_sync_error_budget {
			encode::encode_integer(data, Some(1), Some(1000000), true, *x as i128, false)?;
		}

		Ok(())
	}
}

impl PerCodec for TimeSyncAssistanceInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeSyncAssistanceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeSyncAssistanceInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeSyncAssistanceInfo");
			e
		})
	}
}
// TimeToWait
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TimeToWait {
	#[default]
	V1s,
	V2s,
	V5s,
	V10s,
	V20s,
	V60s,
}

impl TimeToWait {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for TimeToWait {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeToWait::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeToWait");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeToWait");
			e
		})
	}
}
// TimeUeStayedInCell
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct TimeUeStayedInCell(pub u16);

impl TimeUeStayedInCell {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(4095), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(4095), false, self.0 as i128, false)
	}
}

impl PerCodec for TimeUeStayedInCell {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeUeStayedInCell::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeUeStayedInCell");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeUeStayedInCell");
			e
		})
	}
}
// TimeUeStayedInCellEnhancedGranularity
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct TimeUeStayedInCellEnhancedGranularity(pub u16);

impl TimeUeStayedInCellEnhancedGranularity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(40950), false)?.0 as u16,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(40950), false, self.0 as i128, false)
	}
}

impl PerCodec for TimeUeStayedInCellEnhancedGranularity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeUeStayedInCellEnhancedGranularity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeUeStayedInCellEnhancedGranularity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeUeStayedInCellEnhancedGranularity");
			e
		})
	}
}
// Tmgi
#[derive(Clone, Debug)]
pub struct Tmgi(pub [u8; 6]);
impl Default for Tmgi {
	fn default() -> Tmgi {
		let init = std::mem::MaybeUninit::<[u8; 6]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		Tmgi(default_value)
	}
}
impl Tmgi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(6), Some(6), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(6), Some(6), false, &(self.0).into(), false)
	}
}

impl PerCodec for Tmgi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Tmgi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tmgi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Tmgi");
			e
		})
	}
}
// TnapId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TnapId(pub Vec<u8>);

impl TnapId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for TnapId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TnapId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnapId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnapId");
			e
		})
	}
}
// TngfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum TngfId {
	#[default]
	TngfId(BitString),
}

impl TngfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::TngfId(decode::decode_bitstring(
				data,
				Some(32),
				Some(32),
				true,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::TngfId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(32), Some(32), true, &x, false)
			}
		}
	}
}

impl PerCodec for TngfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TngfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TngfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TngfId");
			e
		})
	}
}
// TnlAddressWeightFactor
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct TnlAddressWeightFactor(pub u8);

impl TnlAddressWeightFactor {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(255), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(255), false, self.0 as i128, false)
	}
}

impl PerCodec for TnlAddressWeightFactor {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TnlAddressWeightFactor::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAddressWeightFactor");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAddressWeightFactor");
			e
		})
	}
}
// TnlAssociationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TnlAssociationList(pub NonEmpty<TnlAssociationItem>);

impl TnlAssociationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(32), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TnlAssociationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(32), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TnlAssociationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TnlAssociationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationList");
			e
		})
	}
}
// TnlAssociationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TnlAssociationItem {
	pub tnl_association_address: CpTransportLayerInformation,
	pub cause: Cause,
}

impl TnlAssociationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tnl_association_address = CpTransportLayerInformation::decode(data)?;
		let cause = Cause::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tnl_association_address,
			cause,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tnl_association_address.encode(data)?;
		self.cause.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TnlAssociationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TnlAssociationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationItem");
			e
		})
	}
}
// TnlAssociationUsage
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TnlAssociationUsage {
	#[default]
	Ue,
	NonUe,
	Both,
}

impl TnlAssociationUsage {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for TnlAssociationUsage {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TnlAssociationUsage::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationUsage");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TnlAssociationUsage");
			e
		})
	}
}
// TooearlyIntersystemHo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TooearlyIntersystemHo {
	pub sourcecell_id: EutraCgi,
	pub failurecell_id: NgranCgi,
	pub ue_rlf_report_container: Option<UeRlfReportContainer>,
}

impl TooearlyIntersystemHo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let sourcecell_id = EutraCgi::decode(data)?;
		let failurecell_id = NgranCgi::decode(data)?;
		let ue_rlf_report_container = if optionals[0] {
			Some(UeRlfReportContainer::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			sourcecell_id,
			failurecell_id,
			ue_rlf_report_container,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.ue_rlf_report_container.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.sourcecell_id.encode(data)?;
		self.failurecell_id.encode(data)?;
		if let Some(x) = &self.ue_rlf_report_container {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for TooearlyIntersystemHo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TooearlyIntersystemHo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TooearlyIntersystemHo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TooearlyIntersystemHo");
			e
		})
	}
}
// TraceActivation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TraceActivation {
	pub ngran_trace_id: NgranTraceId,
	pub interfaces_to_trace: InterfacesToTrace,
	pub trace_depth: TraceDepth,
	pub trace_collection_entity_ip_address: TransportLayerAddress,
	pub mdt_configuration: Option<MdtConfiguration>,
	pub trace_collection_entity_uri: Option<UriAddress>,
}

impl TraceActivation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngran_trace_id = NgranTraceId::decode(data)?;
		let interfaces_to_trace = InterfacesToTrace::decode(data)?;
		let trace_depth = TraceDepth::decode(data)?;
		let trace_collection_entity_ip_address = TransportLayerAddress::decode(data)?;

		// Process the extension container
		let mut mdt_configuration: Option<MdtConfiguration> = None;
		let mut trace_collection_entity_uri: Option<UriAddress> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					255 => mdt_configuration = Some(MdtConfiguration::decode(data)?),
					257 => trace_collection_entity_uri = Some(UriAddress::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngran_trace_id,
			interfaces_to_trace,
			trace_depth,
			trace_collection_entity_ip_address,
			mdt_configuration,
			trace_collection_entity_uri,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.mdt_configuration {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 255, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.trace_collection_entity_uri {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 257, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngran_trace_id.encode(data)?;
		self.interfaces_to_trace.encode(data)?;
		self.trace_depth.encode(data)?;
		self.trace_collection_entity_ip_address.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for TraceActivation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TraceActivation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TraceActivation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TraceActivation");
			e
		})
	}
}
// TraceDepth
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TraceDepth {
	#[default]
	Minimum,
	Medium,
	Maximum,
	MinimumWithoutVendorSpecificExtension,
	MediumWithoutVendorSpecificExtension,
	MaximumWithoutVendorSpecificExtension,
}

impl TraceDepth {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(5), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(5), true, *self as i128, false)
	}
}

impl PerCodec for TraceDepth {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TraceDepth::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TraceDepth");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TraceDepth");
			e
		})
	}
}
// TrafficLoadReductionIndication
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct TrafficLoadReductionIndication(pub u8);

impl TrafficLoadReductionIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(1), Some(99), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(1), Some(99), false, self.0 as i128, false)
	}
}

impl PerCodec for TrafficLoadReductionIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TrafficLoadReductionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TrafficLoadReductionIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TrafficLoadReductionIndication");
			e
		})
	}
}
// TypeOfError
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TypeOfError {
	#[default]
	NotUnderstood,
	Missing,
}

impl TypeOfError {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for TypeOfError {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TypeOfError::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TypeOfError");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TypeOfError");
			e
		})
	}
}
// TaiBasedMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBasedMdt {
	pub tai_listfor_mdt: TaiListforMdt,
}

impl TaiBasedMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai_listfor_mdt = TaiListforMdt::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tai_listfor_mdt })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai_listfor_mdt.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiBasedMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBasedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBasedMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBasedMdt");
			e
		})
	}
}
// TaiListforMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListforMdt(pub NonEmpty<Tai>);

impl TaiListforMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListforMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListforMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListforMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListforMdt");
			e
		})
	}
}
// TaiBasedQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiBasedQmc {
	pub tai_listfor_qmc: TaiListforQmc,
}

impl TaiBasedQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let tai_listfor_qmc = TaiListforQmc::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { tai_listfor_qmc })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tai_listfor_qmc.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaiBasedQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiBasedQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBasedQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiBasedQmc");
			e
		})
	}
}
// TaiListforQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaiListforQmc(pub NonEmpty<Tai>);

impl TaiListforQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tai::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaiListforQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaiListforQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListforQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaiListforQmc");
			e
		})
	}
}
// TaBasedQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaBasedQmc {
	pub ta_listfor_qmc: TaListforQmc,
}

impl TaBasedQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ta_listfor_qmc = TaListforQmc::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { ta_listfor_qmc })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ta_listfor_qmc.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaBasedQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaBasedQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaBasedQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaBasedQmc");
			e
		})
	}
}
// TaListforQmc
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaListforQmc(pub NonEmpty<Tac>);

impl TaListforQmc {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaListforQmc {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaListforQmc::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaListforQmc");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaListforQmc");
			e
		})
	}
}
// TaBasedMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaBasedMdt {
	pub ta_listfor_mdt: TaListforMdt,
}

impl TaBasedMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ta_listfor_mdt = TaListforMdt::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { ta_listfor_mdt })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ta_listfor_mdt.encode(data)?;

		Ok(())
	}
}

impl PerCodec for TaBasedMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaBasedMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaBasedMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaBasedMdt");
			e
		})
	}
}
// TaListforMdt
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TaListforMdt(pub NonEmpty<Tac>);

impl TaListforMdt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(Tac::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for TaListforMdt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TaListforMdt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaListforMdt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TaListforMdt");
			e
		})
	}
}
// ThresholdRsrp
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ThresholdRsrp(pub u8);

impl ThresholdRsrp {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
	}
}

impl PerCodec for ThresholdRsrp {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ThresholdRsrp::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdRsrp");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdRsrp");
			e
		})
	}
}
// ThresholdRsrq
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ThresholdRsrq(pub u8);

impl ThresholdRsrq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
	}
}

impl PerCodec for ThresholdRsrq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ThresholdRsrq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdRsrq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdRsrq");
			e
		})
	}
}
// ThresholdSiNr
#[derive(Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct ThresholdSiNr(pub u8);

impl ThresholdSiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_integer(data, Some(0), Some(127), false)?.0 as u8,
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_integer(data, Some(0), Some(127), false, self.0 as i128, false)
	}
}

impl PerCodec for ThresholdSiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ThresholdSiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdSiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ThresholdSiNr");
			e
		})
	}
}
// TimeToTrigger
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TimeToTrigger {
	#[default]
	Ms0,
	Ms40,
	Ms64,
	Ms80,
	Ms100,
	Ms128,
	Ms160,
	Ms256,
	Ms320,
	Ms480,
	Ms512,
	Ms640,
	Ms1024,
	Ms1280,
	Ms2560,
	Ms5120,
}

impl TimeToTrigger {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(15), false)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(15), false, *self as i128, false)
	}
}

impl PerCodec for TimeToTrigger {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeToTrigger::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeToTrigger");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeToTrigger");
			e
		})
	}
}
// TwapId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TwapId(pub Vec<u8>);

impl TwapId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for TwapId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TwapId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TwapId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TwapId");
			e
		})
	}
}
// TwifId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum TwifId {
	#[default]
	TwifId(BitString),
}

impl TwifId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::TwifId(decode::decode_bitstring(
				data,
				Some(32),
				Some(32),
				true,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::TwifId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(32), Some(32), true, &x, false)
			}
		}
	}
}

impl PerCodec for TwifId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TwifId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TwifId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TwifId");
			e
		})
	}
}
// TscAssistanceInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TscAssistanceInformation {
	pub periodicity: Periodicity,
	pub burst_arrival_time: Option<BurstArrivalTime>,
	pub survival_time: Option<SurvivalTime>,
}

impl TscAssistanceInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let periodicity = Periodicity::decode(data)?;
		let burst_arrival_time = if optionals[0] {
			Some(BurstArrivalTime::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut survival_time: Option<SurvivalTime> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					327 => survival_time = Some(SurvivalTime::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			periodicity,
			burst_arrival_time,
			survival_time,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.survival_time {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 327, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.burst_arrival_time.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.periodicity.encode(data)?;
		if let Some(x) = &self.burst_arrival_time {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for TscAssistanceInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TscAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TscAssistanceInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TscAssistanceInformation");
			e
		})
	}
}
// TscTrafficCharacteristics
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct TscTrafficCharacteristics {
	pub tsc_assistance_information_dl: Option<TscAssistanceInformation>,
	pub tsc_assistance_information_ul: Option<TscAssistanceInformation>,
}

impl TscTrafficCharacteristics {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let tsc_assistance_information_dl = if optionals[0] {
			Some(TscAssistanceInformation::decode(data)?)
		} else {
			None
		};
		let tsc_assistance_information_ul = if optionals[1] {
			Some(TscAssistanceInformation::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tsc_assistance_information_dl,
			tsc_assistance_information_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.tsc_assistance_information_dl.is_some());
		optionals.push(self.tsc_assistance_information_ul.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.tsc_assistance_information_dl {
			x.encode(data)?;
		}
		if let Some(x) = &self.tsc_assistance_information_ul {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for TscTrafficCharacteristics {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TscTrafficCharacteristics::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TscTrafficCharacteristics");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TscTrafficCharacteristics");
			e
		})
	}
}
// UeAggregateMaximumBitRate
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAggregateMaximumBitRate {
	pub ue_aggregate_maximum_bit_rate_dl: BitRate,
	pub ue_aggregate_maximum_bit_rate_ul: BitRate,
}

impl UeAggregateMaximumBitRate {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_aggregate_maximum_bit_rate_dl = BitRate::decode(data)?;
		let ue_aggregate_maximum_bit_rate_ul = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_aggregate_maximum_bit_rate_dl,
			ue_aggregate_maximum_bit_rate_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_aggregate_maximum_bit_rate_dl.encode(data)?;
		self.ue_aggregate_maximum_bit_rate_ul.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UeAggregateMaximumBitRate {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAggregateMaximumBitRate::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAggregateMaximumBitRate");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAggregateMaximumBitRate");
			e
		})
	}
}
// UeAppLayerMeasInfoList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAppLayerMeasInfoList(pub NonEmpty<UeAppLayerMeasInfoItem>);

impl UeAppLayerMeasInfoList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UeAppLayerMeasInfoItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UeAppLayerMeasInfoList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAppLayerMeasInfoList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasInfoList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasInfoList");
			e
		})
	}
}
// UeAppLayerMeasInfoItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAppLayerMeasInfoItem {
	pub ue_app_layer_meas_config_info: UeAppLayerMeasConfigInfo,
}

impl UeAppLayerMeasInfoItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ue_app_layer_meas_config_info = UeAppLayerMeasConfigInfo::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_app_layer_meas_config_info,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ue_app_layer_meas_config_info.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UeAppLayerMeasInfoItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAppLayerMeasInfoItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasInfoItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasInfoItem");
			e
		})
	}
}
// UeAppLayerMeasConfigInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAppLayerMeasConfigInfo {
	pub qo_e_reference: QoEReference,
	pub service_type: ServiceType,
	pub area_scope_of_qmc: Option<AreaScopeOfQmc>,
	pub meas_coll_entity_ip_address: TransportLayerAddress,
	pub qo_e_measurement_status: Option<QoEMeasurementStatus>,
	pub container_for_app_layer_meas_config: Option<Vec<u8>>,
	pub meas_config_app_layer_id: Option<u8>,
	pub slice_support_list_qmc: Option<SliceSupportListQmc>,
	pub mdt_alignment_info: Option<MdtAlignmentInfo>,
	pub available_ran_visible_qo_e_metrics: Option<AvailableRanVisibleQoEMetrics>,
}

impl UeAppLayerMeasConfigInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 8)?;
		let qo_e_reference = QoEReference::decode(data)?;
		let service_type = ServiceType::decode(data)?;
		let area_scope_of_qmc = if optionals[0] {
			Some(AreaScopeOfQmc::decode(data)?)
		} else {
			None
		};
		let meas_coll_entity_ip_address = TransportLayerAddress::decode(data)?;
		let qo_e_measurement_status = if optionals[1] {
			Some(QoEMeasurementStatus::decode(data)?)
		} else {
			None
		};
		let container_for_app_layer_meas_config = if optionals[2] {
			Some(decode::decode_octetstring(
				data,
				Some(1),
				Some(8000),
				false,
			)?)
		} else {
			None
		};
		let meas_config_app_layer_id = if optionals[3] {
			Some(decode::decode_integer(data, Some(0), Some(15), true)?.0 as u8)
		} else {
			None
		};
		let slice_support_list_qmc = if optionals[4] {
			Some(SliceSupportListQmc::decode(data)?)
		} else {
			None
		};
		let mdt_alignment_info = if optionals[5] {
			Some(MdtAlignmentInfo::decode(data)?)
		} else {
			None
		};
		let available_ran_visible_qo_e_metrics = if optionals[6] {
			Some(AvailableRanVisibleQoEMetrics::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[7] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qo_e_reference,
			service_type,
			area_scope_of_qmc,
			meas_coll_entity_ip_address,
			qo_e_measurement_status,
			container_for_app_layer_meas_config,
			meas_config_app_layer_id,
			slice_support_list_qmc,
			mdt_alignment_info,
			available_ran_visible_qo_e_metrics,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.area_scope_of_qmc.is_some());
		optionals.push(self.qo_e_measurement_status.is_some());
		optionals.push(self.container_for_app_layer_meas_config.is_some());
		optionals.push(self.meas_config_app_layer_id.is_some());
		optionals.push(self.slice_support_list_qmc.is_some());
		optionals.push(self.mdt_alignment_info.is_some());
		optionals.push(self.available_ran_visible_qo_e_metrics.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.qo_e_reference.encode(data)?;
		self.service_type.encode(data)?;
		if let Some(x) = &self.area_scope_of_qmc {
			x.encode(data)?;
		}
		self.meas_coll_entity_ip_address.encode(data)?;
		if let Some(x) = &self.qo_e_measurement_status {
			x.encode(data)?;
		}
		if let Some(x) = &self.container_for_app_layer_meas_config {
			encode::encode_octetstring(data, Some(1), Some(8000), false, &x, false)?;
		}
		if let Some(x) = &self.meas_config_app_layer_id {
			encode::encode_integer(data, Some(0), Some(15), true, *x as i128, false)?;
		}
		if let Some(x) = &self.slice_support_list_qmc {
			x.encode(data)?;
		}
		if let Some(x) = &self.mdt_alignment_info {
			x.encode(data)?;
		}
		if let Some(x) = &self.available_ran_visible_qo_e_metrics {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeAppLayerMeasConfigInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAppLayerMeasConfigInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasConfigInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAppLayerMeasConfigInfo");
			e
		})
	}
}
// UeAssociatedLogicalNgConnectionList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAssociatedLogicalNgConnectionList(pub NonEmpty<UeAssociatedLogicalNgConnectionItem>);

impl UeAssociatedLogicalNgConnectionList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(65536), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UeAssociatedLogicalNgConnectionItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(65536), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UeAssociatedLogicalNgConnectionList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAssociatedLogicalNgConnectionList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAssociatedLogicalNgConnectionList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAssociatedLogicalNgConnectionList");
			e
		})
	}
}
// UeAssociatedLogicalNgConnectionItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeAssociatedLogicalNgConnectionItem {
	pub amf_ue_ngap_id: Option<AmfUeNgapId>,
	pub ran_ue_ngap_id: Option<RanUeNgapId>,
}

impl UeAssociatedLogicalNgConnectionItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let amf_ue_ngap_id = if optionals[0] {
			Some(AmfUeNgapId::decode(data)?)
		} else {
			None
		};
		let ran_ue_ngap_id = if optionals[1] {
			Some(RanUeNgapId::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_ue_ngap_id,
			ran_ue_ngap_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.amf_ue_ngap_id.is_some());
		optionals.push(self.ran_ue_ngap_id.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.amf_ue_ngap_id {
			x.encode(data)?;
		}
		if let Some(x) = &self.ran_ue_ngap_id {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeAssociatedLogicalNgConnectionItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeAssociatedLogicalNgConnectionItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAssociatedLogicalNgConnectionItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeAssociatedLogicalNgConnectionItem");
			e
		})
	}
}
// UeCapabilityInfoRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeCapabilityInfoRequest {
	#[default]
	Requested,
}

impl UeCapabilityInfoRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeCapabilityInfoRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeCapabilityInfoRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeCapabilityInfoRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeCapabilityInfoRequest");
			e
		})
	}
}
// UeContextRequest
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeContextRequest {
	#[default]
	Requested,
}

impl UeContextRequest {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeContextRequest {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeContextRequest::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextRequest");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextRequest");
			e
		})
	}
}
// UeContextResumeRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeContextResumeRequestTransfer {
	pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
}

impl UeContextResumeRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_failed_to_resume_list = if optionals[0] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_failed_to_resume_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.qos_flow_failed_to_resume_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.qos_flow_failed_to_resume_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeContextResumeRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeContextResumeRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextResumeRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextResumeRequestTransfer");
			e
		})
	}
}
// UeContextResumeResponseTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeContextResumeResponseTransfer {
	pub qos_flow_failed_to_resume_list: Option<QosFlowListWithCause>,
}

impl UeContextResumeResponseTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let qos_flow_failed_to_resume_list = if optionals[0] {
			Some(QosFlowListWithCause::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			qos_flow_failed_to_resume_list,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.qos_flow_failed_to_resume_list.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.qos_flow_failed_to_resume_list {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeContextResumeResponseTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeContextResumeResponseTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextResumeResponseTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextResumeResponseTransfer");
			e
		})
	}
}
// UeContextSuspendRequestTransfer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeContextSuspendRequestTransfer {
	pub suspend_indicator: Option<SuspendIndicator>,
}

impl UeContextSuspendRequestTransfer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let suspend_indicator = if optionals[0] {
			Some(SuspendIndicator::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { suspend_indicator })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.suspend_indicator.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.suspend_indicator {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeContextSuspendRequestTransfer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeContextSuspendRequestTransfer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextSuspendRequestTransfer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeContextSuspendRequestTransfer");
			e
		})
	}
}
// UeDifferentiationInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeDifferentiationInfo {
	pub periodic_communication_indicator: Option<PeriodicCommunicationIndicator>,
	pub periodic_time: Option<u16>,
	pub scheduled_communication_time: Option<ScheduledCommunicationTime>,
	pub stationary_indication: Option<StationaryIndication>,
	pub traffic_profile: Option<TrafficProfile>,
	pub battery_indication: Option<BatteryIndication>,
}

impl UeDifferentiationInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 7)?;
		let periodic_communication_indicator = if optionals[0] {
			Some(PeriodicCommunicationIndicator::decode(data)?)
		} else {
			None
		};
		let periodic_time = if optionals[1] {
			Some(decode::decode_integer(data, Some(1), Some(3600), true)?.0 as u16)
		} else {
			None
		};
		let scheduled_communication_time = if optionals[2] {
			Some(ScheduledCommunicationTime::decode(data)?)
		} else {
			None
		};
		let stationary_indication = if optionals[3] {
			Some(StationaryIndication::decode(data)?)
		} else {
			None
		};
		let traffic_profile = if optionals[4] {
			Some(TrafficProfile::decode(data)?)
		} else {
			None
		};
		let battery_indication = if optionals[5] {
			Some(BatteryIndication::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[6] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			periodic_communication_indicator,
			periodic_time,
			scheduled_communication_time,
			stationary_indication,
			traffic_profile,
			battery_indication,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.periodic_communication_indicator.is_some());
		optionals.push(self.periodic_time.is_some());
		optionals.push(self.scheduled_communication_time.is_some());
		optionals.push(self.stationary_indication.is_some());
		optionals.push(self.traffic_profile.is_some());
		optionals.push(self.battery_indication.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.periodic_communication_indicator {
			x.encode(data)?;
		}
		if let Some(x) = &self.periodic_time {
			encode::encode_integer(data, Some(1), Some(3600), true, *x as i128, false)?;
		}
		if let Some(x) = &self.scheduled_communication_time {
			x.encode(data)?;
		}
		if let Some(x) = &self.stationary_indication {
			x.encode(data)?;
		}
		if let Some(x) = &self.traffic_profile {
			x.encode(data)?;
		}
		if let Some(x) = &self.battery_indication {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UeDifferentiationInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeDifferentiationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeDifferentiationInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeDifferentiationInfo");
			e
		})
	}
}
// UeHistoryInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeHistoryInformation(pub NonEmpty<LastVisitedCellItem>);

impl UeHistoryInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(LastVisitedCellItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UeHistoryInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeHistoryInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeHistoryInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeHistoryInformation");
			e
		})
	}
}
// UeHistoryInformationFromTheUe
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UeHistoryInformationFromTheUe {
	#[default]
	Nr(NrMobilityHistoryReport),
}

impl UeHistoryInformationFromTheUe {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Nr(NrMobilityHistoryReport::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Nr(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for UeHistoryInformationFromTheUe {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeHistoryInformationFromTheUe::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeHistoryInformationFromTheUe");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeHistoryInformationFromTheUe");
			e
		})
	}
}
// UeIdentityIndexValue
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UeIdentityIndexValue {
	#[default]
	IndexLength10(BitString),
}

impl UeIdentityIndexValue {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::IndexLength10(decode::decode_bitstring(
				data,
				Some(10),
				Some(10),
				false,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::IndexLength10(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(10), Some(10), false, &x, false)
			}
		}
	}
}

impl PerCodec for UeIdentityIndexValue {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeIdentityIndexValue::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeIdentityIndexValue");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeIdentityIndexValue");
			e
		})
	}
}
// UeNgapIDs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UeNgapIDs {
	#[default]
	UeNgapIdPair(UeNgapIdPair),
	AmfUeNgapId(AmfUeNgapId),
}

impl UeNgapIDs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::UeNgapIdPair(UeNgapIdPair::decode(data)?)),
			1 => Ok(Self::AmfUeNgapId(AmfUeNgapId::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::UeNgapIdPair(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::AmfUeNgapId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for UeNgapIDs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeNgapIDs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeNgapIDs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeNgapIDs");
			e
		})
	}
}
// UeNgapIdPair
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeNgapIdPair {
	pub amf_ue_ngap_id: AmfUeNgapId,
	pub ran_ue_ngap_id: RanUeNgapId,
}

impl UeNgapIdPair {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let amf_ue_ngap_id = AmfUeNgapId::decode(data)?;
		let ran_ue_ngap_id = RanUeNgapId::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			amf_ue_ngap_id,
			ran_ue_ngap_id,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.amf_ue_ngap_id.encode(data)?;
		self.ran_ue_ngap_id.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UeNgapIdPair {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeNgapIdPair::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeNgapIdPair");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeNgapIdPair");
			e
		})
	}
}
// UePagingIdentity
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UePagingIdentity {
	#[default]
	FiveGSTmsi(FiveGSTmsi),
}

impl UePagingIdentity {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::FiveGSTmsi(FiveGSTmsi::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::FiveGSTmsi(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for UePagingIdentity {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePagingIdentity::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingIdentity");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePagingIdentity");
			e
		})
	}
}
// UePresence
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UePresence {
	#[default]
	In,
	Out,
	Unknown,
}

impl UePresence {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for UePresence {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePresence::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresence");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresence");
			e
		})
	}
}
// UePresenceInAreaOfInterestList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UePresenceInAreaOfInterestList(pub NonEmpty<UePresenceInAreaOfInterestItem>);

impl UePresenceInAreaOfInterestList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(64), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UePresenceInAreaOfInterestItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(64), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UePresenceInAreaOfInterestList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePresenceInAreaOfInterestList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresenceInAreaOfInterestList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresenceInAreaOfInterestList");
			e
		})
	}
}
// UePresenceInAreaOfInterestItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UePresenceInAreaOfInterestItem {
	pub location_reporting_reference_id: LocationReportingReferenceId,
	pub ue_presence: UePresence,
}

impl UePresenceInAreaOfInterestItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let location_reporting_reference_id = LocationReportingReferenceId::decode(data)?;
		let ue_presence = UePresence::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			location_reporting_reference_id,
			ue_presence,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.location_reporting_reference_id.encode(data)?;
		self.ue_presence.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UePresenceInAreaOfInterestItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UePresenceInAreaOfInterestItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresenceInAreaOfInterestItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UePresenceInAreaOfInterestItem");
			e
		})
	}
}
// UeRadioCapability
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapability(pub Vec<u8>);

impl UeRadioCapability {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UeRadioCapability {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapability::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapability");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapability");
			e
		})
	}
}
// UeRadioCapabilityForPaging
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapabilityForPaging {
	pub ue_radio_capability_for_paging_of_nr: Option<UeRadioCapabilityForPagingOfNr>,
	pub ue_radio_capability_for_paging_of_eutra: Option<UeRadioCapabilityForPagingOfEutra>,
	pub ue_radio_capability_for_paging_of_nb_iot: Option<UeRadioCapabilityForPagingOfNbIot>,
}

impl UeRadioCapabilityForPaging {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let ue_radio_capability_for_paging_of_nr = if optionals[0] {
			Some(UeRadioCapabilityForPagingOfNr::decode(data)?)
		} else {
			None
		};
		let ue_radio_capability_for_paging_of_eutra = if optionals[1] {
			Some(UeRadioCapabilityForPagingOfEutra::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut ue_radio_capability_for_paging_of_nb_iot: Option<
			UeRadioCapabilityForPagingOfNbIot,
		> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					214 => {
						ue_radio_capability_for_paging_of_nb_iot =
							Some(UeRadioCapabilityForPagingOfNbIot::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ue_radio_capability_for_paging_of_nr,
			ue_radio_capability_for_paging_of_eutra,
			ue_radio_capability_for_paging_of_nb_iot,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.ue_radio_capability_for_paging_of_nb_iot {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 214, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.ue_radio_capability_for_paging_of_nr.is_some());
		optionals.push(self.ue_radio_capability_for_paging_of_eutra.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.ue_radio_capability_for_paging_of_nr {
			x.encode(data)?;
		}
		if let Some(x) = &self.ue_radio_capability_for_paging_of_eutra {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UeRadioCapabilityForPaging {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapabilityForPaging::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPaging");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPaging");
			e
		})
	}
}
// UeRadioCapabilityForPagingOfNbIot
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapabilityForPagingOfNbIot(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfNbIot {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UeRadioCapabilityForPagingOfNbIot {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapabilityForPagingOfNbIot::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfNbIot");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfNbIot");
			e
		})
	}
}
// UeRadioCapabilityForPagingOfNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapabilityForPagingOfNr(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UeRadioCapabilityForPagingOfNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapabilityForPagingOfNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfNr");
			e
		})
	}
}
// UeRadioCapabilityForPagingOfEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapabilityForPagingOfEutra(pub Vec<u8>);

impl UeRadioCapabilityForPagingOfEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UeRadioCapabilityForPagingOfEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapabilityForPagingOfEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityForPagingOfEutra");
			e
		})
	}
}
// UeRadioCapabilityId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeRadioCapabilityId(pub Vec<u8>);

impl UeRadioCapabilityId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(data, None, None, false)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UeRadioCapabilityId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRadioCapabilityId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRadioCapabilityId");
			e
		})
	}
}
// UeRetentionInformation
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeRetentionInformation {
	#[default]
	UesRetained,
}

impl UeRetentionInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeRetentionInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRetentionInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRetentionInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRetentionInformation");
			e
		})
	}
}
// UeRlfReportContainer
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UeRlfReportContainer {
	#[default]
	Nr(NrUeRlfReportContainer),
	Lte(LteUeRlfReportContainer),
}

impl UeRlfReportContainer {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::Nr(NrUeRlfReportContainer::decode(data)?)),
			1 => Ok(Self::Lte(LteUeRlfReportContainer::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::Nr(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::Lte(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for UeRlfReportContainer {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeRlfReportContainer::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRlfReportContainer");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeRlfReportContainer");
			e
		})
	}
}
// UeSecurityCapabilities
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeSecurityCapabilities {
	pub nr_encryption_algorithms: NrEncryptionAlgorithms,
	pub nr_integrity_protection_algorithms: NrIntegrityProtectionAlgorithms,
	pub eutr_aencryption_algorithms: EutrAencryptionAlgorithms,
	pub eutr_aintegrity_protection_algorithms: EutrAintegrityProtectionAlgorithms,
}

impl UeSecurityCapabilities {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let nr_encryption_algorithms = NrEncryptionAlgorithms::decode(data)?;
		let nr_integrity_protection_algorithms = NrIntegrityProtectionAlgorithms::decode(data)?;
		let eutr_aencryption_algorithms = EutrAencryptionAlgorithms::decode(data)?;
		let eutr_aintegrity_protection_algorithms =
			EutrAintegrityProtectionAlgorithms::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_encryption_algorithms,
			nr_integrity_protection_algorithms,
			eutr_aencryption_algorithms,
			eutr_aintegrity_protection_algorithms,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_encryption_algorithms.encode(data)?;
		self.nr_integrity_protection_algorithms.encode(data)?;
		self.eutr_aencryption_algorithms.encode(data)?;
		self.eutr_aintegrity_protection_algorithms.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UeSecurityCapabilities {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeSecurityCapabilities::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSecurityCapabilities");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSecurityCapabilities");
			e
		})
	}
}
// UeSliceMaximumBitRateList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeSliceMaximumBitRateList(pub NonEmpty<UeSliceMaximumBitRateItem>);

impl UeSliceMaximumBitRateList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(8), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UeSliceMaximumBitRateItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(8), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UeSliceMaximumBitRateList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeSliceMaximumBitRateList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSliceMaximumBitRateList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSliceMaximumBitRateList");
			e
		})
	}
}
// UeSliceMaximumBitRateItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UeSliceMaximumBitRateItem {
	pub snssai: Snssai,
	pub ue_slice_maximum_bit_rate_dl: BitRate,
	pub ue_slice_maximum_bit_rate_ul: BitRate,
}

impl UeSliceMaximumBitRateItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let snssai = Snssai::decode(data)?;
		let ue_slice_maximum_bit_rate_dl = BitRate::decode(data)?;
		let ue_slice_maximum_bit_rate_ul = BitRate::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			snssai,
			ue_slice_maximum_bit_rate_dl,
			ue_slice_maximum_bit_rate_ul,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.snssai.encode(data)?;
		self.ue_slice_maximum_bit_rate_dl.encode(data)?;
		self.ue_slice_maximum_bit_rate_ul.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UeSliceMaximumBitRateItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeSliceMaximumBitRateItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSliceMaximumBitRateItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSliceMaximumBitRateItem");
			e
		})
	}
}
// UeUpCIotSupport
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeUpCIotSupport {
	#[default]
	Supported,
}

impl UeUpCIotSupport {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeUpCIotSupport {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeUpCIotSupport::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeUpCIotSupport");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeUpCIotSupport");
			e
		})
	}
}
// UlCpSecurityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UlCpSecurityInformation {
	pub ul_nas_mac: UlNasMac,
	pub ul_nas_count: UlNasCount,
}

impl UlCpSecurityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ul_nas_mac = UlNasMac::decode(data)?;
		let ul_nas_count = UlNasCount::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_nas_mac,
			ul_nas_count,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ul_nas_mac.encode(data)?;
		self.ul_nas_count.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UlCpSecurityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlCpSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlCpSecurityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlCpSecurityInformation");
			e
		})
	}
}
// UlNasMac
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct UlNasMac(pub BitString);

impl UlNasMac {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(16),
			Some(16),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(16), Some(16), false, &self.0, false)
	}
}

impl PerCodec for UlNasMac {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlNasMac::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNasMac");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNasMac");
			e
		})
	}
}
// UlNasCount
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct UlNasCount(pub BitString);

impl UlNasCount {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(5),
			Some(5),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(5), Some(5), false, &self.0, false)
	}
}

impl PerCodec for UlNasCount {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlNasCount::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNasCount");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNasCount");
			e
		})
	}
}
// UlNguUpTnlModifyList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UlNguUpTnlModifyList(pub NonEmpty<UlNguUpTnlModifyItem>);

impl UlNguUpTnlModifyList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UlNguUpTnlModifyItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UlNguUpTnlModifyList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlNguUpTnlModifyList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNguUpTnlModifyList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNguUpTnlModifyList");
			e
		})
	}
}
// UlNguUpTnlModifyItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UlNguUpTnlModifyItem {
	pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
	pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
	pub redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
	pub redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation>,
}

impl UlNguUpTnlModifyItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ul_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

		// Process the extension container
		let mut redundant_ul_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;
		let mut redundant_dl_ngu_up_tnl_information: Option<UpTransportLayerInformation> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					195 => {
						redundant_ul_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					192 => {
						redundant_dl_ngu_up_tnl_information =
							Some(UpTransportLayerInformation::decode(data)?)
					}
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_ngu_up_tnl_information,
			dl_ngu_up_tnl_information,
			redundant_ul_ngu_up_tnl_information,
			redundant_dl_ngu_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.redundant_ul_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 195, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.redundant_dl_ngu_up_tnl_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 192, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ul_ngu_up_tnl_information.encode(data)?;
		self.dl_ngu_up_tnl_information.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UlNguUpTnlModifyItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlNguUpTnlModifyItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNguUpTnlModifyItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlNguUpTnlModifyItem");
			e
		})
	}
}
// UnavailableGuamiList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UnavailableGuamiList(pub NonEmpty<UnavailableGuamiItem>);

impl UnavailableGuamiList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(256), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UnavailableGuamiItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(256), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UnavailableGuamiList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UnavailableGuamiList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UnavailableGuamiList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UnavailableGuamiList");
			e
		})
	}
}
// UnavailableGuamiItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UnavailableGuamiItem {
	pub guami: Guami,
	pub timer_approach_for_guami_removal: Option<TimerApproachForGuamiRemoval>,
	pub backup_amf_name: Option<AmfName>,
}

impl UnavailableGuamiItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let guami = Guami::decode(data)?;
		let timer_approach_for_guami_removal = if optionals[0] {
			Some(TimerApproachForGuamiRemoval::decode(data)?)
		} else {
			None
		};
		let backup_amf_name = if optionals[1] {
			Some(AmfName::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			guami,
			timer_approach_for_guami_removal,
			backup_amf_name,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.timer_approach_for_guami_removal.is_some());
		optionals.push(self.backup_amf_name.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.guami.encode(data)?;
		if let Some(x) = &self.timer_approach_for_guami_removal {
			x.encode(data)?;
		}
		if let Some(x) = &self.backup_amf_name {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for UnavailableGuamiItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UnavailableGuamiItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UnavailableGuamiItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UnavailableGuamiItem");
			e
		})
	}
}
// UlForwarding
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UlForwarding {
	#[default]
	UlForwardingProposed,
}

impl UlForwarding {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UlForwarding {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UlForwarding::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlForwarding");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UlForwarding");
			e
		})
	}
}
// UpdateFeedback
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct UpdateFeedback(pub BitString);

impl UpdateFeedback {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_bitstring(
			data,
			Some(8),
			Some(8),
			true,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_bitstring(data, Some(8), Some(8), true, &self.0, false)
	}
}

impl PerCodec for UpdateFeedback {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpdateFeedback::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpdateFeedback");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpdateFeedback");
			e
		})
	}
}
// UpTransportLayerInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UpTransportLayerInformation {
	#[default]
	GtpTunnel(GtpTunnel),
}

impl UpTransportLayerInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::GtpTunnel(GtpTunnel::decode(data)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::GtpTunnel(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for UpTransportLayerInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpTransportLayerInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformation");
			e
		})
	}
}
// UpTransportLayerInformationList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UpTransportLayerInformationList(pub NonEmpty<UpTransportLayerInformationItem>);

impl UpTransportLayerInformationList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UpTransportLayerInformationItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UpTransportLayerInformationList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpTransportLayerInformationList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationList");
			e
		})
	}
}
// UpTransportLayerInformationItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UpTransportLayerInformationItem {
	pub ngu_up_tnl_information: UpTransportLayerInformation,
	pub common_network_instance: Option<CommonNetworkInstance>,
}

impl UpTransportLayerInformationItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

		// Process the extension container
		let mut common_network_instance: Option<CommonNetworkInstance> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					166 => common_network_instance = Some(CommonNetworkInstance::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ngu_up_tnl_information,
			common_network_instance,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.common_network_instance {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 166, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ngu_up_tnl_information.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UpTransportLayerInformationItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpTransportLayerInformationItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationItem");
			e
		})
	}
}
// UpTransportLayerInformationPairList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UpTransportLayerInformationPairList(pub NonEmpty<UpTransportLayerInformationPairItem>);

impl UpTransportLayerInformationPairList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(3), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(UpTransportLayerInformationPairItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(3), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for UpTransportLayerInformationPairList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpTransportLayerInformationPairList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationPairList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationPairList");
			e
		})
	}
}
// UpTransportLayerInformationPairItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UpTransportLayerInformationPairItem {
	pub ul_ngu_up_tnl_information: UpTransportLayerInformation,
	pub dl_ngu_up_tnl_information: UpTransportLayerInformation,
}

impl UpTransportLayerInformationPairItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ul_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;
		let dl_ngu_up_tnl_information = UpTransportLayerInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ul_ngu_up_tnl_information,
			dl_ngu_up_tnl_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ul_ngu_up_tnl_information.encode(data)?;
		self.dl_ngu_up_tnl_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UpTransportLayerInformationPairItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UpTransportLayerInformationPairItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationPairItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UpTransportLayerInformationPairItem");
			e
		})
	}
}
// UriAddress
#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd, Debug, smart_default::SmartDefault)]
pub struct UriAddress(pub String);

impl UriAddress {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_visible_string(
			data, None, None, false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_visible_string(data, None, None, false, &self.0, false)
	}
}

impl PerCodec for UriAddress {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UriAddress::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UriAddress");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UriAddress");
			e
		})
	}
}
// UserLocationInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UserLocationInformation {
	#[default]
	UserLocationInformationEutra(UserLocationInformationEutra),
	UserLocationInformationNr(UserLocationInformationNr),
	UserLocationInformationN3Iwf(UserLocationInformationN3Iwf),
	UserLocationInformationTngf(UserLocationInformationTngf),
	UserLocationInformationTwif(UserLocationInformationTwif),
	UserLocationInformationWAgf(UserLocationInformationWAgf),
}

impl UserLocationInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 3, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::UserLocationInformationEutra(
				UserLocationInformationEutra::decode(data)?,
			)),
			1 => Ok(Self::UserLocationInformationNr(
				UserLocationInformationNr::decode(data)?,
			)),
			2 => Ok(Self::UserLocationInformationN3Iwf(
				UserLocationInformationN3Iwf::decode(data)?,
			)),
			3 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					244 => Ok(Self::UserLocationInformationTngf(
						UserLocationInformationTngf::decode(data)?,
					)),
					248 => Ok(Self::UserLocationInformationTwif(
						UserLocationInformationTwif::decode(data)?,
					)),
					243 => Ok(Self::UserLocationInformationWAgf(
						UserLocationInformationWAgf::decode(data)?,
					)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::UserLocationInformationEutra(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 0, false)?;
				x.encode(data)
			}
			Self::UserLocationInformationNr(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 1, false)?;
				x.encode(data)
			}
			Self::UserLocationInformationN3Iwf(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 2, false)?;
				x.encode(data)
			}
			Self::UserLocationInformationTngf(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 244, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::UserLocationInformationTwif(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 248, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::UserLocationInformationWAgf(x) => {
				encode::encode_choice_idx(data, 0, 3, false, 3, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 243, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for UserLocationInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformation");
			e
		})
	}
}
// UserLocationInformationEutra
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserLocationInformationEutra {
	pub eutra_cgi: EutraCgi,
	pub tai: Tai,
	pub time_stamp: Option<TimeStamp>,
	pub ps_cell_information: Option<NgranCgi>,
}

impl UserLocationInformationEutra {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let eutra_cgi = EutraCgi::decode(data)?;
		let tai = Tai::decode(data)?;
		let time_stamp = if optionals[0] {
			Some(TimeStamp::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut ps_cell_information: Option<NgranCgi> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					149 => ps_cell_information = Some(NgranCgi::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			eutra_cgi,
			tai,
			time_stamp,
			ps_cell_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.ps_cell_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 149, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.time_stamp.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.eutra_cgi.encode(data)?;
		self.tai.encode(data)?;
		if let Some(x) = &self.time_stamp {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UserLocationInformationEutra {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationEutra::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationEutra");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationEutra");
			e
		})
	}
}
// UserLocationInformationN3Iwf
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserLocationInformationN3Iwf {
	pub ip_address: TransportLayerAddress,
	pub port_number: PortNumber,
	pub tai: Option<Tai>,
}

impl UserLocationInformationN3Iwf {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let ip_address = TransportLayerAddress::decode(data)?;
		let port_number = PortNumber::decode(data)?;

		// Process the extension container
		let mut tai: Option<Tai> = None;

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					213 => tai = Some(Tai::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			ip_address,
			port_number,
			tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tai {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.ip_address.encode(data)?;
		self.port_number.encode(data)?;
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UserLocationInformationN3Iwf {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationN3Iwf::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationN3Iwf");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationN3Iwf");
			e
		})
	}
}
// UserLocationInformationTngf
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserLocationInformationTngf {
	pub tnap_id: TnapId,
	pub ip_address: TransportLayerAddress,
	pub port_number: Option<PortNumber>,
	pub tai: Option<Tai>,
}

impl UserLocationInformationTngf {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let tnap_id = TnapId::decode(data)?;
		let ip_address = TransportLayerAddress::decode(data)?;
		let port_number = if optionals[0] {
			Some(PortNumber::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut tai: Option<Tai> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					213 => tai = Some(Tai::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			tnap_id,
			ip_address,
			port_number,
			tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tai {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.port_number.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.tnap_id.encode(data)?;
		self.ip_address.encode(data)?;
		if let Some(x) = &self.port_number {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UserLocationInformationTngf {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationTngf::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationTngf");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationTngf");
			e
		})
	}
}
// UserLocationInformationTwif
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserLocationInformationTwif {
	pub twap_id: TwapId,
	pub ip_address: TransportLayerAddress,
	pub port_number: Option<PortNumber>,
	pub tai: Option<Tai>,
}

impl UserLocationInformationTwif {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let twap_id = TwapId::decode(data)?;
		let ip_address = TransportLayerAddress::decode(data)?;
		let port_number = if optionals[0] {
			Some(PortNumber::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut tai: Option<Tai> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					213 => tai = Some(Tai::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			twap_id,
			ip_address,
			port_number,
			tai,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.tai {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 213, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.port_number.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.twap_id.encode(data)?;
		self.ip_address.encode(data)?;
		if let Some(x) = &self.port_number {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UserLocationInformationTwif {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationTwif::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationTwif");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationTwif");
			e
		})
	}
}
// UserLocationInformationWAgf
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum UserLocationInformationWAgf {
	#[default]
	GlobalLineId(GlobalLineId),
	HfcNodeId(HfcNodeId),
	GlobalCableId(GlobalCableId),
	HfcNodeIdNew(HfcNodeIdNew),
	GlobalCableIdNew(GlobalCableIdNew),
}

impl UserLocationInformationWAgf {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 2, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::GlobalLineId(GlobalLineId::decode(data)?)),
			1 => Ok(Self::HfcNodeId(HfcNodeId::decode(data)?)),
			2 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					275 => Ok(Self::GlobalCableId(GlobalCableId::decode(data)?)),
					362 => Ok(Self::HfcNodeIdNew(HfcNodeIdNew::decode(data)?)),
					363 => Ok(Self::GlobalCableIdNew(GlobalCableIdNew::decode(data)?)),
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::GlobalLineId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 0, false)?;
				x.encode(data)
			}
			Self::HfcNodeId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 1, false)?;
				x.encode(data)
			}
			Self::GlobalCableId(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 275, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::HfcNodeIdNew(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 362, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
			Self::GlobalCableIdNew(x) => {
				encode::encode_choice_idx(data, 0, 2, false, 2, false)?;
				encode::encode_integer(data, Some(0), Some(65535), false, 363, false)?;
				Criticality::Ignore.encode(data)?;
				let ie = &mut Allocator::new_codec_data();
				x.encode(ie)?;
				encode::encode_length_determinent(data, None, None, false, ie.length_in_bytes())?;
				Ok(data.append_aligned(ie))
			}
		}
	}
}

impl PerCodec for UserLocationInformationWAgf {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationWAgf::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationWAgf");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationWAgf");
			e
		})
	}
}
// UserLocationInformationNr
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserLocationInformationNr {
	pub nr_cgi: NrCgi,
	pub tai: Tai,
	pub time_stamp: Option<TimeStamp>,
	pub ps_cell_information: Option<NgranCgi>,
	pub nid: Option<Nid>,
	pub nr_ntntai_information: Option<NrNtntaiInformation>,
}

impl UserLocationInformationNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let nr_cgi = NrCgi::decode(data)?;
		let tai = Tai::decode(data)?;
		let time_stamp = if optionals[0] {
			Some(TimeStamp::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut ps_cell_information: Option<NgranCgi> = None;
		let mut nid: Option<Nid> = None;
		let mut nr_ntntai_information: Option<NrNtntaiInformation> = None;

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					149 => ps_cell_information = Some(NgranCgi::decode(data)?),
					263 => nid = Some(Nid::decode(data)?),
					287 => nr_ntntai_information = Some(NrNtntaiInformation::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			nr_cgi,
			tai,
			time_stamp,
			ps_cell_information,
			nid,
			nr_ntntai_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.ps_cell_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 149, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.nid {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 263, false)?;
			Criticality::Reject.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		if let Some(x) = &self.nr_ntntai_information {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 287, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.time_stamp.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.nr_cgi.encode(data)?;
		self.tai.encode(data)?;
		if let Some(x) = &self.time_stamp {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for UserLocationInformationNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserLocationInformationNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserLocationInformationNr");
			e
		})
	}
}
// UserPlaneSecurityInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct UserPlaneSecurityInformation {
	pub security_result: SecurityResult,
	pub security_indication: SecurityIndication,
}

impl UserPlaneSecurityInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let security_result = SecurityResult::decode(data)?;
		let security_indication = SecurityIndication::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			security_result,
			security_indication,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.security_result.encode(data)?;
		self.security_indication.encode(data)?;

		Ok(())
	}
}

impl PerCodec for UserPlaneSecurityInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UserPlaneSecurityInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserPlaneSecurityInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UserPlaneSecurityInformation");
			e
		})
	}
}
// VolumeTimedReportList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct VolumeTimedReportList(pub NonEmpty<VolumeTimedReportItem>);

impl VolumeTimedReportList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(VolumeTimedReportItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for VolumeTimedReportList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		VolumeTimedReportList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VolumeTimedReportList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VolumeTimedReportList");
			e
		})
	}
}
// VolumeTimedReportItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct VolumeTimedReportItem {
	pub start_time_stamp: [u8; 4],
	pub end_time_stamp: [u8; 4],
	pub usage_count_ul: u64,
	pub usage_count_dl: u64,
}

impl VolumeTimedReportItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let start_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
			.try_into()
			.unwrap();
		let end_time_stamp = decode::decode_octetstring(data, Some(4), Some(4), false)?
			.try_into()
			.unwrap();
		let usage_count_ul = decode::decode_integer(data, Some(0), None, false)?.0 as u64;
		let usage_count_dl = decode::decode_integer(data, Some(0), None, false)?.0 as u64;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			start_time_stamp,
			end_time_stamp,
			usage_count_ul,
			usage_count_dl,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		encode::encode_octetstring(
			data,
			Some(4),
			Some(4),
			false,
			&(self.start_time_stamp).into(),
			false,
		)?;
		encode::encode_octetstring(
			data,
			Some(4),
			Some(4),
			false,
			&(self.end_time_stamp).into(),
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			None,
			false,
			self.usage_count_ul as i128,
			false,
		)?;
		encode::encode_integer(
			data,
			Some(0),
			None,
			false,
			self.usage_count_dl as i128,
			false,
		)?;

		Ok(())
	}
}

impl PerCodec for VolumeTimedReportItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		VolumeTimedReportItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VolumeTimedReportItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("VolumeTimedReportItem");
			e
		})
	}
}
// WAgfId
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum WAgfId {
	#[default]
	WAgfId(BitString),
}

impl WAgfId {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 1, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::WAgfId(decode::decode_bitstring(
				data,
				Some(16),
				Some(16),
				true,
			)?)),
			1 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::WAgfId(x) => {
				encode::encode_choice_idx(data, 0, 1, false, 0, false)?;
				encode::encode_bitstring(data, Some(16), Some(16), true, &x, false)
			}
		}
	}
}

impl PerCodec for WAgfId {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WAgfId::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WAgfId");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WAgfId");
			e
		})
	}
}
// WarningAreaCoordinates
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WarningAreaCoordinates(pub Vec<u8>);

impl WarningAreaCoordinates {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(
			data,
			Some(1),
			Some(1024),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(1), Some(1024), false, &self.0, false)
	}
}

impl PerCodec for WarningAreaCoordinates {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WarningAreaCoordinates::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningAreaCoordinates");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningAreaCoordinates");
			e
		})
	}
}
// WarningAreaList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub enum WarningAreaList {
	#[default]
	EutraCgiListForWarning(EutraCgiListForWarning),
	NrCgiListForWarning(NrCgiListForWarning),
	TaiListForWarning(TaiListForWarning),
	EmergencyAreaIdList(EmergencyAreaIdList),
}

impl WarningAreaList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_choice_idx(data, 0, 4, false)?;
		if extended {
			return Err(PerCodecError::new("CHOICE additions not implemented"));
		}
		match idx {
			0 => Ok(Self::EutraCgiListForWarning(
				EutraCgiListForWarning::decode(data)?,
			)),
			1 => Ok(Self::NrCgiListForWarning(NrCgiListForWarning::decode(
				data,
			)?)),
			2 => Ok(Self::TaiListForWarning(TaiListForWarning::decode(data)?)),
			3 => Ok(Self::EmergencyAreaIdList(EmergencyAreaIdList::decode(
				data,
			)?)),
			4 => {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _ = Criticality::decode(data)?;
				let _ = decode::decode_length_determinent(data, None, None, false)?;
				let result = match id {
					x => Err(PerCodecError::new(format!("Unrecognised IE type {}", x))),
				};
				data.decode_align()?;
				result
			}
			_ => Err(PerCodecError::new("Unknown choice idx")),
		}
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		match self {
			Self::EutraCgiListForWarning(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 0, false)?;
				x.encode(data)
			}
			Self::NrCgiListForWarning(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 1, false)?;
				x.encode(data)
			}
			Self::TaiListForWarning(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 2, false)?;
				x.encode(data)
			}
			Self::EmergencyAreaIdList(x) => {
				encode::encode_choice_idx(data, 0, 4, false, 3, false)?;
				x.encode(data)
			}
		}
	}
}

impl PerCodec for WarningAreaList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WarningAreaList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningAreaList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningAreaList");
			e
		})
	}
}
// WarningMessageContents
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WarningMessageContents(pub Vec<u8>);

impl WarningMessageContents {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(
			data,
			Some(1),
			Some(9600),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(1), Some(9600), false, &self.0, false)
	}
}

impl PerCodec for WarningMessageContents {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WarningMessageContents::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningMessageContents");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningMessageContents");
			e
		})
	}
}
// WarningSecurityInfo
#[derive(Clone, Debug)]
pub struct WarningSecurityInfo(pub [u8; 50]);
impl Default for WarningSecurityInfo {
	fn default() -> WarningSecurityInfo {
		let init = std::mem::MaybeUninit::<[u8; 50]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		WarningSecurityInfo(default_value)
	}
}
impl WarningSecurityInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(50), Some(50), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(50), Some(50), false, &(self.0).into(), false)
	}
}

impl PerCodec for WarningSecurityInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WarningSecurityInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningSecurityInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningSecurityInfo");
			e
		})
	}
}
// WarningType
#[derive(Clone, Debug)]
pub struct WarningType(pub [u8; 2]);
impl Default for WarningType {
	fn default() -> WarningType {
		let init = std::mem::MaybeUninit::<[u8; 2]>::zeroed();
		// SAFETY: No pointers present for the assume init here
		// TODO: Evaluate the performance issues: "https://users.rust-lang.org/t/unnecessary-performance-penalty-for-mem-maybeuninit/84063"
		let default_value = unsafe { init.assume_init() };
		WarningType(default_value)
	}
}
impl WarningType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(
			decode::decode_octetstring(data, Some(2), Some(2), false)?
				.try_into()
				.unwrap(),
		))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(2), Some(2), false, &(self.0).into(), false)
	}
}

impl PerCodec for WarningType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WarningType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WarningType");
			e
		})
	}
}
// WlanMeasurementConfiguration
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WlanMeasurementConfiguration {
	pub wlan_meas_config: WlanMeasConfig,
	pub wlan_meas_config_name_list: Option<WlanMeasConfigNameList>,
	pub wlan_rssi: Option<WlanRssi>,
	pub wlan_rtt: Option<WlanRtt>,
}

impl WlanMeasurementConfiguration {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 4)?;
		let wlan_meas_config = WlanMeasConfig::decode(data)?;
		let wlan_meas_config_name_list = if optionals[0] {
			Some(WlanMeasConfigNameList::decode(data)?)
		} else {
			None
		};
		let wlan_rssi = if optionals[1] {
			Some(WlanRssi::decode(data)?)
		} else {
			None
		};
		let wlan_rtt = if optionals[2] {
			Some(WlanRtt::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[3] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			wlan_meas_config,
			wlan_meas_config_name_list,
			wlan_rssi,
			wlan_rtt,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.wlan_meas_config_name_list.is_some());
		optionals.push(self.wlan_rssi.is_some());
		optionals.push(self.wlan_rtt.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.wlan_meas_config.encode(data)?;
		if let Some(x) = &self.wlan_meas_config_name_list {
			x.encode(data)?;
		}
		if let Some(x) = &self.wlan_rssi {
			x.encode(data)?;
		}
		if let Some(x) = &self.wlan_rtt {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for WlanMeasurementConfiguration {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanMeasurementConfiguration::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasurementConfiguration");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasurementConfiguration");
			e
		})
	}
}
// WlanMeasConfigNameList
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WlanMeasConfigNameList(pub NonEmpty<WlanMeasConfigNameItem>);

impl WlanMeasConfigNameList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(4), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(WlanMeasConfigNameItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(4), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for WlanMeasConfigNameList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanMeasConfigNameList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfigNameList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfigNameList");
			e
		})
	}
}
// WlanMeasConfigNameItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WlanMeasConfigNameItem {
	pub wlan_name: WlanName,
}

impl WlanMeasConfigNameItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let wlan_name = WlanName::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self { wlan_name })
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.wlan_name.encode(data)?;

		Ok(())
	}
}

impl PerCodec for WlanMeasConfigNameItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanMeasConfigNameItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfigNameItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfigNameItem");
			e
		})
	}
}
// WlanMeasConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum WlanMeasConfig {
	#[default]
	Setup,
}

impl WlanMeasConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for WlanMeasConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanMeasConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanMeasConfig");
			e
		})
	}
}
// WlanName
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WlanName(pub Vec<u8>);

impl WlanName {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self(decode::decode_octetstring(
			data,
			Some(1),
			Some(32),
			false,
		)?))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_octetstring(data, Some(1), Some(32), false, &self.0, false)
	}
}

impl PerCodec for WlanName {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanName::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanName");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanName");
			e
		})
	}
}
// WusAssistanceInformation
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct WusAssistanceInformation {
	pub paging_probability_information: PagingProbabilityInformation,
}

impl WusAssistanceInformation {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 1)?;
		let paging_probability_information = PagingProbabilityInformation::decode(data)?;

		// Process the extension container

		if optionals[0] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			paging_probability_information,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.paging_probability_information.encode(data)?;

		Ok(())
	}
}

impl PerCodec for WusAssistanceInformation {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WusAssistanceInformation::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WusAssistanceInformation");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WusAssistanceInformation");
			e
		})
	}
}
// XnExtTlAs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct XnExtTlAs(pub NonEmpty<XnExtTlaItem>);

impl XnExtTlAs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(XnExtTlaItem::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for XnExtTlAs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		XnExtTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnExtTlAs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnExtTlAs");
			e
		})
	}
}
// XnExtTlaItem
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct XnExtTlaItem {
	pub i_psec_tla: Option<TransportLayerAddress>,
	pub gtp_tl_as: Option<XnGtpTlAs>,
	pub sctp_tl_as: Option<SctpTlAs>,
}

impl XnExtTlaItem {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 3)?;
		let i_psec_tla = if optionals[0] {
			Some(TransportLayerAddress::decode(data)?)
		} else {
			None
		};
		let gtp_tl_as = if optionals[1] {
			Some(XnGtpTlAs::decode(data)?)
		} else {
			None
		};

		// Process the extension container
		let mut sctp_tl_as: Option<SctpTlAs> = None;

		if optionals[2] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					173 => sctp_tl_as = Some(SctpTlAs::decode(data)?),
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			i_psec_tla,
			gtp_tl_as,
			sctp_tl_as,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut num_ies = 0;
		let ies = &mut Allocator::new_codec_data();
		if let Some(x) = &self.sctp_tl_as {
			let ie = &mut Allocator::new_codec_data();
			x.encode(ie)?;
			encode::encode_integer(ies, Some(0), Some(65535), false, 173, false)?;
			Criticality::Ignore.encode(ies)?;
			encode::encode_length_determinent(ies, None, None, false, ie.length_in_bytes())?;
			ies.append_aligned(ie);
			num_ies += 1;
		}

		let mut optionals = BitString::new();
		optionals.push(self.i_psec_tla.is_some());
		optionals.push(self.gtp_tl_as.is_some());
		optionals.push(num_ies != 0);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		if let Some(x) = &self.i_psec_tla {
			x.encode(data)?;
		}
		if let Some(x) = &self.gtp_tl_as {
			x.encode(data)?;
		}
		if num_ies != 0 {
			encode::encode_length_determinent(data, Some(1), Some(65535), false, num_ies)?;
			data.append_aligned(ies);
		}
		Ok(())
	}
}

impl PerCodec for XnExtTlaItem {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		XnExtTlaItem::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnExtTlaItem");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnExtTlaItem");
			e
		})
	}
}
// XnGtpTlAs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct XnGtpTlAs(pub NonEmpty<TransportLayerAddress>);

impl XnGtpTlAs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(16), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TransportLayerAddress::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(16), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for XnGtpTlAs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		XnGtpTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnGtpTlAs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnGtpTlAs");
			e
		})
	}
}
// XnTlAs
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct XnTlAs(pub NonEmpty<TransportLayerAddress>);

impl XnTlAs {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Ok(Self({
			let length = decode::decode_length_determinent(data, Some(1), Some(2), false)?;
			let mut items = vec![];
			for _ in 0..length {
				items.push(TransportLayerAddress::decode(data)?);
			}
			NonEmpty::from_vec(items).unwrap()
		}))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_length_determinent(data, Some(1), Some(2), false, self.0.len())?;
		for x in &self.0 {
			x.encode(data)?;
		}
		Ok(())
	}
}

impl PerCodec for XnTlAs {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		XnTlAs::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnTlAs");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnTlAs");
			e
		})
	}
}
// XnTnlConfigurationInfo
#[derive(Clone, Debug, smart_default::SmartDefault)]
pub struct XnTnlConfigurationInfo {
	pub xn_transport_layer_addresses: XnTlAs,
	pub xn_extended_transport_layer_addresses: Option<XnExtTlAs>,
}

impl XnTnlConfigurationInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (optionals, _extensions_present) = decode::decode_sequence_header(data, true, 2)?;
		let xn_transport_layer_addresses = XnTlAs::decode(data)?;
		let xn_extended_transport_layer_addresses = if optionals[0] {
			Some(XnExtTlAs::decode(data)?)
		} else {
			None
		};

		// Process the extension container

		if optionals[1] {
			let num_ies = decode::decode_length_determinent(data, Some(1), Some(65535), false)?;
			for _ in 0..num_ies {
				let (id, _ext) = decode::decode_integer(data, Some(0), Some(65535), false)?;
				let _criticality = Criticality::decode(data)?;
				let ie_length = decode::decode_length_determinent(data, None, None, false)?;
				match id {
					_ => data.advance_maybe_err(ie_length, false)?,
				}
				data.decode_align()?;
			}
		}
		Ok(Self {
			xn_transport_layer_addresses,
			xn_extended_transport_layer_addresses,
		})
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		let mut optionals = BitString::new();
		optionals.push(self.xn_extended_transport_layer_addresses.is_some());
		optionals.push(false);

		encode::encode_sequence_header(data, true, &optionals, false)?;
		self.xn_transport_layer_addresses.encode(data)?;
		if let Some(x) = &self.xn_extended_transport_layer_addresses {
			x.encode(data)?;
		}

		Ok(())
	}
}

impl PerCodec for XnTnlConfigurationInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		XnTnlConfigurationInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnTnlConfigurationInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("XnTnlConfigurationInfo");
			e
		})
	}
}
// PniNpnRestricted
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PniNpnRestricted {
	#[default]
	Restricted,
	NotRestricted,
}

impl PniNpnRestricted {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PniNpnRestricted {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PniNpnRestricted::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PniNpnRestricted");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PniNpnRestricted");
			e
		})
	}
}
// QosFlowMappingIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum QosFlowMappingIndication {
	#[default]
	Ul,
	Dl,
}

impl QosFlowMappingIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for QosFlowMappingIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QosFlowMappingIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowMappingIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QosFlowMappingIndication");
			e
		})
	}
}
// ApplicationLayerBufferLevelList
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum ApplicationLayerBufferLevelList {
	#[default]
	True,
}

impl ApplicationLayerBufferLevelList {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for ApplicationLayerBufferLevelList {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		ApplicationLayerBufferLevelList::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ApplicationLayerBufferLevelList");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("ApplicationLayerBufferLevelList");
			e
		})
	}
}
// PlayoutDelayForMediaStartup
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PlayoutDelayForMediaStartup {
	#[default]
	True,
}

impl PlayoutDelayForMediaStartup {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for PlayoutDelayForMediaStartup {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PlayoutDelayForMediaStartup::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlayoutDelayForMediaStartup");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PlayoutDelayForMediaStartup");
			e
		})
	}
}
// Rsrp
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum Rsrp {
	#[default]
	True,
}

impl Rsrp {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for Rsrp {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Rsrp::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsrp");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsrp");
			e
		})
	}
}
// Rsrq
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum Rsrq {
	#[default]
	True,
}

impl Rsrq {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for Rsrq {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Rsrq::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsrq");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Rsrq");
			e
		})
	}
}
// SiNr
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum SiNr {
	#[default]
	True,
}

impl SiNr {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for SiNr {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		SiNr::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SiNr");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("SiNr");
			e
		})
	}
}
// BtRssi
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum BtRssi {
	#[default]
	True,
}

impl BtRssi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for BtRssi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BtRssi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BtRssi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BtRssi");
			e
		})
	}
}
// CnType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum CnType {
	#[default]
	EpcForbidden,
	FiveGcForbidden,
}

impl CnType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for CnType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		CnType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("CnType");
			e
		})
	}
}
// DapsIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum DapsIndicator {
	#[default]
	DapsHoRequired,
}

impl DapsIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for DapsIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		DapsIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("DapsIndicator");
			e
		})
	}
}
// Dapsresponseindicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum Dapsresponseindicator {
	#[default]
	DapsHoAccepted,
	DapsHoNotAccepted,
}

impl Dapsresponseindicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for Dapsresponseindicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		Dapsresponseindicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Dapsresponseindicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("Dapsresponseindicator");
			e
		})
	}
}
// OutOfCoverage
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum OutOfCoverage {
	#[default]
	True,
}

impl OutOfCoverage {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for OutOfCoverage {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		OutOfCoverage::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OutOfCoverage");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("OutOfCoverage");
			e
		})
	}
}
// HandoverReportType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum HandoverReportType {
	#[default]
	HoTooEarly,
	HoToWrongCell,
	IntersystemPingPong,
}

impl HandoverReportType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for HandoverReportType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		HandoverReportType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverReportType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("HandoverReportType");
			e
		})
	}
}
// NotifyFlag
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NotifyFlag {
	#[default]
	Activated,
	Deactivated,
}

impl NotifyFlag {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for NotifyFlag {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NotifyFlag::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotifyFlag");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NotifyFlag");
			e
		})
	}
}
// EarlyIratho
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum EarlyIratho {
	#[default]
	True,
	False,
}

impl EarlyIratho {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for EarlyIratho {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		EarlyIratho::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EarlyIratho");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("EarlyIratho");
			e
		})
	}
}
// NgapProtocolIeSupportInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NgapProtocolIeSupportInfo {
	#[default]
	Supported,
	NotSupported,
}

impl NgapProtocolIeSupportInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for NgapProtocolIeSupportInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapProtocolIeSupportInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapProtocolIeSupportInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapProtocolIeSupportInfo");
			e
		})
	}
}
// NgapProtocolIePresenceInfo
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum NgapProtocolIePresenceInfo {
	#[default]
	Present,
	NotPresent,
}

impl NgapProtocolIePresenceInfo {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for NgapProtocolIePresenceInfo {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		NgapProtocolIePresenceInfo::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapProtocolIePresenceInfo");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("NgapProtocolIePresenceInfo");
			e
		})
	}
}
// RatType
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RatType {
	#[default]
	Nr,
	Eutra,
}

impl RatType {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RatType {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatType::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatType");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatType");
			e
		})
	}
}
// RatType1
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RatType1 {
	#[default]
	Nr,
	Eutra,
}

impl RatType1 {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RatType1 {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RatType1::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatType1");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RatType1");
			e
		})
	}
}
// RimRsDetection
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum RimRsDetection {
	#[default]
	RsDetected,
	RsDisappeared,
}

impl RimRsDetection {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for RimRsDetection {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		RimRsDetection::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimRsDetection");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("RimRsDetection");
			e
		})
	}
}
// UncompensatedBarometricConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UncompensatedBarometricConfig {
	#[default]
	True,
}

impl UncompensatedBarometricConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UncompensatedBarometricConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UncompensatedBarometricConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UncompensatedBarometricConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UncompensatedBarometricConfig");
			e
		})
	}
}
// UeSpeedConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeSpeedConfig {
	#[default]
	True,
}

impl UeSpeedConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeSpeedConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeSpeedConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSpeedConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeSpeedConfig");
			e
		})
	}
}
// UeOrientationConfig
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum UeOrientationConfig {
	#[default]
	True,
}

impl UeOrientationConfig {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for UeOrientationConfig {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		UeOrientationConfig::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeOrientationConfig");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("UeOrientationConfig");
			e
		})
	}
}
// TimeDistributionIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TimeDistributionIndication {
	#[default]
	Enabled,
	Disabled,
}

impl TimeDistributionIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for TimeDistributionIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TimeDistributionIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeDistributionIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TimeDistributionIndication");
			e
		})
	}
}
// QoEMeasurementStatus
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum QoEMeasurementStatus {
	#[default]
	Ongoing,
}

impl QoEMeasurementStatus {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for QoEMeasurementStatus {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		QoEMeasurementStatus::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEMeasurementStatus");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("QoEMeasurementStatus");
			e
		})
	}
}
// PeriodicCommunicationIndicator
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum PeriodicCommunicationIndicator {
	#[default]
	Periodically,
	Ondemand,
}

impl PeriodicCommunicationIndicator {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for PeriodicCommunicationIndicator {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		PeriodicCommunicationIndicator::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicCommunicationIndicator");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("PeriodicCommunicationIndicator");
			e
		})
	}
}
// StationaryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum StationaryIndication {
	#[default]
	Stationary,
	Mobile,
}

impl StationaryIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(1), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(1), true, *self as i128, false)
	}
}

impl PerCodec for StationaryIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		StationaryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("StationaryIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("StationaryIndication");
			e
		})
	}
}
// TrafficProfile
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum TrafficProfile {
	#[default]
	SinglePacket,
	DualPackets,
	MultiplePackets,
}

impl TrafficProfile {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for TrafficProfile {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		TrafficProfile::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TrafficProfile");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("TrafficProfile");
			e
		})
	}
}
// BatteryIndication
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum BatteryIndication {
	#[default]
	BatteryPowered,
	BatteryPoweredNotRechargeableOrReplaceable,
	NotBatteryPowered,
}

impl BatteryIndication {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(2), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(2), true, *self as i128, false)
	}
}

impl PerCodec for BatteryIndication {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		BatteryIndication::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BatteryIndication");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("BatteryIndication");
			e
		})
	}
}
// WlanRssi
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum WlanRssi {
	#[default]
	True,
}

impl WlanRssi {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for WlanRssi {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanRssi::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanRssi");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanRssi");
			e
		})
	}
}
// WlanRtt
#[derive(Clone, Debug, Copy, TryFromPrimitive, smart_default::SmartDefault)]
#[repr(u8)]
pub enum WlanRtt {
	#[default]
	True,
}

impl WlanRtt {
	fn decode_inner(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		let (idx, extended) = decode::decode_enumerated(data, Some(0), Some(0), true)?;
		if extended {
			return Err(PerCodecError::new("Extended enum not implemented"));
		}
		Self::try_from(idx as u8).map_err(|_| PerCodecError::new("Unknown enum variant"))
	}
	fn encode_inner(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		encode::encode_enumerated(data, Some(0), Some(0), true, *self as i128, false)
	}
}

impl PerCodec for WlanRtt {
	type Allocator = Allocator;
	fn decode(data: &mut PerCodecData) -> Result<Self, PerCodecError> {
		WlanRtt::decode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanRtt");
			e
		})
	}
	fn encode(
		&self,
		data: &mut PerCodecData,
	) -> Result<(), PerCodecError> {
		self.encode_inner(data).map_err(|mut e: PerCodecError| {
			e.push_context("WlanRtt");
			e
		})
	}
}
